/*!
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */
(function (t) {
  const e = (t["en"] = t["en"] || {});
  e.dictionary = Object.assign(e.dictionary || {}, {
    "%0 of %1": "%0 of %1",
    "Block quote": "Block quote",
    Bold: "Bold",
    "Bulleted List": "Bulleted List",
    Cancel: "Cancel",
    "Change image text alternative": "Change image text alternative",
    "Characters: %0": "Characters: %0",
    "Choose heading": "Choose heading",
    "Decrease indent": "Decrease indent",
    Downloadable: "Downloadable",
    "Dropdown toolbar": "Dropdown toolbar",
    "Edit link": "Edit link",
    "Editor toolbar": "Editor toolbar",
    Heading: "Heading",
    "Heading 1": "Heading 1",
    "Heading 2": "Heading 2",
    "Heading 3": "Heading 3",
    "Heading 4": "Heading 4",
    "Heading 5": "Heading 5",
    "Heading 6": "Heading 6",
    "Image toolbar": "Image toolbar",
    "image widget": "image widget",
    "Increase indent": "Increase indent",
    "Insert image": "Insert image",
    "Insert paragraph after block": "Insert paragraph after block",
    "Insert paragraph before block": "Insert paragraph before block",
    Link: "Link",
    "Link URL": "Link URL",
    Next: "Next",
    "Numbered List": "Numbered List",
    "Open in a new tab": "Open in a new tab",
    "Open link in new tab": "Open link in new tab",
    Paragraph: "Paragraph",
    Previous: "Previous",
    Redo: "Redo",
    "Rich Text Editor, %0": "Rich Text Editor, %0",
    Save: "Save",
    "Select all": "Select all",
    "Show more items": "Show more items",
    Strikethrough: "Strikethrough",
    "Text alternative": "Text alternative",
    "This link has no URL": "This link has no URL",
    Underline: "Underline",
    Undo: "Undo",
    Unlink: "Unlink",
    "Upload failed": "Upload failed",
    "Upload in progress": "Upload in progress",
    "Widget toolbar": "Widget toolbar",
    "Words: %0": "Words: %0",
  });
})(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {}));
(function t(e, n) {
  if (typeof exports === "object" && typeof module === "object")
    module.exports = n();
  else if (typeof define === "function" && define.amd) define([], n);
  else if (typeof exports === "object") exports["InlineEditor"] = n();
  else e["InlineEditor"] = n();
})(window, function () {
  return (function (t) {
    var e = {};
    function n(o) {
      if (e[o]) {
        return e[o].exports;
      }
      var i = (e[o] = { i: o, l: false, exports: {} });
      t[o].call(i.exports, i, i.exports, n);
      i.l = true;
      return i.exports;
    }
    n.m = t;
    n.c = e;
    n.d = function (t, e, o) {
      if (!n.o(t, e)) {
        Object.defineProperty(t, e, { enumerable: true, get: o });
      }
    };
    n.r = function (t) {
      if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        Object.defineProperty(t, Symbol.toStringTag, { value: "Module" });
      }
      Object.defineProperty(t, "__esModule", { value: true });
    };
    n.t = function (t, e) {
      if (e & 1) t = n(t);
      if (e & 8) return t;
      if (e & 4 && typeof t === "object" && t && t.__esModule) return t;
      var o = Object.create(null);
      n.r(o);
      Object.defineProperty(o, "default", { enumerable: true, value: t });
      if (e & 2 && typeof t != "string")
        for (var i in t)
          n.d(
            o,
            i,
            function (e) {
              return t[e];
            }.bind(null, i)
          );
      return o;
    };
    n.n = function (t) {
      var e =
        t && t.__esModule
          ? function e() {
              return t["default"];
            }
          : function e() {
              return t;
            };
      n.d(e, "a", e);
      return e;
    };
    n.o = function (t, e) {
      return Object.prototype.hasOwnProperty.call(t, e);
    };
    n.p = "";
    return n((n.s = 45));
  })([
    function (t, e, n) {
      "use strict";
      n.d(e, "a", function () {
        return i;
      });
      n.d(e, "c", function () {
        return r;
      });
      n.d(e, "b", function () {
        return s;
      });
      const o =
        "https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html";
      class i extends Error {
        constructor(t, e, n) {
          const o = `${t}${n ? ` ${JSON.stringify(n)}` : ""}${a(t)}`;
          super(o);
          this.name = "CKEditorError";
          this.context = e;
          this.data = n;
        }
        is(t) {
          return t === "CKEditorError";
        }
        static rethrowUnexpectedError(t, e) {
          if (t.is && t.is("CKEditorError")) {
            throw t;
          }
          const n = new i(t.message, e);
          n.stack = t.stack;
          throw n;
        }
      }
      function r(t, e) {
        console.warn(...c(t, e));
      }
      function s(t, e) {
        console.error(...c(t, e));
      }
      function a(t) {
        return `\nRead more: ${o}#error-${t}`;
      }
      function c(t, e) {
        const n = a(t);
        return e ? [t, e, n] : [t, n];
      }
    },
    function (t, e, n) {
      "use strict";
      var o = (function t() {
        var e;
        return function t() {
          if (typeof e === "undefined") {
            e = Boolean(window && document && document.all && !window.atob);
          }
          return e;
        };
      })();
      var i = (function t() {
        var e = {};
        return function t(n) {
          if (typeof e[n] === "undefined") {
            var o = document.querySelector(n);
            if (
              window.HTMLIFrameElement &&
              o instanceof window.HTMLIFrameElement
            ) {
              try {
                o = o.contentDocument.head;
              } catch (t) {
                o = null;
              }
            }
            e[n] = o;
          }
          return e[n];
        };
      })();
      var r = [];
      function s(t) {
        var e = -1;
        for (var n = 0; n < r.length; n++) {
          if (r[n].identifier === t) {
            e = n;
            break;
          }
        }
        return e;
      }
      function a(t, e) {
        var n = {};
        var o = [];
        for (var i = 0; i < t.length; i++) {
          var a = t[i];
          var c = e.base ? a[0] + e.base : a[0];
          var l = n[c] || 0;
          var d = "".concat(c, " ").concat(l);
          n[c] = l + 1;
          var u = s(d);
          var h = { css: a[1], media: a[2], sourceMap: a[3] };
          if (u !== -1) {
            r[u].references++;
            r[u].updater(h);
          } else {
            r.push({ identifier: d, updater: p(h, e), references: 1 });
          }
          o.push(d);
        }
        return o;
      }
      function c(t) {
        var e = document.createElement("style");
        var o = t.attributes || {};
        if (typeof o.nonce === "undefined") {
          var r = true ? n.nc : undefined;
          if (r) {
            o.nonce = r;
          }
        }
        Object.keys(o).forEach(function (t) {
          e.setAttribute(t, o[t]);
        });
        if (typeof t.insert === "function") {
          t.insert(e);
        } else {
          var s = i(t.insert || "head");
          if (!s) {
            throw new Error(
              "Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid."
            );
          }
          s.appendChild(e);
        }
        return e;
      }
      function l(t) {
        if (t.parentNode === null) {
          return false;
        }
        t.parentNode.removeChild(t);
      }
      var d = (function t() {
        var e = [];
        return function t(n, o) {
          e[n] = o;
          return e.filter(Boolean).join("\n");
        };
      })();
      function u(t, e, n, o) {
        var i = n
          ? ""
          : o.media
          ? "@media ".concat(o.media, " {").concat(o.css, "}")
          : o.css;
        if (t.styleSheet) {
          t.styleSheet.cssText = d(e, i);
        } else {
          var r = document.createTextNode(i);
          var s = t.childNodes;
          if (s[e]) {
            t.removeChild(s[e]);
          }
          if (s.length) {
            t.insertBefore(r, s[e]);
          } else {
            t.appendChild(r);
          }
        }
      }
      function h(t, e, n) {
        var o = n.css;
        var i = n.media;
        var r = n.sourceMap;
        if (i) {
          t.setAttribute("media", i);
        } else {
          t.removeAttribute("media");
        }
        if (r && typeof btoa !== "undefined") {
          o += "\n/*# sourceMappingURL=data:application/json;base64,".concat(
            btoa(unescape(encodeURIComponent(JSON.stringify(r)))),
            " */"
          );
        }
        if (t.styleSheet) {
          t.styleSheet.cssText = o;
        } else {
          while (t.firstChild) {
            t.removeChild(t.firstChild);
          }
          t.appendChild(document.createTextNode(o));
        }
      }
      var f = null;
      var g = 0;
      function p(t, e) {
        var n;
        var o;
        var i;
        if (e.singleton) {
          var r = g++;
          n = f || (f = c(e));
          o = u.bind(null, n, r, false);
          i = u.bind(null, n, r, true);
        } else {
          n = c(e);
          o = h.bind(null, n, e);
          i = function t() {
            l(n);
          };
        }
        o(t);
        return function e(n) {
          if (n) {
            if (
              n.css === t.css &&
              n.media === t.media &&
              n.sourceMap === t.sourceMap
            ) {
              return;
            }
            o((t = n));
          } else {
            i();
          }
        };
      }
      t.exports = function (t, e) {
        e = e || {};
        if (!e.singleton && typeof e.singleton !== "boolean") {
          e.singleton = o();
        }
        t = t || [];
        var n = a(t, e);
        return function t(o) {
          o = o || [];
          if (Object.prototype.toString.call(o) !== "[object Array]") {
            return;
          }
          for (var i = 0; i < n.length; i++) {
            var c = n[i];
            var l = s(c);
            r[l].references--;
          }
          var d = a(o, e);
          for (var u = 0; u < n.length; u++) {
            var h = n[u];
            var f = s(h);
            if (r[f].references === 0) {
              r[f].updater();
              r.splice(f, 1);
            }
          }
          n = d;
        };
      };
    },
    function (t, e, n) {
      "use strict";
      function o(t, e) {
        return c(t) || a(t, e) || r(t, e) || i();
      }
      function i() {
        throw new TypeError(
          "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
        );
      }
      function r(t, e) {
        if (!t) return;
        if (typeof t === "string") return s(t, e);
        var n = Object.prototype.toString.call(t).slice(8, -1);
        if (n === "Object" && t.constructor) n = t.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(t);
        if (
          n === "Arguments" ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)
        )
          return s(t, e);
      }
      function s(t, e) {
        if (e == null || e > t.length) e = t.length;
        for (var n = 0, o = new Array(e); n < e; n++) {
          o[n] = t[n];
        }
        return o;
      }
      function a(t, e) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(t)))
          return;
        var n = [];
        var o = true;
        var i = false;
        var r = undefined;
        try {
          for (
            var s = t[Symbol.iterator](), a;
            !(o = (a = s.next()).done);
            o = true
          ) {
            n.push(a.value);
            if (e && n.length === e) break;
          }
        } catch (t) {
          i = true;
          r = t;
        } finally {
          try {
            if (!o && s["return"] != null) s["return"]();
          } finally {
            if (i) throw r;
          }
        }
        return n;
      }
      function c(t) {
        if (Array.isArray(t)) return t;
      }
      t.exports = function t(e) {
        var n = o(e, 4),
          i = n[1],
          r = n[3];
        if (typeof btoa === "function") {
          var s = btoa(unescape(encodeURIComponent(JSON.stringify(r))));
          var a = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(
            s
          );
          var c = "/*# ".concat(a, " */");
          var l = r.sources.map(function (t) {
            return "/*# sourceURL=".concat(r.sourceRoot || "").concat(t, " */");
          });
          return [i].concat(l).concat([c]).join("\n");
        }
        return [i].join("\n");
      };
    },
    function (t, e, n) {
      "use strict";
      t.exports = function (t) {
        var e = [];
        e.toString = function e() {
          return this.map(function (e) {
            var n = t(e);
            if (e[2]) {
              return "@media ".concat(e[2], " {").concat(n, "}");
            }
            return n;
          }).join("");
        };
        e.i = function (t, n, o) {
          if (typeof t === "string") {
            t = [[null, t, ""]];
          }
          var i = {};
          if (o) {
            for (var r = 0; r < this.length; r++) {
              var s = this[r][0];
              if (s != null) {
                i[s] = true;
              }
            }
          }
          for (var a = 0; a < t.length; a++) {
            var c = [].concat(t[a]);
            if (o && i[c[0]]) {
              continue;
            }
            if (n) {
              if (!c[2]) {
                c[2] = n;
              } else {
                c[2] = "".concat(n, " and ").concat(c[2]);
              }
            }
            e.push(c);
          }
        };
        return e;
      };
    },
    ,
    function (t, e, n) {
      "use strict";
      var o = n(9);
      var i = typeof self == "object" && self && self.Object === Object && self;
      var r = o["a"] || i || Function("return this")();
      e["a"] = r;
    },
    function (t, e, n) {
      "use strict";
      (function (t) {
        var o = n(5);
        var i = n(44);
        var r =
          typeof exports == "object" && exports && !exports.nodeType && exports;
        var s = r && typeof t == "object" && t && !t.nodeType && t;
        var a = s && s.exports === r;
        var c = a ? o["a"].Buffer : undefined;
        var l = c ? c.isBuffer : undefined;
        var d = l || i["a"];
        e["a"] = d;
      }.call(this, n(11)(t)));
    },
    function (t, e, n) {
      "use strict";
      (function (t) {
        var o = n(9);
        var i =
          typeof exports == "object" && exports && !exports.nodeType && exports;
        var r = i && typeof t == "object" && t && !t.nodeType && t;
        var s = r && r.exports === i;
        var a = s && o["a"].process;
        var c = (function () {
          try {
            var t = r && r.require && r.require("util").types;
            if (t) {
              return t;
            }
            return a && a.binding && a.binding("util");
          } catch (t) {}
        })();
        e["a"] = c;
      }.call(this, n(11)(t)));
    },
    function (t, e, n) {
      "use strict";
      (function (t) {
        var e = n(0);
        const o = "23.1.0";
        const i = typeof window === "object" ? window : t;
        if (i.CKEDITOR_VERSION) {
          throw new e["a"]("ckeditor-duplicated-modules", null);
        } else {
          i.CKEDITOR_VERSION = o;
        }
      }.call(this, n(43)));
    },
    function (t, e, n) {
      "use strict";
      (function (t) {
        var n = typeof t == "object" && t && t.Object === Object && t;
        e["a"] = n;
      }.call(this, n(43)));
    },
    function (t, e, n) {
      "use strict";
      (function (t) {
        var o = n(5);
        var i =
          typeof exports == "object" && exports && !exports.nodeType && exports;
        var r = i && typeof t == "object" && t && !t.nodeType && t;
        var s = r && r.exports === i;
        var a = s ? o["a"].Buffer : undefined,
          c = a ? a.allocUnsafe : undefined;
        function l(t, e) {
          if (e) {
            return t.slice();
          }
          var n = t.length,
            o = c ? c(n) : new t.constructor(n);
          t.copy(o);
          return o;
        }
        e["a"] = l;
      }.call(this, n(11)(t)));
    },
    function (t, e) {
      t.exports = function (t) {
        if (!t.webpackPolyfill) {
          var e = Object.create(t);
          if (!e.children) e.children = [];
          Object.defineProperty(e, "loaded", {
            enumerable: true,
            get: function () {
              return e.l;
            },
          });
          Object.defineProperty(e, "id", {
            enumerable: true,
            get: function () {
              return e.i;
            },
          });
          Object.defineProperty(e, "exports", { enumerable: true });
          e.webpackPolyfill = 1;
        }
        return e;
      };
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-placeholder:before,.ck .ck-placeholder:before{content:attr(data-placeholder);pointer-events:none}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-placeholder:before,.ck .ck-placeholder:before{cursor:text;color:var(--ck-color-engine-placeholder-text)}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css",
          ],
          names: [],
          mappings:
            "AAQC,qDACC,8BAA+B,CAG/B,mBACD,CAKA,wCACC,YACD,CCbA,qDACC,WAAY,CACZ,6CACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n\t&::before {\n\t\tcontent: attr(data-placeholder);\n\n\t\t/* See ckeditor/ckeditor5#469. */\n\t\tpointer-events: none;\n\t}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n\t&::before {\n\t\tdisplay: none;\n\t}\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n\t&::before {\n\t\tcursor: text;\n\t\tcolor: var(--ck-color-engine-placeholder-text);\n\t}\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck-hidden{display:none!important}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{box-sizing:border-box;width:auto;height:auto;position:static}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999);--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#c4c4c4;--ck-color-base-action:#61b045;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#198cf0;--ck-color-base-active-focus:#0e7fe1;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:208,79%,51%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#bcdefb;--ck-color-focus-disabled-shadow:rgba(119,186,248,0.3);--ck-color-focus-error-shadow:rgba(255,64,31,0.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,0.15);--ck-color-shadow-drop-active:rgba(0,0,0,0.2);--ck-color-shadow-inner:rgba(0,0,0,0.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#e6e6e6;--ck-color-button-default-active-background:#d9d9d9;--ck-color-button-default-active-shadow:#bfbfbf;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#dedede;--ck-color-button-on-hover-background:#c4c4c4;--ck-color-button-on-active-background:#bababa;--ck-color-button-on-active-shadow:#a1a1a1;--ck-color-button-on-disabled-background:#dedede;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#579e3d;--ck-color-button-action-active-background:#53973b;--ck-color-button-action-active-shadow:#498433;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#b0b0b0;--ck-color-switch-button-off-hover-background:#a3a3a3;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#579e3d;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,0.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:#c7c7c7;--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:#c7c7c7;--ck-color-input-disabled-text:#5c5c5c;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-base-active);--ck-color-list-button-on-background-focus:var(--ck-color-base-active-focus);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-foreground);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,177,255,0.1);--ck-color-link-fake-selection:rgba(31,177,255,0.3);--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck.ck-reset,.ck.ck-reset_all,.ck.ck-reset_all *{margin:0;padding:0;border:0;background:transparent;text-decoration:none;vertical-align:middle;transition:none;word-wrap:break-word}.ck.ck-reset_all,.ck.ck-reset_all *{border-collapse:collapse;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);color:var(--ck-color-text);text-align:left;white-space:nowrap;cursor:auto;float:none}.ck.ck-reset_all .ck-rtl *{text-align:right}.ck.ck-reset_all iframe{vertical-align:inherit}.ck.ck-reset_all textarea{white-space:pre-wrap}.ck.ck-reset_all input[type=password],.ck.ck-reset_all input[type=text],.ck.ck-reset_all textarea{cursor:text}.ck.ck-reset_all input[type=password][disabled],.ck.ck-reset_all input[type=text][disabled],.ck.ck-reset_all textarea[disabled]{cursor:default}.ck.ck-reset_all fieldset{padding:10px;border:2px groove #dfdee3}.ck.ck-reset_all button::-moz-focus-inner{padding:0;border:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css",
          ],
          names: [],
          mappings:
            "AAQA,WAGC,sBACD,CCPA,iDAGC,qBAAsB,CACtB,UAAW,CACX,WAAY,CACZ,eACD,CCPA,MACC,gBAAiB,CACjB,4CAA+C,CCD/C,kCAAmD,CACnD,+BAAoD,CACpD,8BAAgD,CAChD,8BAAmD,CACnD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAmD,CACnD,oCAAuD,CACvD,6BAAkD,CAIlD,+CAAwD,CACxD,qEAA+E,CAC/E,qCAAwD,CACxD,sDAA8D,CAC9D,iDAAyD,CACzD,yCAAqD,CACrD,uCAAsD,CACtD,6CAA0D,CAC1D,uCAAsD,CAItD,gDAAuD,CACvD,kDAA+D,CAC/D,mDAAgE,CAChE,+CAA6D,CAC7D,yDAA8D,CAE9D,uCAAuD,CACvD,6CAA4D,CAC5D,8CAA4D,CAC5D,0CAAyD,CACzD,gDAA8D,CAE9D,+DAAsE,CACtE,iDAAkE,CAClE,kDAAkE,CAClE,8CAA+D,CAC/D,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA4D,CAC5D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAmE,CACnE,yEAA8E,CAC9E,qDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,+BAAiD,CACjD,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,wCAAwD,CACxD,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,gEAAuE,CACvE,4EAAiF,CACjF,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,wDAAmE,CACnE,mDAAgE,CCpGhE,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCLFD,CKQA,iDAIC,QAAS,CACT,SAAU,CACV,QAAS,CACT,sBAAuB,CACvB,oBAAqB,CACrB,qBAAsB,CACtB,eAAgB,CAGhB,oBACD,CAKA,oCAGC,wBAAyB,CACzB,iGAAkG,CAClG,0BAA2B,CAC3B,eAAgB,CAChB,kBAAmB,CACnB,WAAY,CACZ,UACD,CAGC,2BACC,gBACD,CAEA,wBAEC,sBACD,CAEA,0BACC,oBACD,CAEA,kGAGC,WACD,CAEA,gIAGC,cACD,CAEA,0BACC,YAAa,CACb,yBACD,CAEA,0CAEC,SAAU,CACV,QACD,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n\t/* Override selector specificity. Otherwise, all elements with some display\n\tstyle defined will override this one, which is not a desired result. */\n\tdisplay: none !important;\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\tbox-sizing: border-box;\n\twidth: auto;\n\theight: auto;\n\tposition: static;\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-z-default: 1;\n\t--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-base-foreground: \t\t\t\t\t\t\t\thsl(0, 0%, 98%);\n\t--ck-color-base-background: \t\t\t\t\t\t\t\thsl(0, 0%, 100%);\n\t--ck-color-base-border: \t\t\t\t\t\t\t\t\thsl(0, 0%, 77%);\n\t--ck-color-base-action: \t\t\t\t\t\t\t\t\thsl(104, 44%, 48%);\n\t--ck-color-base-focus: \t\t\t\t\t\t\t\t\t\thsl(209, 92%, 70%);\n\t--ck-color-base-text: \t\t\t\t\t\t\t\t\t\thsl(0, 0%, 20%);\n\t--ck-color-base-active: \t\t\t\t\t\t\t\t\thsl(208, 88%, 52%);\n\t--ck-color-base-active-focus:\t\t\t\t\t\t\t\thsl(208, 88%, 47%);\n\t--ck-color-base-error:\t\t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t/* -- Generic colors ------------------------------------------------------------------------ */\n\n\t--ck-color-focus-border-coordinates: \t\t\t\t\t\t208, 79%, 51%;\n\t--ck-color-focus-border: \t\t\t\t\t\t\t\t\thsl(var(--ck-color-focus-border-coordinates));\n\t--ck-color-focus-outer-shadow:\t\t\t\t\t\t\t\thsl(207, 89%, 86%);\n\t--ck-color-focus-disabled-shadow:\t\t\t\t\t\t\thsla(209, 90%, 72%,.3);\n\t--ck-color-focus-error-shadow:\t\t\t\t\t\t\t\thsla(9,100%,56%,.3);\n\t--ck-color-text: \t\t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-shadow-drop: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.15);\n\t--ck-color-shadow-drop-active:\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.2);\n\t--ck-color-shadow-inner: \t\t\t\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Buttons ------------------------------------------------------------------------------- */\n\n\t--ck-color-button-default-background: \t\t\t\t\t\ttransparent;\n\t--ck-color-button-default-hover-background: \t\t\t\thsl(0, 0%, 90%);\n\t--ck-color-button-default-active-background: \t\t\t\thsl(0, 0%, 85%);\n\t--ck-color-button-default-active-shadow: \t\t\t\t\thsl(0, 0%, 75%);\n\t--ck-color-button-default-disabled-background: \t\t\t\ttransparent;\n\n\t--ck-color-button-on-background: \t\t\t\t\t\t\thsl(0, 0%, 87%);\n\t--ck-color-button-on-hover-background: \t\t\t\t\t\thsl(0, 0%, 77%);\n\t--ck-color-button-on-active-background: \t\t\t\t\thsl(0, 0%, 73%);\n\t--ck-color-button-on-active-shadow: \t\t\t\t\t\thsl(0, 0%, 63%);\n\t--ck-color-button-on-disabled-background: \t\t\t\t\thsl(0, 0%, 87%);\n\n\t--ck-color-button-action-background: \t\t\t\t\t\tvar(--ck-color-base-action);\n\t--ck-color-button-action-hover-background: \t\t\t\t\thsl(104, 44%, 43%);\n\t--ck-color-button-action-active-background: \t\t\t\thsl(104, 44%, 41%);\n\t--ck-color-button-action-active-shadow: \t\t\t\t\thsl(104, 44%, 36%);\n\t--ck-color-button-action-disabled-background: \t\t\t\thsl(104, 44%, 58%);\n\t--ck-color-button-action-text: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t--ck-color-button-save: \t\t\t\t\t\t\t\t\thsl(120, 100%, 27%);\n\t--ck-color-button-cancel: \t\t\t\t\t\t\t\t\thsl(15, 100%, 43%);\n\n\t--ck-color-switch-button-off-background:\t\t\t\t\thsl(0, 0%, 69%);\n\t--ck-color-switch-button-off-hover-background:\t\t\t\thsl(0, 0%, 64%);\n\t--ck-color-switch-button-on-background:\t\t\t\t\t\tvar(--ck-color-button-action-background);\n\t--ck-color-switch-button-on-hover-background:\t\t\t\thsl(104, 44%, 43%);\n\t--ck-color-switch-button-inner-background:\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-switch-button-inner-shadow:\t\t\t\t\t\thsla(0, 0%, 0%, 0.1);\n\n\t/* -- Dropdown ------------------------------------------------------------------------------ */\n\n\t--ck-color-dropdown-panel-background: \t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-dropdown-panel-border: \t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Input --------------------------------------------------------------------------------- */\n\n\t--ck-color-input-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-input-border: \t\t\t\t\t\t\t\t\thsl(0, 0%, 78%);\n\t--ck-color-input-error-border:\t\t\t\t\t\t\t\tvar(--ck-color-base-error);\n\t--ck-color-input-text: \t\t\t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-input-disabled-background: \t\t\t\t\t\thsl(0, 0%, 95%);\n\t--ck-color-input-disabled-border: \t\t\t\t\t\t\thsl(0, 0%, 78%);\n\t--ck-color-input-disabled-text: \t\t\t\t\t\t\thsl(0, 0%, 36%);\n\n\t/* -- List ---------------------------------------------------------------------------------- */\n\n\t--ck-color-list-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-list-button-hover-background: \t\t\t\t\tvar(--ck-color-button-default-hover-background);\n\t--ck-color-list-button-on-background: \t\t\t\t\t\tvar(--ck-color-base-active);\n\t--ck-color-list-button-on-background-focus: \t\t\t\tvar(--ck-color-base-active-focus);\n\t--ck-color-list-button-on-text:\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Panel --------------------------------------------------------------------------------- */\n\n\t--ck-color-panel-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\t--ck-color-panel-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Toolbar ------------------------------------------------------------------------------- */\n\n\t--ck-color-toolbar-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-foreground);\n\t--ck-color-toolbar-border: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-border);\n\n\t/* -- Tooltip ------------------------------------------------------------------------------- */\n\n\t--ck-color-tooltip-background: \t\t\t\t\t\t\t\tvar(--ck-color-base-text);\n\t--ck-color-tooltip-text: \t\t\t\t\t\t\t\t\tvar(--ck-color-base-background);\n\n\t/* -- Engine -------------------------------------------------------------------------------- */\n\n\t--ck-color-engine-placeholder-text: \t\t\t\t\t\thsl(0, 0%, 44%);\n\n\t/* -- Upload -------------------------------------------------------------------------------- */\n\n\t--ck-color-upload-bar-background:\t\t \t\t\t\t\thsl(209, 92%, 70%);\n\n\t/* -- Link -------------------------------------------------------------------------------- */\n\n\t--ck-color-link-default:\t\t\t\t\t\t\t\t\thsl(240, 100%, 47%);\n\t--ck-color-link-selected-background:\t\t\t\t\t\thsla(201, 100%, 56%, 0.1);\n\t--ck-color-link-fake-selection:\t\t\t\t\t\t\t\thsla(201, 100%, 56%, 0.3);\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * An opacity value of disabled UI item.\n\t */\n\t--ck-disabled-opacity: .5;\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * The geometry of the of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n\t/**\n\t * A visual style of focused element's outer shadow.\n\t */\n\t--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when disabled).\n\t */\n\t--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n\t/**\n\t * A visual style of focused element's outer shadow (when has errors).\n\t */\n\t--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n\t/**\n\t * A visual style of focused element's border or outline.\n\t */\n\t--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-font-size-base: 13px;\n\t--ck-line-height-base: 1.84615;\n\t--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n\t--ck-font-size-tiny: 0.7em;\n\t--ck-font-size-small: 0.75em;\n\t--ck-font-size-normal: 1em;\n\t--ck-font-size-big: 1.4em;\n\t--ck-font-size-large: 1.8em;\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* This is super-important. This is **manually** adjusted so a button without an icon\n\tis never smaller than a button with icon, additionally making sure that text-less buttons\n\tare perfect squares. The value is also shared by other components which should stay "in-line"\n\twith buttons. */\n\t--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\t/* Do not include inheritable rules here. */\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tbackground: transparent;\n\ttext-decoration: none;\n\tvertical-align: middle;\n\ttransition: none;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n\tword-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck.ck-reset_all * {\n\t/* These are rule inherited by all children elements. */\n\tborder-collapse: collapse;\n\tfont: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n\tcolor: var(--ck-color-text);\n\ttext-align: left;\n\twhite-space: nowrap;\n\tcursor: auto;\n\tfloat: none;\n}\n\n.ck.ck-reset_all {\n\t& .ck-rtl * {\n\t\ttext-align: right;\n\t}\n\n\t& iframe {\n\t\t/* For IE */\n\t\tvertical-align: inherit;\n\t}\n\n\t& textarea {\n\t\twhite-space: pre-wrap;\n\t}\n\n\t& textarea,\n\t& input[type="text"],\n\t& input[type="password"] {\n\t\tcursor: text;\n\t}\n\n\t& textarea[disabled],\n\t& input[type="text"][disabled],\n\t& input[type="password"][disabled] {\n\t\tcursor: default;\n\t}\n\n\t& fieldset {\n\t\tpadding: 10px;\n\t\tborder: 2px groove hsl(255, 7%, 88%);\n\t}\n\n\t& button::-moz-focus-inner {\n\t\t/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n\t\tpadding: 0;\n\t\tborder: 0\n\t}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n\ttext-align: right;\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n\t--ck-border-radius: 2px;\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/**\n\t * A visual style of element's inner shadow (i.e. input).\n\t */\n\t--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n\t/**\n\t * A visual style of element's drop shadow (i.e. panel).\n\t */\n\t--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n\t/**\n\t * A visual style of element's active shadow (i.e. comment or suggestion).\n\t */\n\t--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-spacing-unit: \t\t\t\t\t\t0.6em;\n\t--ck-spacing-large: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 1.5);\n\t--ck-spacing-standard: \t\t\t\t\tvar(--ck-spacing-unit);\n\t--ck-spacing-medium: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.8);\n\t--ck-spacing-small: \t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.5);\n\t--ck-spacing-tiny: \t\t\t\t\t\tcalc(var(--ck-spacing-unit) * 0.3);\n\t--ck-spacing-extra-tiny: \t\t\t\tcalc(var(--ck-spacing-unit) * 0.16);\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-editor__editable:not(.ck-editor__nested-editable).ck-focused{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0}.ck.ck-editor__editable_inline{overflow:auto;padding:0 var(--ck-spacing-standard);border:1px solid transparent}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-base-foreground)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-base-foreground)}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
          ],
          names: [],
          mappings:
            "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEERA,YAAa,CACb,2BAA2B,CCF3B,qCHYA,CAGD,+BACC,aAAc,CACd,oCAAqC,CACrC,4BAwBD,CAtBC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CACC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,mDACD,CAIA,gEACC,gDACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n\t--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n\t@mixin ck-rounded-corners;\n\n\t&.ck-focused {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\t}\n}\n\n.ck.ck-editor__editable_inline {\n\toverflow: auto;\n\tpadding: 0 var(--ck-spacing-standard);\n\tborder: 1px solid transparent;\n\n\t&[dir="ltr"] {\n\t\ttext-align: left;\n\t}\n\n\t&[dir="rtl"] {\n\t\ttext-align: right;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n\t& > *:first-child {\n\t\tmargin-top: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/847 */\n\t& > *:last-child {\n\t\tmargin-bottom: var(--ck-spacing-large);\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n\t&.ck-blurred ::selection {\n\t\tbackground: var(--ck-color-editable-blur-selection);\n\t}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n\t&::after {\n\t\tborder-bottom-color: var(--ck-color-base-foreground);\n\t}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n\t&::after {\n\t\tborder-top-color: var(--ck-color-base-foreground);\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{width:0;height:0;border-style:solid}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:var(--ck-balloon-arrow-height);border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:0}.ck.ck-balloon-panel[class*=arrow_n]:before{border-bottom-color:var(--ck-color-panel-border)}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-left-color:transparent;border-right-color:transparent;border-top-color:transparent}.ck.ck-balloon-panel[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background);margin-top:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-width:var(--ck-balloon-arrow-half-width);border-bottom-width:0;border-right-width:var(--ck-balloon-arrow-half-width);border-top-width:var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-top-color:var(--ck-color-panel-border);filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent}.ck.ck-balloon-panel[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background);margin-bottom:var(--ck-balloon-arrow-offset)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);bottom:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{right:25%;margin-right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}',
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
          ],
          names: [],
          mappings:
            "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCJC,eD4ID,CAxIA,iFCAE,qCDwIF,CAxIA,qBENC,oCAA8B,CFU9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAiID,CA9HE,+GAEC,OAAQ,CACR,QAAS,CACT,kBACD,CAIA,uFAEC,oDAAoH,CAApH,kDAAoH,CAApH,qDAAoH,CAApH,kBACD,CAEA,4CACC,gDACD,CAEA,uFAHC,6BAA8E,CAA9E,8BAA8E,CAA9E,4BAMD,CAHA,2CACC,oDAAkF,CAClF,yCACD,CAIA,uFAEC,oDAAoH,CAApH,qBAAoH,CAApH,qDAAoH,CAApH,+CACD,CAEA,4CACC,6CAAkE,CAClE,uDACD,CAEA,uFAJC,6BAAkE,CAAlE,+BAAkE,CAAlE,8BAOD,CAHA,2CACC,iDAAkF,CAClF,4CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,8CACD,CAIA,2GAEC,+CAAkD,CAClD,8CACD,CAIA,2GAEC,gDAAmD,CACnD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,8CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,8CACD,CAIA,6GAEC,SAAU,CACV,uDAA0D,CAC1D,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t/* Make sure the balloon arrow does not float over its children. */\n\t--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n\tdisplay: none;\n\tposition: absolute;\n\n\tz-index: var(--ck-z-modal);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tposition: absolute;\n\t\t}\n\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before {\n\t\t\tz-index: var(--ck-balloon-panel-arrow-z-index);\n\t\t}\n\n\t\t&::after {\n\t\t\tz-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_visible {\n\t\tdisplay: block;\n\t}\n}\n',
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-arrow-offset: 2px;\n\t--ck-balloon-arrow-height: 10px;\n\t--ck-balloon-arrow-half-width: 8px;\n\t--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\n\t&.ck-balloon-panel_with-arrow {\n\t\t&::before,\n\t\t&::after {\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t\tborder-style: solid;\n\t\t}\n\t}\n\n\t&[class*="arrow_n"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-border) transparent;\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: transparent transparent var(--ck-color-panel-background) transparent;\n\t\t\tmargin-top: var(--ck-balloon-arrow-offset);\n\t\t}\n\t}\n\n\t&[class*="arrow_s"] {\n\t\t&::before,\n\t\t&::after {\n\t\t\tborder-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n\t\t}\n\n\t\t&::before {\n\t\t\tborder-color: var(--ck-color-panel-border) transparent transparent;\n\t\t\tfilter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n\t\t}\n\n\t\t&::after {\n\t\t\tborder-color: var(--ck-color-panel-background) transparent transparent transparent;\n\t\t\tmargin-bottom: var(--ck-balloon-arrow-offset);\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_n {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_ne {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_s {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 50%;\n\t\t\tmargin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_se {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_sme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_smw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\tbottom: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nme {\n\t\t&::before,\n\t\t&::after {\n\t\t\tright: 25%;\n\t\t\tmargin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n\n\t&.ck-balloon-panel_arrow_nmw {\n\t\t&::before,\n\t\t&::after {\n\t\t\tleft: 25%;\n\t\t\tmargin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n\t\t\ttop: calc(-1 * var(--ck-balloon-arrow-height));\n\t\t}\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on .ck-tooltip{display:none}.ck.ck-dropdown .ck-dropdown__panel{-webkit-backface-visibility:hidden;display:none;z-index:var(--ck-z-modal);position:absolute}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{top:100%;bottom:auto}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{width:7em;overflow:hidden;text-overflow:ellipsis}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{box-shadow:var(--ck-drop-shadow),0 0;background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
          ],
          names: [],
          mappings:
            "AAOA,gBACC,oBAAqB,CACrB,iBAyDD,CAvDC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UAOD,CCcA,iEACC,YACD,CDdA,oCAGC,kCAAmC,CAEnC,YAAa,CACb,yBAA0B,CAE1B,iBA8BD,CA5BC,+DACC,oBACD,CAEA,oHAEC,WACD,CAEA,oHAMC,QAAS,CACT,WACD,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAQF,mCACC,mCACD,CEhEA,MACC,sDACD,CAEA,gBAEC,iBAiED,CA/DC,oCACC,mCACD,CAGC,8CACC,gCAAiC,CAGjC,sCACD,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEACC,SAAU,CACV,eAAgB,CAChB,sBACD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAIF,uBExEC,eFoGD,CA5BA,qFEpEE,qCFgGF,CA5BA,uBG1EC,oCAA8B,CH8E9B,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CAGT,cAmBD,CAfC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import \"../tooltip/mixins/_tooltip.css\";\n\n.ck.ck-dropdown {\n\tdisplay: inline-block;\n\tposition: relative;\n\n\t& .ck-dropdown__arrow {\n\t\tpointer-events: none;\n\t\tz-index: var(--ck-z-default);\n\t}\n\n\t/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n\t& .ck-button.ck-dropdown__button {\n\t\twidth: 100%;\n\n\t\t/* Disable main button's tooltip when the dropdown is open. Otherwise the panel may\n\t\tpartially cover the tooltip */\n\t\t&.ck-on {\n\t\t\t@mixin ck-tooltip_disabled;\n\t\t}\n\t}\n\n\t& .ck-dropdown__panel {\n\t\t/* This is to get rid of flickering when the tooltip is shown under the panel,\n\t\twhich looks like the panel moves vertically a pixel down and up. */\n\t\t-webkit-backface-visibility: hidden;\n\n\t\tdisplay: none;\n\t\tz-index: var(--ck-z-modal);\n\n\t\tposition: absolute;\n\n\t\t&.ck-dropdown__panel-visible {\n\t\t\tdisplay: inline-block;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_nw {\n\t\t\tbottom: 100%;\n\t\t}\n\n\t\t&.ck-dropdown__panel_se,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\t/*\n\t\t\t * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n\t\t\t * See https://github.com/ckeditor/ckeditor5/issues/1053.\n\t\t\t */\n\t\t\ttop: 100%;\n\t\t\tbottom: auto;\n\t\t}\n\n\t\t&.ck-dropdown__panel_ne,\n\t\t&.ck-dropdown__panel_se {\n\t\t\tleft: 0px;\n\t\t}\n\n\t\t&.ck-dropdown__panel_nw,\n\t\t&.ck-dropdown__panel_sw {\n\t\t\tright: 0px;\n\t\t}\n\t}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n\tz-index: calc( var(--ck-z-modal) + 1 );\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n\t--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-dropdown {\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t& .ck-dropdown__arrow {\n\t\twidth: var(--ck-dropdown-arrow-size);\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-dropdown__arrow {\n\t\t\tright: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-dropdown__arrow {\n\t\t\tleft: var(--ck-spacing-standard);\n\n\t\t\t/* A space to accommodate the triangle. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-dropdown__arrow {\n\t\t@mixin ck-disabled;\n\t}\n\n\t& .ck-button.ck-dropdown__button {\n\t\t@mixin ck-dir ltr {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t&:not(.ck-button_with-text) {\n\t\t\t\t/* Make sure dropdowns with just an icon have the right inner spacing */\n\t\t\t\tpadding-right: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\n\t\t/* #23 */\n\t\t& .ck-button__label {\n\t\t\twidth: 7em;\n\t\t\toverflow: hidden;\n\t\t\ttext-overflow: ellipsis;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t\t&.ck-disabled .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5/issues/816 */\n\t\t&.ck-on {\n\t\t\tborder-bottom-left-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t&.ck-dropdown__button_label-width_auto .ck-button__label {\n\t\t\twidth: auto;\n\t\t}\n\t}\n}\n\n.ck.ck-dropdown__panel {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-drop-shadow;\n\n\tbackground: var(--ck-color-dropdown-panel-background);\n\tborder: 1px solid var(--ck-color-dropdown-panel-border);\n\tbottom: 0;\n\n\t/* Make sure the panel is at least as wide as the drop-down\'s button. */\n\tmin-width: 100%;\n\n\t/* Disabled corner border radius to be consistent with the .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t&.ck-dropdown__panel_se {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_sw {\n\t\tborder-top-right-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_ne {\n\t\tborder-bottom-left-radius: 0;\n\t}\n\n\t&.ck-dropdown__panel_nw {\n\t\tborder-bottom-right-radius: 0;\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{width:var(--ck-icon-size);height:var(--ck-icon-size);font-size:.8333350694em;will-change:transform}.ck.ck-icon,.ck.ck-icon *{color:inherit;cursor:inherit}.ck.ck-icon :not([fill]){fill:currentColor}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css",
          ],
          names: [],
          mappings:
            "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YACC,yBAA0B,CAC1B,0BAA2B,CAG3B,uBAAwB,CAQxB,qBAcD,CAZC,0BARA,aAAc,CAGd,cAgBA,CAJC,yBAEC,iBACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n\tvertical-align: middle;\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n\twidth: var(--ck-icon-size);\n\theight: var(--ck-icon-size);\n\n\t/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n\tfont-size: .8333350694em;\n\n\tcolor: inherit;\n\n\t/* Inherit cursor style (#5). */\n\tcursor: inherit;\n\n\t/* This will prevent blurry icons on Firefox. See #340. */\n\twill-change: transform;\n\n\t& * {\n\t\t/* Inherit cursor style (#5). */\n\t\tcursor: inherit;\n\n\t\t/* Allows dynamic coloring of the icons. */\n\t\tcolor: inherit;\n\n\t\t&:not([fill]) {\n\t\t\t/* Needed by FF. */\n\t\t\tfill: currentColor;\n\t\t}\n\t}\n}\n',
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        '.ck.ck-tooltip,.ck.ck-tooltip .ck-tooltip__text:after{position:absolute;pointer-events:none;-webkit-backface-visibility:hidden}.ck.ck-tooltip{visibility:hidden;opacity:0;display:none;z-index:var(--ck-z-modal)}.ck.ck-tooltip .ck-tooltip__text{display:inline-block}.ck.ck-tooltip .ck-tooltip__text:after{content:"";width:0;height:0}:root{--ck-tooltip-arrow-size:5px}.ck.ck-tooltip{left:50%;top:0;transition:opacity .2s ease-in-out .2s}.ck.ck-tooltip .ck-tooltip__text{border-radius:0}.ck-rounded-corners .ck.ck-tooltip .ck-tooltip__text,.ck.ck-tooltip .ck-tooltip__text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-tooltip .ck-tooltip__text{font-size:.9em;line-height:1.5;color:var(--ck-color-tooltip-text);padding:var(--ck-spacing-small) var(--ck-spacing-medium);background:var(--ck-color-tooltip-background);position:relative;left:-50%}.ck.ck-tooltip .ck-tooltip__text:after{transition:opacity .2s ease-in-out .2s;border-style:solid;left:50%}.ck.ck-tooltip.ck-tooltip_s,.ck.ck-tooltip.ck-tooltip_sw{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(100%)}.ck.ck-tooltip.ck-tooltip_s .ck-tooltip__text:after,.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{top:calc(var(--ck-tooltip-arrow-size)*-1 + 1px);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:var(--ck-color-tooltip-background);border-right-color:transparent;border-top-color:transparent;border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:var(--ck-tooltip-arrow-size);border-right-width:var(--ck-tooltip-arrow-size);border-top-width:0}.ck.ck-tooltip.ck-tooltip_sw{right:50%;left:auto}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text{left:auto;right:calc(var(--ck-tooltip-arrow-size)*-2)}.ck.ck-tooltip.ck-tooltip_sw .ck-tooltip__text:after{left:auto;right:0}.ck.ck-tooltip.ck-tooltip_n{top:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateY(-100%)}.ck.ck-tooltip.ck-tooltip_n .ck-tooltip__text:after{bottom:calc(var(--ck-tooltip-arrow-size)*-1);transform:translateX(-50%);border-left-color:transparent;border-bottom-color:transparent;border-right-color:transparent;border-top-color:var(--ck-color-tooltip-background);border-left-width:var(--ck-tooltip-arrow-size);border-bottom-width:0;border-right-width:var(--ck-tooltip-arrow-size);border-top-width:var(--ck-tooltip-arrow-size)}',
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
          ],
          names: [],
          mappings:
            "AAKA,sDAEC,iBAAkB,CAGlB,mBAAoB,CAIpB,kCACD,CAEA,eAEC,iBAAkB,CAClB,SAAU,CACV,YAAa,CACb,yBAWD,CATC,iCACC,oBAOD,CALC,uCACC,UAAW,CACX,OAAQ,CACR,QACD,CCxBF,MACC,2BACD,CAEA,eACC,QAAS,CAMT,KAAM,CAON,sCA6FD,CA3FC,iCChBA,eDqCA,CArBA,yGCZC,qCDiCD,CArBA,iCAGC,cAAe,CACf,eAAgB,CAChB,kCAAmC,CACnC,wDAAyD,CACzD,6CAA8C,CAC9C,iBAAkB,CAClB,SAYD,CAVC,uCAMC,sCAAuC,CACvC,kBAAmB,CACnB,QACD,CAYD,yDAEC,4CAA+C,CAC/C,0BASD,CAPC,yGAEC,+CAAkD,CAClD,0BAA6B,CAC7B,6BAAoF,CAApF,sDAAoF,CAApF,8BAAoF,CAApF,4BAAoF,CACpF,8CAAsG,CAAtG,gDAAsG,CAAtG,+CAAsG,CAAtG,kBACD,CAaD,6BACC,SAAU,CACV,SAWD,CATC,+CACC,SAAU,CACV,2CACD,CAEA,qDACC,SAAU,CACV,OACD,CAYD,4BACC,yCAA4C,CAC5C,2BAQD,CANC,oDACC,4CAA+C,CAC/C,0BAA6B,CAC7B,6BAAoF,CAApF,+BAAoF,CAApF,8BAAoF,CAApF,mDAAoF,CACpF,8CAAsG,CAAtG,qBAAsG,CAAtG,+CAAsG,CAAtG,6CACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-tooltip,\n.ck.ck-tooltip .ck-tooltip__text::after {\n\tposition: absolute;\n\n\t/* Without this, hovering the tooltip could keep it visible. */\n\tpointer-events: none;\n\n\t/* This is to get rid of flickering when transitioning opacity in Chrome.\n\tIt\'s weird but it works. */\n\t-webkit-backface-visibility: hidden;\n}\n\n.ck.ck-tooltip {\n\t/* Tooltip is hidden by default. */\n\tvisibility: hidden;\n\topacity: 0;\n\tdisplay: none;\n\tz-index: var(--ck-z-modal);\n\n\t& .ck-tooltip__text {\n\t\tdisplay: inline-block;\n\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\twidth: 0;\n\t\t\theight: 0;\n\t\t}\n\t}\n}\n',
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n:root {\n\t--ck-tooltip-arrow-size: 5px;\n}\n\n.ck.ck-tooltip {\n\tleft: 50%;\n\n\t/*\n\t * Prevent blurry tooltips in LoDPI environments.\n\t * See https://github.com/ckeditor/ckeditor5/issues/1802.\n\t */\n\ttop: 0;\n\n\t/*\n\t * For the transition to work, the tooltip must be controlled\n\t * using visibility+opacity. A delay prevents a "tooltip avalanche"\n\t * i.e. when scanning the toolbar with mouse cursor.\n\t */\n\ttransition: opacity .2s ease-in-out .2s;\n\n\t& .ck-tooltip__text {\n\t\t@mixin ck-rounded-corners;\n\n\t\tfont-size: .9em;\n\t\tline-height: 1.5;\n\t\tcolor: var(--ck-color-tooltip-text);\n\t\tpadding: var(--ck-spacing-small) var(--ck-spacing-medium);\n\t\tbackground: var(--ck-color-tooltip-background);\n\t\tposition: relative;\n\t\tleft: -50%;\n\n\t\t&::after {\n\t\t\t/*\n\t\t\t * For the transition to work, the tooltip must be controlled\n\t\t\t * using visibility+opacity. A delay prevents a "tooltip avalanche"\n\t\t\t * i.e. when scanning the toolbar with mouse cursor.\n\t\t\t */\n\t\t\ttransition: opacity .2s ease-in-out .2s;\n\t\t\tborder-style: solid;\n\t\t\tleft: 50%;\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south of the element.\n\t *\n\t *       [element]\n\t *           ^\n\t *     +-----------+\n\t *     |  Tooltip  |\n\t *     +-----------+\n\t */\n\t&.ck-tooltip_s,\n\t&.ck-tooltip_sw {\n\t\tbottom: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\ttransform: translateY( 100% );\n\n\t\t& .ck-tooltip__text::after {\n\t\t\t/* 1px addresses gliches in rendering causing gap between the triangle and the text */\n\t\t\ttop: calc(-1 * var(--ck-tooltip-arrow-size) + 1px);\n\t\t\ttransform: translateX( -50% );\n\t\t\tborder-color: transparent transparent var(--ck-color-tooltip-background) transparent;\n\t\t\tborder-width: 0 var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size);\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip south-west of the element.\n\t *\n\t *        [element]\n\t *            ^\n\t *  +-----------+\n\t *  |  Tooltip  |\n\t *  +-----------+\n\t */\n\n\t&.ck-tooltip_sw {\n\t\tright: 50%;\n\t\tleft: auto;\n\n\t\t& .ck-tooltip__text {\n\t\t\tleft: auto;\n\t\t\tright: calc( -2 * var(--ck-tooltip-arrow-size));\n\t\t}\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tleft: auto;\n\t\t\tright: 0;\n\t\t}\n\t}\n\n\t/**\n\t * A class that displays the tooltip north of the element.\n\t *\n\t *     +-----------+\n\t *     |  Tooltip  |\n\t *     +-----------+\n\t *           V\n\t *       [element]\n\t */\n\t&.ck-tooltip_n {\n\t\ttop: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\ttransform: translateY( -100% );\n\n\t\t& .ck-tooltip__text::after {\n\t\t\tbottom: calc(-1 * var(--ck-tooltip-arrow-size));\n\t\t\ttransform: translateX( -50% );\n\t\t\tborder-color: var(--ck-color-tooltip-background) transparent transparent transparent;\n\t\t\tborder-width: var(--ck-tooltip-arrow-size) var(--ck-tooltip-arrow-size) 0 var(--ck-tooltip-arrow-size);\n\t\t}\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-button,a.ck.ck-button{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:block}@media (hover:none){.ck.ck-button .ck-tooltip,a.ck.ck-button .ck-tooltip{display:none}}.ck.ck-button,a.ck.ck-button{position:relative;display:inline-flex;align-items:center;justify-content:left}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button:hover .ck-tooltip,a.ck.ck-button:hover .ck-tooltip{visibility:visible;opacity:1}.ck.ck-button:focus:not(:hover) .ck-tooltip,a.ck.ck-button:focus:not(:hover) .ck-tooltip{display:none}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-default-active-shadow)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{white-space:nowrap;cursor:default;vertical-align:middle;padding:var(--ck-spacing-tiny);text-align:center;min-width:var(--ck-ui-component-min-height);min-height:var(--ck-ui-component-min-height);line-height:1;font-size:inherit;border:1px solid transparent;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;-webkit-appearance:none}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{font-size:inherit;font-weight:inherit;color:inherit;cursor:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__icon{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-right:calc(var(--ck-spacing-small)*-1);margin-left:var(--ck-spacing-small)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-on-active-shadow)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background);box-shadow:inset 0 2px 2px var(--ck-color-button-action-active-shadow)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
          ],
          names: [],
          mappings:
            "AAQA,6BCCC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6BD,CE/BC,qDACC,aAqBD,CAHC,oBAnBD,qDAoBE,YAEF,CADC,CFvBF,6BAKC,iBAAkB,CAClB,mBAAoB,CACpB,kBAAmB,CACnB,oBAyBD,CAvBC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEkBA,iEACC,kBAAmB,CACnB,SACD,CAbA,yFACC,YACD,CC7BD,6BCAC,oDD0ID,CCvIE,6EACC,0DACD,CAEA,+EACC,2DAA4C,CAC5C,uEACD,CAID,qDACC,6DACD,CDhBD,6BEDC,eF2ID,CA1IA,wIEGE,qCFuIF,CA1IA,6BAKC,kBAAmB,CACnB,cAAe,CACf,qBAAsB,CACtB,8BAA+B,CAC/B,iBAAkB,CAGlB,2CAA4C,CAC5C,4CAA6C,CAI7C,aAAc,CAGd,iBAAkB,CAGlB,4BAA6B,CAG7B,4DAA8D,CAG9D,uBA6GD,CA3GC,oFGjCA,YAAa,CACb,2BAA2B,CCF3B,2CJsCA,CAIC,kJAEC,aACD,CAGD,iEAEC,iBAAkB,CAClB,mBAAoB,CACpB,aAAc,CACd,cAAe,CAIf,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAEA,uFK3FD,kCL6FC,CAGA,yFKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAOE,6CAAgD,CAChD,mCAEF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDiIA,CC9HC,yFACC,qDACD,CAEA,2FACC,sDAA4C,CAC5C,kEACD,CAID,iEACC,wDACD,CDmHA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC7IC,mDDkJD,CC/IE,2FACC,yDACD,CAEA,6FACC,0DAA4C,CAC5C,sEACD,CAID,mEACC,4DACD,CD6HD,2CAIC,wCACD,CAEA,uCAEC,eACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n@import "../tooltip/mixins/_tooltip.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-unselectable;\n\t@mixin ck-tooltip_enabled;\n\n\tposition: relative;\n\tdisplay: inline-flex;\n\talign-items: center;\n\tjustify-content: left;\n\n\t& .ck-button__label {\n\t\tdisplay: none;\n\t}\n\n\t&.ck-button_with-text {\n\t\t& .ck-button__label {\n\t\t\tdisplay: inline-block;\n\t\t}\n\t}\n\n\t/* Center the icon horizontally in a button without text. */\n\t&:not(.ck-button_with-text)  {\n\t\tjustify-content: center;\n\t}\n\n\t&:hover {\n\t\t@mixin ck-tooltip_visible;\n\t}\n\n\t/* Get rid of the native focus outline around the tooltip when focused (but not :hover). */\n\t&:focus:not(:hover) {\n\t\t@mixin ck-tooltip_disabled;\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Enables the tooltip, which is the tooltip is in DOM but\n * not yet displayed.\n */\n@define-mixin ck-tooltip_enabled {\n\t& .ck-tooltip {\n\t\tdisplay: block;\n\n\t\t/*\n\t\t * Don't display tooltips in devices which don't support :hover.\n\t\t * In fact, it's all about iOS, which forces user to click UI elements twice to execute\n\t\t * the primary action, when tooltips are enabled.\n\t\t *\n\t\t * Q: OK, but why not the following query?\n\t\t *\n\t\t *   @media (hover) {\n\t\t *       display: block;\n\t\t *   }\n\t\t *\n\t\t * A: Because FF does not support it and it would completely disable tooltips\n\t\t * in that browser.\n\t\t *\n\t\t * More in https://github.com/ckeditor/ckeditor5/issues/920.\n\t\t */\n\t\t@media (hover:none) {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n\n/**\n * Disables the tooltip making it disappear from DOM.\n */\n@define-mixin ck-tooltip_disabled {\n\t& .ck-tooltip {\n\t\tdisplay: none;\n\t}\n}\n\n/**\n * Shows the tooltip, which is already in DOM.\n * Requires `ck-tooltip_enabled` first.\n */\n@define-mixin ck-tooltip_visible {\n\t& .ck-tooltip {\n\t\tvisibility: visible;\n\t\topacity: 1;\n\t}\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../mixins/_button.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n\t@mixin ck-button-colors --ck-color-button-default;\n\t@mixin ck-rounded-corners;\n\n\twhite-space: nowrap;\n\tcursor: default;\n\tvertical-align: middle;\n\tpadding: var(--ck-spacing-tiny);\n\ttext-align: center;\n\n\t/* A very important piece of styling. Go to variable declaration to learn more. */\n\tmin-width: var(--ck-ui-component-min-height);\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Normalize the height of the line. Removing this will break consistent height\n\tamong text and text-less buttons (with icons). */\n\tline-height: 1;\n\n\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\tfont-size: inherit;\n\n\t/* Avoid flickering when the foucs border shows up. */\n\tborder: 1px solid transparent;\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */\n\t-webkit-appearance: none;\n\n\t&:active,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n\t}\n\n\t/* Allow icon coloring using the text "color" property. */\n\t& .ck-button__icon {\n\t\t& use,\n\t\t& use * {\n\t\t\tcolor: inherit;\n\t\t}\n\t}\n\n\t& .ck-button__label {\n\t\t/* Enable font size inheritance, which allows fluid UI scaling. */\n\t\tfont-size: inherit;\n\t\tfont-weight: inherit;\n\t\tcolor: inherit;\n\t\tcursor: inherit;\n\n\t\t/* Must be consistent with .ck-icon\'s vertical align. Otherwise, buttons with and\n\t\twithout labels (but with icons) have different sizes in Chrome */\n\t\tvertical-align: middle;\n\n\t\t@mixin ck-dir ltr {\n\t\t\ttext-align: left;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\ttext-align: right;\n\t\t}\n\t}\n\n\t& .ck-button__keystroke {\n\t\tcolor: inherit;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: var(--ck-spacing-large);\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-right: var(--ck-spacing-large);\n\t\t}\n\n\t\tfont-weight: bold;\n\t\topacity: .7;\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */\n\t&.ck-disabled {\n\t\t&:active,\n\t\t&:focus {\n\t\t\t/* The disabled button should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n\t\t}\n\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t\t& .ck-button__label {\n\t\t\t@mixin ck-disabled;\n\t\t}\n\n\t\t& .ck-button__keystroke {\n\t\t\topacity: .3;\n\t\t}\n\t}\n\n\t&.ck-button_with-text {\n\t\tpadding: var(--ck-spacing-tiny) var(--ck-spacing-standard);\n\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__icon {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-right: calc(-1 * var(--ck-spacing-small));\n\t\t\t\tmargin-left: var(--ck-spacing-small);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-button_with-keystroke {\n\t\t/* stylelint-disable-next-line no-descending-specificity */\n\t\t& .ck-button__label {\n\t\t\tflex-grow: 1;\n\t\t}\n\t}\n\n\t/* A style of the button which is currently on, e.g. its feature is active. */\n\t&.ck-on {\n\t\t@mixin ck-button-colors --ck-color-button-on;\n\t}\n\n\t&.ck-button-save {\n\t\tcolor: var(--ck-color-button-save);\n\t}\n\n\t&.ck-button-cancel {\n\t\tcolor: var(--ck-color-button-cancel);\n\t}\n}\n\n/* A style of the button which handles the primary action. */\n.ck.ck-button-action,\na.ck.ck-button-action {\n\t@mixin ck-button-colors --ck-color-button-action;\n\n\tcolor: var(--ck-color-button-action-text);\n}\n\n.ck.ck-button-bold,\na.ck.ck-button-bold {\n\tfont-weight: bold;\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n\tbackground: var($(prefix)-background);\n\n\t&:not(.ck-disabled) {\n\t\t&:hover {\n\t\t\tbackground: var($(prefix)-hover-background);\n\t\t}\n\n\t\t&:active {\n\t\t\tbackground: var($(prefix)-active-background);\n\t\t\tbox-shadow: inset 0 2px 2px var($(prefix)-active-shadow);\n\t\t}\n\t}\n\n\t/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n\t&.ck-disabled {\n\t\tbackground: var($(prefix)-disabled-background);\n\t}\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-list{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-direction:column}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{list-style-type:none;background:var(--ck-color-list-background)}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{min-height:unset;width:100%;text-align:left;border-radius:0;padding:calc(var(--ck-line-height-base)*0.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*0.4*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck.ck-list__separator{height:1px;width:100%;background:var(--ck-color-base-border)}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
          ],
          names: [],
          mappings:
            "AAOA,YCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,qBAcD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAGC,oBAAqB,CACrB,0CACD,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BACC,gBAAiB,CACjB,UAAW,CACX,eAAgB,CAChB,eAAgB,CAKhB,mIAiCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,2DACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,uBACC,UAAW,CACX,UAAW,CACX,sCACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-direction: column;\n\n\t& .ck-list__item,\n\t& .ck-list__separator {\n\t\tdisplay: block;\n\t}\n\n\t/* Make sure that whatever child of the list item gets focus, it remains on the\n\ttop. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n\tadjacent list items. */\n\t& .ck-list__item > *:focus {\n\t\tposition: relative;\n\t\tz-index: var(--ck-z-default);\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-list {\n\t@mixin ck-rounded-corners;\n\n\tlist-style-type: none;\n\tbackground: var(--ck-color-list-background);\n}\n\n.ck.ck-list__item {\n\tcursor: default;\n\tmin-width: 12em;\n\n\t& .ck-button {\n\t\tmin-height: unset;\n\t\twidth: 100%;\n\t\ttext-align: left;\n\t\tborder-radius: 0;\n\n\t\t/* List items should have the same height. Use absolute units to make sure it is so\n\t\t   because e.g. different heading styles may have different height\n\t\t   https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\tpadding:\n\t\t\tcalc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))\n\t\t\tcalc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\n\t\t& .ck-button__label {\n\t\t\t/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */\n\t\t\tline-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-button-on-background);\n\t\t\tcolor: var(--ck-color-list-button-on-text);\n\n\t\t\t&:active {\n\t\t\t\tbox-shadow: none;\n\t\t\t}\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-on-background-focus);\n\t\t\t}\n\n\t\t\t&:focus:not(.ck-disabled) {\n\t\t\t\tborder-color: var(--ck-color-base-background);\n\t\t\t}\n\t\t}\n\n\t\t&:hover:not(.ck-disabled) {\n\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t}\n\t}\n\n\t/* It\'s unnecessary to change the background/text of a switch toggle; it has different ways\n\tof conveying its state (like the switcher) */\n\t& .ck-switchbutton {\n\t\t&.ck-on {\n\t\t\tbackground: var(--ck-color-list-background);\n\t\t\tcolor: inherit;\n\n\t\t\t&:hover:not(.ck-disabled) {\n\t\t\t\tbackground: var(--ck-color-list-button-hover-background);\n\t\t\t\tcolor: inherit;\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-list__separator {\n\theight: 1px;\n\twidth: 100%;\n\tbackground: var(--ck-color-base-border);\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:1.0769230769em;--ck-switch-button-toggle-spacing:1px;--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - var(--ck-switch-button-toggle-spacing)*2)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{transition:background .4s ease;width:var(--ck-switch-button-toggle-width);background:var(--ck-color-switch-button-off-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*0.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{margin:var(--ck-switch-button-toggle-spacing);width:var(--ck-switch-button-toggle-inner-size);height:var(--ck-switch-button-toggle-inner-size);background:var(--ck-color-switch-button-inner-background);transition:all .3s ease}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var(--ck-switch-button-translation))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var(--ck-switch-button-translation)*-1))}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css",
          ],
          names: [],
          mappings:
            "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,mDAAoD,CACpD,qCAAsC,CACtC,gKAKD,CAGC,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDC3BA,eDoEA,CAzCA,yICvBC,qCDgED,CAzCA,2DAKE,gBAoCF,CAzCA,2DAUE,iBA+BF,CAzCA,iDAcC,8BAAiC,CAEjC,0CAA2C,CAC3C,uDAwBD,CAtBC,2EC9CD,eD2DC,CAbA,6LC1CA,qCAAsC,CD4CpC,+CAWF,CAbA,2EAMC,6CAA8C,CAC9C,+CAAgD,CAChD,gDAAiD,CACjD,yDAA0D,CAG1D,uBACD,CAEA,uDACC,6DAKD,CAHC,iFACC,+DACD,CAIF,6DExEA,kCF0EA,CAEA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,yDAMF,CAXA,2FASE,kEAEF",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__toggle {\n\t\tdisplay: block;\n\n\t\t& .ck-button__toggle__inner {\n\t\t\tdisplay: block;\n\t\t}\n\t}\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floatingpoint numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n\t/* 34px at 13px font-size */\n\t--ck-switch-button-toggle-width: 2.6153846154em;\n\t/* 14px at 13px font-size */\n\t--ck-switch-button-toggle-inner-size: 1.0769230769em;\n\t--ck-switch-button-toggle-spacing: 1px;\n\t--ck-switch-button-translation: calc(\n\t\tvar(--ck-switch-button-toggle-width) -\n\t\tvar(--ck-switch-button-toggle-inner-size) -\n\t\t2 * var(--ck-switch-button-toggle-spacing)\n\t);\n}\n\n.ck.ck-button.ck-switchbutton {\n\t& .ck-button__label {\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-right: calc(2 * var(--ck-spacing-large));\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Separate the label from the switch */\n\t\t\tmargin-left: calc(2 * var(--ck-spacing-large));\n\t\t}\n\t}\n\n\t& .ck-button__toggle {\n\t\t@mixin ck-rounded-corners;\n\n\t\t@mixin ck-dir ltr {\n\t\t\t/* Make sure the toggle is always to the right as far as possible. */\n\t\t\tmargin-left: auto;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\t/* Make sure the toggle is always to the left as far as possible. */\n\t\t\tmargin-right: auto;\n\t\t}\n\n\t\t/* Gently animate the background color of the toggle switch */\n\t\ttransition: background 400ms ease;\n\n\t\twidth: var(--ck-switch-button-toggle-width);\n\t\tbackground: var(--ck-color-switch-button-off-background);\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-radius: calc(.5 * var(--ck-border-radius));\n\t\t\t}\n\n\t\t\t/* Leave some tiny bit of space around the inner part of the switch */\n\t\t\tmargin: var(--ck-switch-button-toggle-spacing);\n\t\t\twidth: var(--ck-switch-button-toggle-inner-size);\n\t\t\theight: var(--ck-switch-button-toggle-inner-size);\n\t\t\tbackground: var(--ck-color-switch-button-inner-background);\n\n\t\t\t/* Gently animate the inner part of the toggle switch */\n\t\t\ttransition: all 300ms ease;\n\t\t}\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-off-hover-background);\n\n\t\t\t& .ck-button__toggle__inner {\n\t\t\t\tbox-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n\t\t\t}\n\t\t}\n\t}\n\n\t&.ck-disabled .ck-button__toggle {\n\t\t@mixin ck-disabled;\n\t}\n\n\t&.ck-on .ck-button__toggle {\n\t\tbackground: var(--ck-color-switch-button-on-background);\n\n\t\t&:hover {\n\t\t\tbackground: var(--ck-color-switch-button-on-hover-background);\n\t\t}\n\n\t\t& .ck-button__toggle__inner {\n\t\t\t/*\n\t\t\t * Move the toggle switch to the right. It will be animated.\n\t\t\t */\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\ttransform: translateX( var( --ck-switch-button-translation ) );\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\ttransform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n\t\t\t}\n\t\t}\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n\topacity: var(--ck-disabled-opacity);\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-toolbar-dropdown .ck.ck-toolbar .ck.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar-dropdown .ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css",
          ],
          names: [],
          mappings: "AAMC,6DACC,gBACD,CAGC,6DACC,qCACD,CCRF,oCACC,QACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown {\n\t& .ck.ck-toolbar .ck.ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& .ck-dropdown__panel .ck-button {\n\t\t&:focus {\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n\tborder: 0;\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
          ],
          names: [],
          mappings:
            "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDIpC,wBAAyB,CACzB,2BAA4B,CAC5B,4BAEF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n\t/* Disabled radius of top-left border to be consistent with .dropdown__button\n\thttps://github.com/ckeditor/ckeditor5/issues/816 */\n\t@mixin ck-rounded-corners {\n\t\tborder-top-left-radius: 0;\n\t}\n\n\t/* Make sure the button belonging to the first/last child of the list goes well with the\n\tborder radius of the entire panel. */\n\t& .ck-list__item {\n\t\t&:first-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-bottom-left-radius: 0;\n\t\t\t\tborder-bottom-right-radius: 0;\n\t\t\t}\n\t\t}\n\n\t\t&:last-child .ck-button {\n\t\t\t@mixin ck-rounded-corners {\n\t\t\t\tborder-top-left-radius: 0;\n\t\t\t\tborder-top-right-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-toolbar{-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none;display:flex;flex-flow:row nowrap;align-items:center}.ck.ck-toolbar>.ck-toolbar__items{display:flex;flex-flow:row wrap;align-items:center;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);padding:0 var(--ck-spacing-small);border:1px solid var(--ck-color-toolbar-border)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;width:1px;min-width:1px;background:var(--ck-color-toolbar-border);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items>*{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>*,.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{width:100%;margin:0;border-radius:0;border:0}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=rtl].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.ck.ck-toolbar[dir=ltr].ck-toolbar_compact>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr].ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child){margin-right:var(--ck-spacing-small)}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
          ],
          names: [],
          mappings:
            "AAOA,eCEC,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBAAgB,CDFhB,YAAa,CACb,oBAAqB,CACrB,kBAyCD,CAvCC,kCACC,YAAa,CACb,kBAAmB,CACnB,kBAAmB,CACnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE3CF,eCGC,eD0FD,CA7FA,qECOE,qCDsFF,CA7FA,eAGC,6CAA8C,CAC9C,iCAAkC,CAClC,+CAwFD,CAtFC,yCACC,kBAAmB,CACnB,SAAU,CACV,aAAc,CACd,yCAA0C,CAM1C,kCAAmC,CACnC,qCACD,CAGC,oCAEC,kCAAmC,CACnC,qCAAsC,CAGtC,oCACD,CAIA,kEACC,YACD,CAGD,oFAGC,kCAAmC,CACnC,qCACD,CAEA,mCAEC,SAgBD,CAbC,0DAEC,UAAW,CAGX,QAAS,CAGT,eAAgB,CAGhB,QACD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAvFF,qCA2FE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JACC,wBAAyB,CACzB,2BACD,CAGA,2JACC,yBAA0B,CAC1B,4BACD,CAID,qGACC,mCACD,CAGA,yLACC,mCACD,CAWA,qHACC,cACD,CAIC,6JACC,yBAA0B,CAC1B,4BACD,CAGA,2JACC,wBAAyB,CACzB,2BACD,CAID,qGACC,oCACD,CAGA,yLACC,oCACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-unselectable;\n\n\tdisplay: flex;\n\tflex-flow: row nowrap;\n\talign-items: center;\n\n\t& > .ck-toolbar__items {\n\t\tdisplay: flex;\n\t\tflex-flow: row wrap;\n\t\talign-items: center;\n\t\tflex-grow: 1;\n\n\t}\n\n\t& .ck.ck-toolbar__separator {\n\t\tdisplay: inline-block;\n\n\t\t/*\n\t\t * A leading or trailing separator makes no sense (separates from nothing on one side).\n\t\t * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n\t\t * moved to another toolbar in the dropdown.\n\t\t */\n\t\t&:first-child,\n\t\t&:last-child {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t&.ck-toolbar_grouping > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t&.ck-toolbar_vertical > .ck-toolbar__items {\n\t\tflex-direction: column;\n\t}\n\n\t&.ck-toolbar_floating > .ck-toolbar__items {\n\t\tflex-wrap: nowrap;\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t& > .ck-dropdown__button .ck-dropdown__arrow {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n\t-moz-user-select: none;\n\t-webkit-user-select: none;\n\t-ms-user-select: none;\n\tuser-select: none\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-toolbar {\n\t@mixin ck-rounded-corners;\n\n\tbackground: var(--ck-color-toolbar-background);\n\tpadding: 0 var(--ck-spacing-small);\n\tborder: 1px solid var(--ck-color-toolbar-border);\n\n\t& .ck.ck-toolbar__separator {\n\t\talign-self: stretch;\n\t\twidth: 1px;\n\t\tmin-width: 1px;\n\t\tbackground: var(--ck-color-toolbar-border);\n\n\t\t/*\n\t\t * These margins make the separators look better in balloon toolbars (when aligned with the "tip").\n\t\t * See https://github.com/ckeditor/ckeditor5/issues/7493.\n\t\t */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items {\n\t\t& > * {\n\t\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\t\tmargin-top: var(--ck-spacing-small);\n\t\t\tmargin-bottom: var(--ck-spacing-small);\n\n\t\t\t/* (#11) Separate toolbar items. */\n\t\t\tmargin-right: var(--ck-spacing-small);\n\t\t}\n\n\t\t/* Don\'t display a separator after an empty items container, for instance,\n\t\twhen all items were grouped */\n\t\t&:empty + .ck.ck-toolbar__separator {\n\t\t\tdisplay: none;\n\t\t}\n\t}\n\n\t& > .ck-toolbar__items > *,\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/* Make sure items wrapped to the next line have v-spacing */\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t&.ck-toolbar_vertical {\n\t\t/* Items in a vertical toolbar span the entire width. */\n\t\tpadding: 0;\n\n\t\t/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */\n\t\t& > .ck-toolbar__items > .ck {\n\t\t\t/* Items in a vertical toolbar should span the horizontal space. */\n\t\t\twidth: 100%;\n\n\t\t\t/* Items in a vertical toolbar should have no margin. */\n\t\t\tmargin: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */\n\t\t\tborder-radius: 0;\n\n\t\t\t/* Items in a vertical toolbar span the entire width so any border is pointless. */\n\t\t\tborder: 0;\n\t\t}\n\t}\n\n\t&.ck-toolbar_compact {\n\t\t/* No spacing around items. */\n\t\tpadding: 0;\n\n\t\t& > .ck-toolbar__items > * {\n\t\t\t/* Compact toolbar items have no spacing between them. */\n\t\t\tmargin: 0;\n\n\t\t\t/* "Middle" children should have no rounded corners. */\n\t\t\t&:not(:first-child):not(:last-child) {\n\t\t\t\tborder-radius: 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t& > .ck.ck-toolbar__grouped-dropdown {\n\t\t/*\n\t\t * Dropdown button has asymmetric padding to fit the arrow.\n\t\t * This button has no arrow so let\'s revert that padding back to normal.\n\t\t */\n\t\t& > .ck.ck-button.ck-dropdown__button {\n\t\t\tpadding-left: var(--ck-spacing-tiny);\n\t\t}\n\t}\n\n\t@nest .ck-toolbar-container & {\n\t\tborder: 0;\n\t}\n}\n\n/* stylelint-disable */\n\n/*\n * Styles for RTL toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="rtl"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="rtl"] {\n\t& > .ck-toolbar__items > .ck {\n\t\tmargin-right: 0;\n\t}\n\n\t&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {\n\t\t/* (#11) Separate toolbar items. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-left: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n/*\n * Styles for LTR toolbars.\n *\n * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"\n * because its parent is not controlled by the editor framework.\n */\n[dir="ltr"] .ck.ck-toolbar,\n.ck.ck-toolbar[dir="ltr"] {\n\t& > .ck-toolbar__items > .ck:last-child {\n\t\tmargin-right: 0;\n\t}\n\n\t&.ck-toolbar_compact > .ck-toolbar__items > .ck {\n\t\t/* No rounded corners on the right side of the first child. */\n\t\t&:first-child {\n\t\t\tborder-top-right-radius: 0;\n\t\t\tborder-bottom-right-radius: 0;\n\t\t}\n\n\t\t/* No rounded corners on the left side of the last child. */\n\t\t&:last-child {\n\t\t\tborder-top-left-radius: 0;\n\t\t\tborder-bottom-left-radius: 0;\n\t\t}\n\t}\n\n\t/* Separate the the separator form the grouping dropdown when some items are grouped. */\n\t& > .ck.ck-toolbar__separator {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n\n\t/* Some spacing between the items and the separator before the grouped items dropdown. */\n\t&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {\n\t\tmargin-right: var(--ck-spacing-small);\n\t}\n}\n\n/* stylelint-enable */\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck-content blockquote{overflow:hidden;padding-right:1.5em;padding-left:1.5em;margin-left:0;margin-right:0;font-style:italic;border-left:5px solid #ccc}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css",
          ],
          names: [],
          mappings:
            "AAKA,uBAEC,eAAgB,CAGhB,mBAAoB,CACpB,kBAAmB,CAEnB,aAAc,CACd,cAAe,CACf,iBAAkB,CAClB,0BACD,CAEA,gCACC,aAAc,CACd,2BACD",
          sourcesContent: [
            '/**\n * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n\t/* See #12 */\n\toverflow: hidden;\n\n\t/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n\tpadding-right: 1.5em;\n\tpadding-left: 1.5em;\n\n\tmargin-left: 0;\n\tmargin-right: 0;\n\tfont-style: italic;\n\tborder-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n\tborder-left: 0;\n\tborder-right: solid 5px hsl(0, 0%, 80%);\n}\n',
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-heading/theme/heading.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css",
          ],
          names: [],
          mappings:
            "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n\tfont-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n\tfont-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n\tfont-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n\tfont-weight: bold;\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n\t& .ck-dropdown__button .ck-button__label {\n\t\twidth: 8em;\n\t}\n\n\t& .ck-dropdown__panel .ck-list__item {\n\t\tmin-width: 18em;\n\t}\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        '.ck .ck-widget .ck-widget__type-around__button{display:block;position:absolute;overflow:hidden;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{position:absolute;top:50%;left:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{top:calc(var(--ck-widget-outline-thickness)*-0.5);left:min(10%,30px);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-0.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;position:absolute;top:1px;left:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;position:absolute;left:0;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{top:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{width:var(--ck-widget-type-around-button-size);height:var(--ck-widget-type-around-button-size);background:var(--ck-color-widget-type-around-button);border-radius:100px;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);opacity:0;pointer-events:none}.ck .ck-widget .ck-widget__type-around__button svg{width:10px;height:8px;transform:translate(-50%,-50%);transition:transform .5s ease;margin-top:1px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{width:calc(var(--ck-widget-type-around-button-size) - 2px);height:calc(var(--ck-widget-type-around-button-size) - 2px);border-radius:100px;background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3))}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{pointer-events:none;height:1px;animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;outline:1px solid hsla(0,0%,100%,.5);background:var(--ck-color-base-text)}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer{opacity:0}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}',
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css",
          ],
          names: [],
          mappings:
            "AASC,+CACC,aAAc,CACd,iBAAkB,CAClB,eAAgB,CAChB,2BAwBD,CAtBC,mDACC,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAEA,qFAEC,iDAAoD,CACpD,kBAAoB,CAEpB,0BACD,CAEA,oFAEC,oDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CACd,iBAAkB,CAClB,OAAQ,CACR,QAAS,CACT,qCACD,CAMD,2EACC,YAAa,CACb,iBAAkB,CAClB,MAAO,CACP,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHACC,qDAA0D,CAC1D,aACD,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CACC,8CAA+C,CAC/C,+CAAgD,CAChD,oDAAqD,CACrD,mBAAoB,CACpB,uMAAyM,CAb1M,SAAU,CACV,mBA0DA,CA1CC,mDACC,UAAW,CACX,UAAW,CACX,8BAA+B,CAC/B,6BAA8B,CAC9B,cAgBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLACC,0DAA2D,CAC3D,2DAA4D,CAC5D,mBAAoB,CACpB,uEACD,CAOD,8GACC,gBACD,CAKA,mDACC,mBAAoB,CACpB,UAAW,CACX,mFAAoF,CAMpF,oCAAwC,CACxC,oCACD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CASE,0jBACC,SACD,CASF,mPACC,SACD,CAcC,iRAxLF,SAAU,CACV,mBAyLE,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\tdisplay: block;\n\t\tposition: absolute;\n\t\toverflow: hidden;\n\t\tz-index: var(--ck-z-default);\n\n\t\t& svg {\n\t\t\tposition: absolute;\n\t\t\ttop: 50%;\n\t\t\tleft: 50%;\n\t\t\tz-index: calc(var(--ck-z-default) + 2);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_before {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\ttop: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tleft: min(10%, 30px);\n\n\t\t\ttransform: translateY(-50%);\n\t\t}\n\n\t\t&.ck-widget__type-around__button_after {\n\t\t\t/* Place it in the middle of the outline */\n\t\t\tbottom: calc(-0.5 * var(--ck-widget-outline-thickness));\n\t\t\tright: min(10%, 30px);\n\n\t\t\ttransform: translateY(50%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\t&::after {\n\t\t\tcontent: "";\n\t\t\tdisplay: block;\n\t\t\tposition: absolute;\n\t\t\ttop: 1px;\n\t\t\tleft: 1px;\n\t\t\tz-index: calc(var(--ck-z-default) + 1);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tdisplay: none;\n\t\tposition: absolute;\n\t\tleft: 0;\n\t\tright: 0;\n\t}\n\n\t/*\n\t * When the widget is hovered the "fake caret" would normally be narrower than the\n\t * extra outline displayed around the widget. Let\'s extend the "fake caret" to match\n\t * the full width of the widget.\n\t */\n\t&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tleft: calc( -1 * var(--ck-widget-outline-thickness) );\n\t\tright: calc( -1 * var(--ck-widget-outline-thickness) );\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\ttop: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).\n\t */\n\t&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {\n\t\tbottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );\n\t\tdisplay: block;\n\t}\n}\n\n/*\n * Integration with the read-only mode of the editor.\n */\n.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the restricted editing mode (feature) of the editor.\n */\n.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {\n\tdisplay: none;\n}\n\n/*\n * Integration with the #isEnabled property of the WidgetTypeAround plugin.\n */\n.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {\n\tdisplay: none;\n}\n',
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-widget-type-around-button-size: 20px;\n\t--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);\n\t--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);\n\t--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);\n\t--ck-color-widget-type-around-button-radar-start-alpha: 0;\n\t--ck-color-widget-type-around-button-radar-end-alpha: .3;\n\t--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);\n}\n\n@define-mixin ck-widget-type-around-button-visible {\n\topacity: 1;\n\tpointer-events: auto;\n}\n\n@define-mixin ck-widget-type-around-button-hidden {\n\topacity: 0;\n\tpointer-events: none;\n}\n\n.ck .ck-widget {\n\t/*\n\t * Styles of the type around buttons\n\t */\n\t& .ck-widget__type-around__button {\n\t\twidth: var(--ck-widget-type-around-button-size);\n\t\theight: var(--ck-widget-type-around-button-size);\n\t\tbackground: var(--ck-color-widget-type-around-button);\n\t\tborder-radius: 100px;\n\t\ttransition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t@mixin ck-widget-type-around-button-hidden;\n\n\t\t& svg {\n\t\t\twidth: 10px;\n\t\t\theight: 8px;\n\t\t\ttransform: translate(-50%,-50%);\n\t\t\ttransition: transform .5s ease;\n\t\t\tmargin-top: 1px;\n\n\t\t\t& * {\n\t\t\t\tstroke-dasharray: 10;\n\t\t\t\tstroke-dashoffset: 0;\n\n\t\t\t\tfill: none;\n\t\t\t\tstroke: var(--ck-color-widget-type-around-button-icon);\n\t\t\t\tstroke-width: 1.5px;\n\t\t\t\tstroke-linecap: round;\n\t\t\t\tstroke-linejoin: round;\n\t\t\t}\n\n\t\t\t& line {\n\t\t\t\tstroke-dasharray: 7;\n\t\t\t}\n\t\t}\n\n\t\t&:hover {\n\t\t\t/*\n\t\t\t * Display the "sonar" around the button when hovered.\n\t\t\t */\n\t\t\tanimation: ck-widget-type-around-button-sonar 1s ease infinite;\n\n\t\t\t/*\n\t\t\t * Animate active button\'s icon.\n\t\t\t */\n\t\t\t& svg {\n\t\t\t\t& polyline {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-dash 2s linear;\n\t\t\t\t}\n\n\t\t\t\t& line {\n\t\t\t\t\tanimation: ck-widget-type-around-arrow-tip-dash 2s linear;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/*\n\t * Show type around buttons when the widget gets selected or being hovered.\n\t */\n\t&.ck-widget_selected,\n\t&:hover {\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-visible;\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the buttons when the widget is NOT selected (but the buttons are visible\n\t * and still can be hovered).\n\t */\n\t&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\tbackground: var(--ck-color-widget-type-around-button-hover);\n\t}\n\n\t/*\n\t * Styles for the buttons when:\n\t * - the widget is selected,\n\t * - or the button is being hovered (regardless of the widget state).\n\t */\n\t&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,\n\t& > .ck-widget__type-around > .ck-widget__type-around__button:hover {\n\t\tbackground: var(--ck-color-widget-type-around-button-active);\n\n\t\t&::after {\n\t\t\twidth: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\theight: calc(var(--ck-widget-type-around-button-size) - 2px);\n\t\t\tborder-radius: 100px;\n\t\t\tbackground: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);\n\t\t}\n\t}\n\n\t/*\n\t * Styles for the "before" button when the widget has a selection handle. Because some space\n\t * is consumed by the handle, the button must be moved slightly to the right to let it breathe.\n\t */\n\t&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {\n\t\tmargin-left: 20px;\n\t}\n\n\t/*\n\t * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.\n\t */\n\t& .ck-widget__type-around__fake-caret {\n\t\tpointer-events: none;\n\t\theight: 1px;\n\t\tanimation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;\n\n\t\t/*\n\t\t * The semi-transparent-outline+background combo improves the contrast\n\t\t * when the background underneath the fake caret is dark.\n\t\t */\n\t\toutline: solid 1px hsla(0, 0%, 100%, .5);\n\t\tbackground: var(--ck-color-base-text);\n\t}\n\n\t/*\n\t * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t * Despite the widget being physically selected in the model, its outline should disappear.\n\t */\n\t&.ck-widget_selected {\n\t\t&.ck-widget_type-around_show-fake-caret_before,\n\t\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t\toutline-color: transparent;\n\t\t}\n\t}\n\n\t&.ck-widget_type-around_show-fake-caret_before,\n\t&.ck-widget_type-around_show-fake-caret_after {\n\t\t/*\n\t\t * When the "fake caret" is visible we simulate that the widget is not selected\n\t\t * (despite being physically selected), so the outline color should be for the\n\t\t * unselected widget.\n\t\t */\n\t\t&.ck-widget_selected:hover {\n\t\t\toutline-color: var(--ck-color-widget-hover-border);\n\t\t}\n\n\t\t/*\n\t\t * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).\n\t\t * In this state, the type around buttons would collide with the fake carets so they should disappear.\n\t\t */\n\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the selection handle. When the caret is visible, simply\n\t\t * hide the handle because it intersects with the caret (and does not make much sense anyway).\n\t\t */\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t&.ck-widget_selected,\n\t\t\t&.ck-widget_selected:hover {\n\t\t\t\t& > .ck-widget__selection-handle {\n\t\t\t\t\topacity: 0\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Fake horizontal caret integration with the resize UI. When the caret is visible, simply\n\t\t * hide the resize UI because it creates too much noise. It can be visible when the user\n\t\t * hovers the widget, though.\n\t\t */\n\t\t&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {\n\t\t\topacity: 0\n\t\t}\n\t}\n}\n\n/*\n * Hide type around buttons when the widget is selected as a child of a selected\n * nested editable (e.g. mulit-cell table selection).\n *\n * See https://github.com/ckeditor/ckeditor5/issues/7263.\n */\n.ck-editor__nested-editable.ck-editor__editable_selected {\n\t& .ck-widget {\n\t\t&.ck-widget_selected,\n\t\t&:hover {\n\t\t\t& > .ck-widget__type-around > .ck-widget__type-around__button {\n\t\t\t\t@mixin ck-widget-type-around-button-hidden;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/*\n * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).\n */\n.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {\n\tbackground: var(--ck-color-widget-type-around-button-blurred-editable);\n\n\t& svg * {\n\t\tstroke: hsl(0,0%,60%);\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-dash {\n\t0% {\n\t\tstroke-dashoffset: 10;\n\t}\n\t20%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-arrow-tip-dash {\n\t0%, 20% {\n\t\tstroke-dashoffset: 7;\n\t}\n\t40%, 100% {\n\t\tstroke-dashoffset: 0;\n\t}\n}\n\n@keyframes ck-widget-type-around-button-sonar {\n\t0% {\n\t\tbox-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n\t50% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));\n\t}\n\t100% {\n\t\tbox-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));\n\t}\n}\n\n@keyframes ck-widget-type-around-fake-caret-pulse {\n\t0% {\n\t\topacity: 1;\n\t}\n\t49% {\n\t\topacity: 1;\n\t}\n\t50% {\n\t\topacity: 0;\n\t}\n\t99% {\n\t\topacity: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t}\n}\n',
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-resizer-size:10px;--ck-resizer-border-width:1px;--ck-resizer-border-radius:2px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-tooltip-offset:10px;--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);color:var(--ck-color-resizer-tooltip-text);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);font-size:var(--ck-font-size-tiny);display:block;padding:var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{top:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{top:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-width:var(--ck-widget-outline-thickness);outline-style:solid;outline-color:transparent;transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;background-color:var(--ck-color-widget-editable-focus-background)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{padding:4px;box-sizing:border-box;background-color:transparent;opacity:0;transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;transform:translateY(-100%);left:calc(0px - var(--ck-widget-outline-thickness))}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{width:var(--ck-widget-handler-icon-size);height:var(--ck-widget-handler-icon-size);color:var(--ck-color-widget-drag-handler-icon-color)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle{opacity:1;background-color:var(--ck-color-focus-border)}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle .ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-widget/theme/widget.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
          ],
          names: [],
          mappings:
            "AAKA,MACC,+CAAgD,CAChD,sBAAuB,CACvB,6BAA8B,CAC9B,8BAA+B,CAG/B,yDAAiE,CAEjE,gCAAiC,CACjC,6CAAsD,CACtD,uCACD,CAOA,8DAEC,iBAuBD,CArBC,4EACC,iBAOD,CALC,qFAGC,aACD,CAWD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CACtD,0CAA2C,CAC3C,qDAAsD,CACtD,6CAA8C,CAC9C,kCAAmC,CACnC,aAAc,CACd,+BA4BD,CA1BC,gLAIC,iBACD,CAEA,0CACC,oCAAuC,CACvC,qCACD,CAEA,2CACC,oCAAuC,CACvC,sCACD,CAEA,8CACC,uCAA0C,CAC1C,sCACD,CAEA,6CACC,uCAA0C,CAC1C,qCACD,CC7ED,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eACC,gDAAiD,CACjD,mBAAoB,CACpB,yBAA0B,CAC1B,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGC/BA,YAAa,CACb,2BAA2B,CCF3B,qCAA8B,CFqC7B,iEACD,CAIA,4EACC,WAAY,CACZ,qBAAsB,CAGtB,4BAA6B,CAC7B,SAAU,CAMV,6SAG6F,CAG7F,iEAAkE,CAGlE,2BAA4B,CAC5B,mDAqBD,CAnBC,qFAEC,wCAAyC,CACzC,yCAA0C,CAC1C,oDASD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFACC,SAAU,CACV,oDACD,CAKC,oMACC,SAAU,CACV,6CAMD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-resizer: var(--ck-color-focus-border);\n\t--ck-resizer-size: 10px;\n\t--ck-resizer-border-width: 1px;\n\t--ck-resizer-border-radius: 2px;\n\n\t/* Set the resizer with a 50% offset. */\n\t--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n\n\t--ck-resizer-tooltip-offset: 10px;\n\t--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n\t--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n}\n\n.ck .ck-widget {\n\t/* This is neccessary for type around UI to be positioned properly. */\n\tposition: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t/* Make the widget wrapper a relative positioning container for the drag handle. */\n\tposition: relative;\n\n\t& .ck-widget__selection-handle {\n\t\tposition: absolute;\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the icon in not a subject to font-size or line-height to avoid\n\t\t\tunnecessary spacing around it. */\n\t\t\tdisplay: block;\n\t\t}\n\t}\n\n\t/* Show the selection handle on mouse hover over the widget. */\n\t&:hover {\n\t\t& .ck-widget__selection-handle {\n\t\t\tvisibility: visible;\n\t\t}\n\t}\n\n\t/* Show the selection handle when the widget is selected. */\n\t&.ck-widget_selected .ck-widget__selection-handle {\n\t\tvisibility: visible;\n\t}\n}\n\n.ck .ck-size-view {\n\tbackground: var(--ck-color-resizer-tooltip-background);\n\tcolor: var(--ck-color-resizer-tooltip-text);\n\tborder: 1px solid var(--ck-color-resizer-tooltip-text);\n\tborder-radius: var(--ck-resizer-border-radius);\n\tfont-size: var(--ck-font-size-tiny);\n\tdisplay: block;\n\tpadding: var(--ck-spacing-small);\n\n\t&.ck-orientation-top-left,\n\t&.ck-orientation-top-right,\n\t&.ck-orientation-bottom-right,\n\t&.ck-orientation-bottom-left {\n\t\tposition: absolute;\n\t}\n\n\t&.ck-orientation-top-left {\n\t\ttop: var( --ck-resizer-tooltip-offset );\n\t\tleft: var( --ck-resizer-tooltip-offset );\n\t}\n\n\t&.ck-orientation-top-right {\n\t\ttop: var( --ck-resizer-tooltip-offset );\n\t\tright: var( --ck-resizer-tooltip-offset );\n\t}\n\n\t&.ck-orientation-bottom-right {\n\t\tbottom: var( --ck-resizer-tooltip-offset );\n\t\tright: var( --ck-resizer-tooltip-offset );\n\t}\n\n\t&.ck-orientation-bottom-left {\n\t\tbottom: var( --ck-resizer-tooltip-offset );\n\t\tleft: var( --ck-resizer-tooltip-offset );\n\t}\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n\t--ck-widget-outline-thickness: 3px;\n\t--ck-widget-handler-icon-size: 16px;\n\t--ck-widget-handler-animation-duration: 200ms;\n\t--ck-widget-handler-animation-curve: ease;\n\n\t--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n\t--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n\t--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n\t--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n\toutline-width: var(--ck-widget-outline-thickness);\n\toutline-style: solid;\n\toutline-color: transparent;\n\ttransition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n\t}\n\n\t&:hover {\n\t\toutline-color: var(--ck-color-widget-hover-border);\n\t}\n}\n\n.ck .ck-editor__nested-editable {\n\tborder: 1px solid transparent;\n\n\t/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n\tThese styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n\t&.ck-editor__nested-editable_focused,\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\t\tbackground-color: var(--ck-color-widget-editable-focus-background);\n\t}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n\t& .ck-widget__selection-handle {\n\t\tpadding: 4px;\n\t\tbox-sizing: border-box;\n\n\t\t/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n\t\tbackground-color: transparent;\n\t\topacity: 0;\n\n\t\t/* Transition:\n\t\t   * background-color for the .ck-widget_selected state change,\n\t\t   * visibility for hiding the handler,\n\t\t   * opacity for the proper look of the icon when the handler disappears. */\n\t\ttransition:\n\t\t\tbackground-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\tvisibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n\t\t\topacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n\t\t/* Make only top corners round. */\n\t\tborder-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n\t\t/* Place the drag handler outside the widget wrapper. */\n\t\ttransform: translateY(-100%);\n\t\tleft: calc(0px - var(--ck-widget-outline-thickness));\n\n\t\t& .ck-icon {\n\t\t\t/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n\t\t\twidth: var(--ck-widget-handler-icon-size);\n\t\t\theight: var(--ck-widget-handler-icon-size);\n\t\t\tcolor: var(--ck-color-widget-drag-handler-icon-color);\n\n\t\t\t/* The "selected" part of the icon is invisible by default */\n\t\t\t& .ck-icon__selected-indicator {\n\t\t\t\topacity: 0;\n\n\t\t\t\t/* Note: The animation is longer on purpose. Simply feels better. */\n\t\t\t\ttransition: opacity 300ms var(--ck-widget-handler-animation-curve);\n\t\t\t}\n\t\t}\n\n\t\t/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n\t\t&:hover .ck-icon .ck-icon__selected-indicator {\n\t\t\topacity: 1;\n\t\t}\n\t}\n\n\t/* Show the selection handler on mouse hover over the widget. */\n\t&:hover .ck-widget__selection-handle {\n\t\topacity: 1;\n\t\tbackground-color: var(--ck-color-widget-hover-border);\n\t}\n\n\t/* Show the selection handler when the widget is selected. */\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\t& .ck-widget__selection-handle {\n\t\t\topacity: 1;\n\t\t\tbackground-color: var(--ck-color-focus-border);\n\n\t\t\t/* When the widget is selected, notify the user using the proper look of the icon. */\n\t\t\t& .ck-icon .ck-icon__selected-indicator {\n\t\t\t\topacity: 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n\tleft: auto;\n\tright: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n\t/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n\ttransition: none;\n\n\t&:not(.ck-widget_selected) {\n\t\t/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/1261\n\t\t *\n\t\t * Leave the unit because this custom property is used in calc() by other features.\n\t\t * See: https://github.com/ckeditor/ckeditor5/issues/6775\n\t\t */\n\t\t--ck-widget-outline-thickness: 0px;\n\t}\n\n\t&.ck-widget_with-selection-handle {\n\t\t& .ck-widget__selection-handle,\n\t\t& .ck-widget__selection-handle:hover {\n\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t}\n\t}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n\t&.ck-widget_selected,\n\t&.ck-widget_selected:hover {\n\t\toutline-color: var(--ck-color-widget-blurred-border);\n\n\t\t&.ck-widget_with-selection-handle {\n\t\t\t& .ck-widget__selection-handle,\n\t\t\t& .ck-widget__selection-handle:hover {\n\t\t\t\tbackground: var(--ck-color-widget-blurred-border);\n\t\t\t}\n\t\t}\n\t}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n\t/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n\tIn fact, anything with overflow: hidden.\n\thttps://github.com/ckeditor/ckeditor5-block-quote/issues/28\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/44\n\thttps://github.com/ckeditor/ckeditor5-widget/issues/66 */\n\tmargin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css",
          ],
          names: [],
          mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tdisplay: block;\n}\n\n.ck.ck-voice-label {\n\tdisplay: none;\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n\tfont-weight: bold;\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view>.ck.ck-label{width:100%;text-overflow:ellipsis;overflow:hidden}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css",
          ],
          names: [],
          mappings:
            "AAKA,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBACD,CAEA,+DACC,gCACD,CAEA,uCACC,UAAW,CACX,sBAAuB,CACvB,eACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view .ck-labeled-field-view__status {\n\tfont-size: var(--ck-font-size-small);\n\tmargin-top: var(--ck-spacing-small);\n\n\t/* Let the info wrap to the next line to avoid stretching the layout horizontally.\n\tThe status could be very long. */\n\twhite-space: normal;\n}\n\n.ck.ck-labeled-field-view .ck-labeled-field-view__status_error {\n\tcolor: var(--ck-color-base-error);\n}\n\n.ck.ck-labeled-field-view > .ck.ck-label {\n\twidth: 100%;\n\ttext-overflow: ellipsis;\n\toverflow: hidden;\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ":root{--ck-input-text-width:18em}.ck.ck-input-text{border-radius:0}.ck-rounded-corners .ck.ck-input-text,.ck.ck-input-text.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-text{box-shadow:var(--ck-inner-shadow),0 0;background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);min-width:var(--ck-input-text-width);min-height:var(--ck-ui-component-min-height);transition:box-shadow .2s ease-in-out,border .2s ease-in-out}.ck.ck-input-text:focus{outline:none;border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text[readonly]{border:1px solid var(--ck-color-input-disabled-border);background:var(--ck-color-input-disabled-background);color:var(--ck-color-input-disabled-text)}.ck.ck-input-text[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),var(--ck-inner-shadow)}.ck.ck-input-text.ck-error{border-color:var(--ck-color-input-error-border);animation:ck-text-input-shake .3s ease both}.ck.ck-input-text.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),var(--ck-inner-shadow)}@keyframes ck-text-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/inputtext/inputtext.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css",
          ],
          names: [],
          mappings:
            "AASA,MACC,0BACD,CAEA,kBCFC,eDyCD,CAvCA,2ECEE,qCDqCF,CAvCA,kBEJC,qCAA8B,CFQ9B,2CAA4C,CAC5C,6CAA8C,CAC9C,6DAA8D,CAC9D,oCAAqC,CAGrC,4CAA6C,CAG7C,4DA0BD,CAxBC,wBGlBA,YAAa,CACb,2BAA2B,CDF3B,8DFsBA,CAEA,4BACC,sDAAuD,CACvD,oDAAqD,CACrD,yCAMD,CAJC,kCE7BD,uEFgCC,CAGD,2BACC,+CAAgD,CAChD,2CAKD,CAHC,iCEvCD,oEFyCC,CAIF,+BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-input-text-width: 18em;\n}\n\n.ck.ck-input-text {\n\t@mixin ck-rounded-corners;\n\t@mixin ck-box-shadow var(--ck-inner-shadow);\n\n\tbackground: var(--ck-color-input-background);\n\tborder: 1px solid var(--ck-color-input-border);\n\tpadding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n\tmin-width: var(--ck-input-text-width);\n\n\t/* This is important to stay of the same height as surrounding buttons */\n\tmin-height: var(--ck-ui-component-min-height);\n\n\t/* Apply some smooth transition to the box-shadow and border. */\n\ttransition: box-shadow .2s ease-in-out, border .2s ease-in-out;\n\n\t&:focus {\n\t\t@mixin ck-focus-ring;\n\t\t@mixin ck-box-shadow var(--ck-focus-outer-shadow), var(--ck-inner-shadow);\n\t}\n\n\t&[readonly] {\n\t\tborder: 1px solid var(--ck-color-input-disabled-border);\n\t\tbackground: var(--ck-color-input-disabled-background);\n\t\tcolor: var(--ck-color-input-disabled-text);\n\n\t\t&:focus {\n\t\t\t/* The read-only input should have a slightly less visible shadow when focused. */\n\t\t\t@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow), var(--ck-inner-shadow);\n\t\t}\n\t}\n\n\t&.ck-error {\n\t\tborder-color: var(--ck-color-input-error-border);\n\t\tanimation: ck-text-input-shake .3s ease both;\n\n\t\t&:focus {\n\t\t\t@mixin ck-box-shadow var(--ck-focus-error-outer-shadow), var(--ck-inner-shadow);\n\t\t}\n\t}\n}\n\n@keyframes ck-text-input-shake {\n\t20% {\n\t\ttransform: translateX(-2px);\n\t}\n\n\t40% {\n\t\ttransform: translateX(2px);\n\t}\n\n\t60% {\n\t\ttransform: translateX(-1px);\n\t}\n\n\t80% {\n\t\ttransform: translateX(1px);\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n\tborder-radius: 0;\n\n\t@nest .ck-rounded-corners &,\n\t&.ck-rounded-corners {\n\t\tborder-radius: var(--ck-border-radius);\n\t\t@mixin-content;\n\t}\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n\t/* Disable native outline. */\n\toutline: none;\n\tborder: var(--ck-focus-ring)\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
          ],
          names: [],
          mappings:
            "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-labeled-field-view {\n\t\tdisplay: inline-block;\n\t}\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        '.ck-vertical-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{content:"";width:0;position:absolute;right:-1px;top:var(--ck-spacing-small);bottom:var(--ck-spacing-small);z-index:1}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-standard)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-text-width)*0.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){padding:var(--ck-spacing-standard);margin-top:var(--ck-spacing-standard);border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after,[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}',
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css",
          ],
          names: [],
          mappings:
            "AAOA,mCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAC5B,8BAA+B,CAC/B,SACD,CCTC,oCDaC,wCACC,UAAW,CACX,OAAQ,CACR,iBAAkB,CAClB,UAAW,CACX,2BAA4B,CAC5B,8BAA+B,CAC/B,SACD,CCnBD,CCAD,qDACC,kDACD,CAEA,uBACC,kCAkED,CAhEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,0CA6CF,CA3CE,8CACC,8DAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAID,iGAEC,kCAAmC,CACnC,qCAAsC,CAEtC,eAAgB,CAChB,QAAS,CACT,gDAaD,CApBA,0OAcE,aAMF,CAGC,yMACC,kDACD,CDpEF",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button::after {\n\tcontent: "";\n\twidth: 0;\n\tposition: absolute;\n\tright: -1px;\n\ttop: var(--ck-spacing-small);\n\tbottom: var(--ck-spacing-small);\n\tz-index: 1;\n}\n\n.ck.ck-responsive-form {\n\t@mixin ck-media-phone {\n\t\t& .ck-button::after {\n\t\t\tcontent: "";\n\t\t\twidth: 0;\n\t\t\tposition: absolute;\n\t\t\tright: -1px;\n\t\t\ttop: var(--ck-spacing-small);\n\t\t\tbottom: var(--ck-spacing-small);\n\t\t\tz-index: 1;\n\t\t}\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n\tborder-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n\tpadding: var(--ck-spacing-standard);\n\n\t&:focus {\n\t\t/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n\t\toutline: none;\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& > :not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& > :not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tpadding: 0;\n\t\twidth: calc(.8 * var(--ck-input-text-width));\n\n\t\t& .ck-labeled-field-view {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-input-text {\n\t\t\t\tmin-width: 0;\n\t\t\t\twidth: 100%;\n\t\t\t}\n\n\t\t\t/* Let the long error messages wrap in the narrow form. */\n\t\t\t& .ck-labeled-field-view__error {\n\t\t\t\twhite-space: normal;\n\t\t\t}\n\t\t}\n\n\t\t/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n\t\t& > .ck-button:nth-last-child(1),\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\tpadding: var(--ck-spacing-standard);\n\t\t\tmargin-top: var(--ck-spacing-standard);\n\n\t\t\tborder-radius: 0;\n\t\t\tborder: 0;\n\t\t\tborder-top: 1px solid var(--ck-color-base-border);\n\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\n\t\t\t\t&:last-of-type {\n\t\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t& > .ck-button:nth-last-child(2) {\n\t\t\t&::after {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n}\n',
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck .ck-balloon-rotator__navigation{display:flex;align-items:center;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);margin-bottom:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-right:var(--ck-spacing-standard);margin-left:var(--ck-spacing-small)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css",
          ],
          names: [],
          mappings:
            "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCACC,oCAAqC,CACrC,kCAAmC,CACnC,qCACD,CAGA,iEACC,uCAAwC,CAGxC,mCACD,CAMA,2DACC,eACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n\tjustify-content: center;\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n\tbackground: var(--ck-color-toolbar-background);\n\tborder-bottom: 1px solid var(--ck-color-toolbar-border);\n\tpadding: 0 var(--ck-spacing-small);\n\n\t/* Let's keep similar appearance to `ck-toolbar`. */\n\t& > * {\n\t\tmargin-right: var(--ck-spacing-small);\n\t\tmargin-top: var(--ck-spacing-small);\n\t\tmargin-bottom: var(--ck-spacing-small);\n\t}\n\n\t/* Gives counter more breath than buttons. */\n\t& .ck-balloon-rotator__counter {\n\t\tmargin-right: var(--ck-spacing-standard);\n\n\t\t/* We need to use smaller margin because of previous button's right margin. */\n\t\tmargin-left: var(--ck-spacing-small);\n\t}\n}\n\n.ck .ck-balloon-rotator__content {\n\n\t/* Disable default annotation shadow inside rotator with fake panels. */\n\t& .ck.ck-annotation-wrapper {\n\t\tbox-shadow: none;\n\t}\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{box-shadow:var(--ck-drop-shadow),0 0;min-height:15px;background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);width:100%;height:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css",
          ],
          names: [],
          mappings:
            "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBCJC,oCAA8B,CDO9B,eAAgB,CAEhB,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CAEtC,UAAW,CACX,WACD,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n\tposition: absolute;\n\n\t/* Fake panels should be placed under main balloon content. */\n\tz-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n\tposition: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tz-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tz-index: 1;\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n\t--ck-balloon-fake-panel-offset-horizontal: 6px;\n\t--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n\t@mixin ck-drop-shadow;\n\n\tmin-height: 15px;\n\n\tbackground: var(--ck-color-panel-background);\n\tborder: 1px solid var(--ck-color-panel-border);\n\tborder-radius: var(--ck-border-radius);\n\n\twidth: 100%;\n\theight: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n\tmargin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n\tmargin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n\tmargin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n\tmargin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n\t--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n\tbox-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n\t@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck-content .image{display:table;clear:both;text-align:center;margin:1em auto}.ck-content .image img{display:block;margin:0 auto;max-width:100%;min-width:50px}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-image/theme/image.css",
          ],
          names: [],
          mappings:
            "AAKA,mBACC,aAAc,CACd,UAAW,CACX,iBAAkB,CAGlB,eAeD,CAbC,uBAEC,aAAc,CAGd,aAAc,CAGd,cAAe,CAGf,cACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .image {\n\tdisplay: table;\n\tclear: both;\n\ttext-align: center;\n\n\t/* Make sure there is some space between the content and the image. Center image by default. */\n\tmargin: 1em auto;\n\n\t& img {\n\t\t/* Prevent unnecessary margins caused by line-height (see #44). */\n\t\tdisplay: block;\n\n\t\t/* Center the image if its width is smaller than the content's width. */\n\t\tmargin: 0 auto;\n\n\t\t/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n\t\tmax-width: 100%;\n\n\t\t/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n\t\tmin-width: 50px;\n\t}\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-editor__editable .image{position:relative}.ck.ck-editor__editable .image .ck-progress-bar{position:absolute;top:0;left:0}.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar{height:2px;width:0;background:var(--ck-color-upload-bar-background);transition:width .1s}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css",
          ],
          names: [],
          mappings:
            "AAKA,+BACC,iBACD,CAGA,gDACC,iBAAkB,CAClB,KAAM,CACN,MACD,CCPC,yCACC,oBACD,CAID,gDACC,UAAW,CACX,OAAQ,CACR,gDAAiD,CACjD,oBACD,CAEA,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable .image {\n\tposition: relative;\n}\n\n/* Upload progress bar. */\n.ck.ck-editor__editable .image .ck-progress-bar {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable .image {\n\t/* Showing animation. */\n\t&.ck-appear {\n\t\tanimation: fadeIn 700ms;\n\t}\n}\n\n/* Upload progress bar. */\n.ck.ck-editor__editable .image .ck-progress-bar {\n\theight: 2px;\n\twidth: 0;\n\tbackground: var(--ck-color-upload-bar-background);\n\ttransition: width 100ms;\n}\n\n@keyframes fadeIn {\n\tfrom { opacity: 0; }\n\tto   { opacity: 1; }\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        '.ck-image-upload-complete-icon{display:block;position:absolute;top:10px;right:10px;border-radius:50%}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20px;--ck-image-upload-icon-width:2px}.ck-image-upload-complete-icon{width:var(--ck-image-upload-icon-size);height:var(--ck-image-upload-icon-size);opacity:0;background:var(--ck-color-image-upload-icon-background);animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;animation-fill-mode:forwards,forwards;animation-duration:.5s,.5s;font-size:var(--ck-image-upload-icon-size);animation-delay:0ms,3s}.ck-image-upload-complete-icon:after{left:25%;top:50%;opacity:0;height:0;width:0;transform:scaleX(-1) rotate(135deg);transform-origin:left top;border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);animation-name:ck-upload-complete-icon-check;animation-duration:.5s;animation-delay:.5s;animation-fill-mode:forwards;box-sizing:border-box}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{opacity:1;width:0;height:0}33%{width:.3em;height:0}to{opacity:1;width:.3em;height:.45em}}',
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css",
          ],
          names: [],
          mappings:
            "AAKA,+BACC,aAAc,CACd,iBAAkB,CAClB,QAAS,CACT,UAAW,CACX,iBAMD,CAJC,qCACC,UAAW,CACX,iBACD,CCVD,MACC,iCAA8C,CAC9C,+CAA4D,CAE5D,gCAAiC,CACjC,gCACD,CAEA,+BACC,sCAAuC,CACvC,uCAAwC,CACxC,SAAU,CACV,uDAAwD,CACxD,wEAA0E,CAC1E,qCAAuC,CACvC,0BAAgC,CAGhC,0CAA2C,CAG3C,sBAyBD,CAtBC,qCAEC,QAAS,CAET,OAAQ,CACR,SAAU,CACV,QAAS,CACT,OAAQ,CAER,mCAAoC,CACpC,yBAA0B,CAC1B,oFAAqF,CACrF,sFAAuF,CAEvF,4CAA6C,CAC7C,sBAAyB,CACzB,mBAAsB,CACtB,4BAA6B,CAG7B,qBACD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GACC,SAAU,CACV,OAAQ,CACR,QACD,CACA,IACC,UAAY,CACZ,QACD,CACA,GACC,SAAU,CACV,UAAY,CACZ,YACD,CACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n\tdisplay: block;\n\tposition: absolute;\n\ttop: 10px;\n\tright: 10px;\n\tborder-radius: 50%;\n\n\t&::after {\n\t\tcontent: "";\n\t\tposition: absolute;\n\t}\n}\n',
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n\t--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n\t--ck-image-upload-icon-size: 20px;\n\t--ck-image-upload-icon-width: 2px;\n}\n\n.ck-image-upload-complete-icon {\n\twidth: var(--ck-image-upload-icon-size);\n\theight: var(--ck-image-upload-icon-size);\n\topacity: 0;\n\tbackground: var(--ck-color-image-upload-icon-background);\n\tanimation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n\tanimation-fill-mode: forwards, forwards;\n\tanimation-duration: 500ms, 500ms;\n\n\t/* To make animation scalable. */\n\tfont-size: var(--ck-image-upload-icon-size);\n\n\t/* Hide completed upload icon after 3 seconds. */\n\tanimation-delay: 0ms, 3000ms;\n\n\t/* This is check icon element made from border-width mixed with animations. */\n\t&::after {\n\t\t/* Because of border transformation we need to "hard code" left position. */\n\t\tleft: 25%;\n\n\t\ttop: 50%;\n\t\topacity: 0;\n\t\theight: 0;\n\t\twidth: 0;\n\n\t\ttransform: scaleX(-1) rotate(135deg);\n\t\ttransform-origin: left top;\n\t\tborder-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\t\tborder-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n\t\tanimation-name: ck-upload-complete-icon-check;\n\t\tanimation-duration: 500ms;\n\t\tanimation-delay: 500ms;\n\t\tanimation-fill-mode: forwards;\n\n\t\t/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n\t\tbox-sizing: border-box;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-show {\n\tfrom {\n\t\topacity: 0;\n\t}\n\n\tto {\n\t\topacity: 1;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n\tfrom {\n\t\topacity: 1;\n\t}\n\n\tto {\n\t\topacity: 0;\n\t}\n}\n\n@keyframes ck-upload-complete-icon-check {\n\t0% {\n\t\topacity: 1;\n\t\twidth: 0;\n\t\theight: 0;\n\t}\n\t33% {\n\t\twidth: 0.3em;\n\t\theight: 0;\n\t}\n\t100% {\n\t\topacity: 1;\n\t\twidth: 0.3em;\n\t\theight: 0.45em;\n\t}\n}\n',
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        '.ck .ck-upload-placeholder-loader{position:absolute;display:flex;align-items:center;justify-content:center;top:0;left:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px}.ck .ck-image-upload-placeholder{width:100%;margin:0}.ck .ck-upload-placeholder-loader{width:100%;height:100%}.ck .ck-upload-placeholder-loader:before{width:var(--ck-upload-placeholder-loader-size);height:var(--ck-upload-placeholder-loader-size);border-radius:50%;border-top:3px solid var(--ck-color-upload-placeholder-loader);border-right:2px solid transparent;animation:ck-upload-placeholder-loader 1s linear infinite}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}',
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css",
          ],
          names: [],
          mappings:
            "AAKA,kCACC,iBAAkB,CAClB,YAAa,CACb,kBAAmB,CACnB,sBAAuB,CACvB,KAAM,CACN,MAMD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCACD,CAEA,iCAEC,UAAW,CACX,QACD,CAEA,kCACC,UAAW,CACX,WAUD,CARC,yCACC,8CAA+C,CAC/C,+CAAgD,CAChD,iBAAkB,CAClB,8DAA+D,CAC/D,kCAAmC,CACnC,yDACD,CAGD,wCACC,GACC,uBACD,CACD",
          sourcesContent: [
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n\tposition: absolute;\n\tdisplay: flex;\n\talign-items: center;\n\tjustify-content: center;\n\ttop: 0;\n\tleft: 0;\n\n\t&::before {\n\t\tcontent: '';\n\t\tposition: relative;\n\t}\n}\n",
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n\t--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n\t--ck-upload-placeholder-loader-size: 32px;\n}\n\n.ck .ck-image-upload-placeholder {\n\t/* We need to control the full width of the SVG gray background. */\n\twidth: 100%;\n\tmargin: 0;\n}\n\n.ck .ck-upload-placeholder-loader {\n\twidth: 100%;\n\theight: 100%;\n\n\t&::before {\n\t\twidth: var(--ck-upload-placeholder-loader-size);\n\t\theight: var(--ck-upload-placeholder-loader-size);\n\t\tborder-radius: 50%;\n\t\tborder-top: 3px solid var(--ck-color-upload-placeholder-loader);\n\t\tborder-right: 2px solid transparent;\n\t\tanimation: ck-upload-placeholder-loader 1s linear infinite;\n\t}\n}\n\n@keyframes ck-upload-placeholder-loader {\n\tto {\n\t\ttransform: rotate( 360deg );\n\t}\n}\n",
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{height:100%;border-right:1px solid var(--ck-color-base-text);margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css",
          ],
          names: [],
          mappings:
            "AAMA,sBACC,mDACD,CAMA,4BACC,8CACD,CAGA,sCACC,WAAY,CACZ,gDAAiD,CACjD,iBAAkB,CAClB,oCACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n\tbackground: var(--ck-color-link-selected-background);\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n\tbackground: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n\theight: 100%;\n\tborder-right: 1px solid var(--ck-color-base-text);\n\tmargin-right: -1px;\n\toutline: solid 1px hsla(0, 0%, 100%, .5);\n}\n',
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block;padding:0;min-width:var(--ck-input-text-width)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical .ck-button{padding:var(--ck-spacing-standard);margin:0;border-radius:0;border:0;border-top:1px solid var(--ck-color-base-border);width:50%}[dir=ltr] .ck.ck-link-form_layout-vertical .ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical .ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin-left:0}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{border:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-link/theme/linkform.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css",
          ],
          names: [],
          mappings:
            "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAAc,CEpBd,SAAU,CACV,oCFoBD,CElBC,wDACC,oFAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CACC,kCAAmC,CACnC,QAAS,CACT,eAAgB,CAChB,QAAS,CACT,gDAAiD,CACjD,SAaD,CAnBA,4GAaE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,aAUD,CARC,wEACC,QAAS,CACT,UAKD,CAHC,8EACC,eACD",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n\tdisplay: flex;\n\n\t& .ck-label {\n\t\tdisplay: none;\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-labeled-field-view {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tdisplay: block;\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n\tpadding: 0;\n\tmin-width: var(--ck-input-text-width);\n\n\t& .ck-labeled-field-view {\n\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) var(--ck-spacing-small);\n\n\t\t& .ck-input-text {\n\t\t\tmin-width: 0;\n\t\t\twidth: 100%;\n\t\t}\n\t}\n\n\t& .ck-button {\n\t\tpadding: var(--ck-spacing-standard);\n\t\tmargin: 0;\n\t\tborder-radius: 0;\n\t\tborder: 0;\n\t\tborder-top: 1px solid var(--ck-color-base-border);\n\t\twidth: 50%;\n\n\t\t@mixin ck-dir ltr {\n\t\t\tmargin-left: 0;\n\t\t}\n\n\t\t@mixin ck-dir rtl {\n\t\t\tmargin-left: 0;\n\n\t\t\t&:last-of-type {\n\t\t\t\tborder-right: 1px solid var(--ck-color-base-border);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n\t& .ck.ck-list {\n\t\tmargin-left: 0;\n\n\t\t& .ck-button.ck-switchbutton {\n\t\t\tborder: 0;\n\t\t\twidth: 100%;\n\n\t\t\t&:hover {\n\t\t\t\tbackground: none;\n\t\t\t}\n\t\t}\n\t}\n}\n',
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e, n) {
      "use strict";
      var o = n(2);
      var i = n.n(o);
      var r = n(3);
      var s = n.n(r);
      var a = s()(i.a);
      a.push([
        t.i,
        ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{padding:0 var(--ck-spacing-medium);color:var(--ck-color-link-default);text-overflow:ellipsis;cursor:pointer;max-width:var(--ck-input-text-width);min-width:3em;text-align:center}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{min-width:0;max-width:100%}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}",
        "",
        {
          version: 3,
          sources: [
            "webpack://node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css",
            "webpack://node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css",
            "webpack://node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css",
          ],
          names: [],
          mappings:
            "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCKA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EACC,kCAAmC,CACnC,kCAAmC,CACnC,sBAAuB,CACvB,cAAe,CAIf,oCAAqC,CACrC,aAAc,CACd,iBAKD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDvDD,oCC2DC,wDACC,8DAMD,CAJC,0EACC,WAAY,CACZ,cACD,CAGD,gJAME,aAEF,CD1ED",
          sourcesContent: [
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\tdisplay: flex;\n\tflex-direction: row;\n\tflex-wrap: nowrap;\n\n\t& .ck-link-actions__preview {\n\t\tdisplay: inline-block;\n\n\t\t& .ck-button__label {\n\t\t\toverflow: hidden;\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\tflex-wrap: wrap;\n\n\t\t& .ck-link-actions__preview {\n\t\t\tflex-basis: 100%;\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\tflex-basis: 50%;\n\t\t}\n\t}\n}\n',
            "/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n\t@media screen and (max-width: 600px) {\n\t\t@mixin-content;\n\t}\n}\n",
            '/*\n * Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/components/tooltip/mixins/_tooltip.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n\t& .ck-button.ck-link-actions__preview {\n\t\tpadding-left: 0;\n\t\tpadding-right: 0;\n\n\t\t& .ck-button__label {\n\t\t\tpadding: 0 var(--ck-spacing-medium);\n\t\t\tcolor: var(--ck-color-link-default);\n\t\t\ttext-overflow: ellipsis;\n\t\t\tcursor: pointer;\n\n\t\t\t/* Match the box model of the link editor form\'s input so the balloon\n\t\t\tdoes not change width when moving between actions and the form. */\n\t\t\tmax-width: var(--ck-input-text-width);\n\t\t\tmin-width: 3em;\n\t\t\ttext-align: center;\n\n\t\t\t&:hover {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\n\t\t&,\n\t\t&:hover,\n\t\t&:focus,\n\t\t&:active {\n\t\t\tbackground: none;\n\t\t}\n\n\t\t&:active {\n\t\t\tbox-shadow: none;\n\t\t}\n\n\t\t&:focus {\n\t\t\t& .ck-button__label {\n\t\t\t\ttext-decoration: underline;\n\t\t\t}\n\t\t}\n\t}\n\n\t@mixin ck-dir ltr {\n\t\t& .ck-button:not(:first-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-dir rtl {\n\t\t& .ck-button:not(:last-child) {\n\t\t\tmargin-left: var(--ck-spacing-standard);\n\t\t}\n\t}\n\n\t@mixin ck-media-phone {\n\t\t& .ck-button.ck-link-actions__preview {\n\t\t\tmargin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;\n\n\t\t\t& .ck-button__label {\n\t\t\t\tmin-width: 0;\n\t\t\t\tmax-width: 100%;\n\t\t\t}\n\t\t}\n\n\t\t& .ck-button:not(.ck-link-actions__preview) {\n\t\t\t@mixin ck-dir ltr {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\n\t\t\t@mixin ck-dir rtl {\n\t\t\t\tmargin-left: 0;\n\t\t\t}\n\t\t}\n\t}\n}\n',
          ],
          sourceRoot: "",
        },
      ]);
      e["a"] = a;
    },
    function (t, e) {
      var n;
      n = (function () {
        return this;
      })();
      try {
        n = n || new Function("return this")();
      } catch (t) {
        if (typeof window === "object") n = window;
      }
      t.exports = n;
    },
    function (t, e, n) {
      "use strict";
      function o() {
        return false;
      }
      e["a"] = o;
    },
    function (t, e, n) {
      "use strict";
      n.r(e);
      var o = n(5);
      var i = o["a"].Symbol;
      var r = i;
      var s = Object.prototype;
      var a = s.hasOwnProperty;
      var c = s.toString;
      var l = r ? r.toStringTag : undefined;
      function d(t) {
        var e = a.call(t, l),
          n = t[l];
        try {
          t[l] = undefined;
          var o = true;
        } catch (t) {}
        var i = c.call(t);
        if (o) {
          if (e) {
            t[l] = n;
          } else {
            delete t[l];
          }
        }
        return i;
      }
      var u = d;
      var h = Object.prototype;
      var f = h.toString;
      function g(t) {
        return f.call(t);
      }
      var p = g;
      var m = "[object Null]",
        k = "[object Undefined]";
      var b = r ? r.toStringTag : undefined;
      function w(t) {
        if (t == null) {
          return t === undefined ? k : m;
        }
        return b && b in Object(t) ? u(t) : p(t);
      }
      var _ = w;
      function A(t, e) {
        return function (n) {
          return t(e(n));
        };
      }
      var C = A;
      var v = C(Object.getPrototypeOf, Object);
      var y = v;
      function x(t) {
        return t != null && typeof t == "object";
      }
      var E = x;
      var S = "[object Object]";
      var P = Function.prototype,
        D = Object.prototype;
      var T = P.toString;
      var B = D.hasOwnProperty;
      var I = T.call(Object);
      function O(t) {
        if (!E(t) || _(t) != S) {
          return false;
        }
        var e = y(t);
        if (e === null) {
          return true;
        }
        var n = B.call(e, "constructor") && e.constructor;
        return typeof n == "function" && n instanceof n && T.call(n) == I;
      }
      var R = O;
      function F() {
        this.__data__ = [];
        this.size = 0;
      }
      var N = F;
      function M(t, e) {
        return t === e || (t !== t && e !== e);
      }
      var V = M;
      function L(t, e) {
        var n = t.length;
        while (n--) {
          if (V(t[n][0], e)) {
            return n;
          }
        }
        return -1;
      }
      var z = L;
      var j = Array.prototype;
      var K = j.splice;
      function q(t) {
        var e = this.__data__,
          n = z(e, t);
        if (n < 0) {
          return false;
        }
        var o = e.length - 1;
        if (n == o) {
          e.pop();
        } else {
          K.call(e, n, 1);
        }
        --this.size;
        return true;
      }
      var $ = q;
      function W(t) {
        var e = this.__data__,
          n = z(e, t);
        return n < 0 ? undefined : e[n][1];
      }
      var G = W;
      function U(t) {
        return z(this.__data__, t) > -1;
      }
      var H = U;
      function J(t, e) {
        var n = this.__data__,
          o = z(n, t);
        if (o < 0) {
          ++this.size;
          n.push([t, e]);
        } else {
          n[o][1] = e;
        }
        return this;
      }
      var Y = J;
      function Q(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var o = t[e];
          this.set(o[0], o[1]);
        }
      }
      Q.prototype.clear = N;
      Q.prototype["delete"] = $;
      Q.prototype.get = G;
      Q.prototype.has = H;
      Q.prototype.set = Y;
      var X = Q;
      function Z() {
        this.__data__ = new X();
        this.size = 0;
      }
      var tt = Z;
      function et(t) {
        var e = this.__data__,
          n = e["delete"](t);
        this.size = e.size;
        return n;
      }
      var nt = et;
      function ot(t) {
        return this.__data__.get(t);
      }
      var it = ot;
      function rt(t) {
        return this.__data__.has(t);
      }
      var st = rt;
      function at(t) {
        var e = typeof t;
        return t != null && (e == "object" || e == "function");
      }
      var ct = at;
      var lt = "[object AsyncFunction]",
        dt = "[object Function]",
        ut = "[object GeneratorFunction]",
        ht = "[object Proxy]";
      function ft(t) {
        if (!ct(t)) {
          return false;
        }
        var e = _(t);
        return e == dt || e == ut || e == lt || e == ht;
      }
      var gt = ft;
      var pt = o["a"]["__core-js_shared__"];
      var mt = pt;
      var kt = (function () {
        var t = /[^.]+$/.exec((mt && mt.keys && mt.keys.IE_PROTO) || "");
        return t ? "Symbol(src)_1." + t : "";
      })();
      function bt(t) {
        return !!kt && kt in t;
      }
      var wt = bt;
      var _t = Function.prototype;
      var At = _t.toString;
      function Ct(t) {
        if (t != null) {
          try {
            return At.call(t);
          } catch (t) {}
          try {
            return t + "";
          } catch (t) {}
        }
        return "";
      }
      var vt = Ct;
      var yt = /[\\^$.*+?()[\]{}|]/g;
      var xt = /^\[object .+?Constructor\]$/;
      var Et = Function.prototype,
        St = Object.prototype;
      var Pt = Et.toString;
      var Dt = St.hasOwnProperty;
      var Tt = RegExp(
        "^" +
          Pt.call(Dt)
            .replace(yt, "\\$&")
            .replace(
              /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
              "$1.*?"
            ) +
          "$"
      );
      function Bt(t) {
        if (!ct(t) || wt(t)) {
          return false;
        }
        var e = gt(t) ? Tt : xt;
        return e.test(vt(t));
      }
      var It = Bt;
      function Ot(t, e) {
        return t == null ? undefined : t[e];
      }
      var Rt = Ot;
      function Ft(t, e) {
        var n = Rt(t, e);
        return It(n) ? n : undefined;
      }
      var Nt = Ft;
      var Mt = Nt(o["a"], "Map");
      var Vt = Mt;
      var Lt = Nt(Object, "create");
      var zt = Lt;
      function jt() {
        this.__data__ = zt ? zt(null) : {};
        this.size = 0;
      }
      var Kt = jt;
      function qt(t) {
        var e = this.has(t) && delete this.__data__[t];
        this.size -= e ? 1 : 0;
        return e;
      }
      var $t = qt;
      var Wt = "__lodash_hash_undefined__";
      var Gt = Object.prototype;
      var Ut = Gt.hasOwnProperty;
      function Ht(t) {
        var e = this.__data__;
        if (zt) {
          var n = e[t];
          return n === Wt ? undefined : n;
        }
        return Ut.call(e, t) ? e[t] : undefined;
      }
      var Jt = Ht;
      var Yt = Object.prototype;
      var Qt = Yt.hasOwnProperty;
      function Xt(t) {
        var e = this.__data__;
        return zt ? e[t] !== undefined : Qt.call(e, t);
      }
      var Zt = Xt;
      var te = "__lodash_hash_undefined__";
      function ee(t, e) {
        var n = this.__data__;
        this.size += this.has(t) ? 0 : 1;
        n[t] = zt && e === undefined ? te : e;
        return this;
      }
      var ne = ee;
      function oe(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var o = t[e];
          this.set(o[0], o[1]);
        }
      }
      oe.prototype.clear = Kt;
      oe.prototype["delete"] = $t;
      oe.prototype.get = Jt;
      oe.prototype.has = Zt;
      oe.prototype.set = ne;
      var ie = oe;
      function re() {
        this.size = 0;
        this.__data__ = {
          hash: new ie(),
          map: new (Vt || X)(),
          string: new ie(),
        };
      }
      var se = re;
      function ae(t) {
        var e = typeof t;
        return e == "string" || e == "number" || e == "symbol" || e == "boolean"
          ? t !== "__proto__"
          : t === null;
      }
      var ce = ae;
      function le(t, e) {
        var n = t.__data__;
        return ce(e) ? n[typeof e == "string" ? "string" : "hash"] : n.map;
      }
      var de = le;
      function ue(t) {
        var e = de(this, t)["delete"](t);
        this.size -= e ? 1 : 0;
        return e;
      }
      var he = ue;
      function fe(t) {
        return de(this, t).get(t);
      }
      var ge = fe;
      function pe(t) {
        return de(this, t).has(t);
      }
      var me = pe;
      function ke(t, e) {
        var n = de(this, t),
          o = n.size;
        n.set(t, e);
        this.size += n.size == o ? 0 : 1;
        return this;
      }
      var be = ke;
      function we(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.clear();
        while (++e < n) {
          var o = t[e];
          this.set(o[0], o[1]);
        }
      }
      we.prototype.clear = se;
      we.prototype["delete"] = he;
      we.prototype.get = ge;
      we.prototype.has = me;
      we.prototype.set = be;
      var _e = we;
      var Ae = 200;
      function Ce(t, e) {
        var n = this.__data__;
        if (n instanceof X) {
          var o = n.__data__;
          if (!Vt || o.length < Ae - 1) {
            o.push([t, e]);
            this.size = ++n.size;
            return this;
          }
          n = this.__data__ = new _e(o);
        }
        n.set(t, e);
        this.size = n.size;
        return this;
      }
      var ve = Ce;
      function ye(t) {
        var e = (this.__data__ = new X(t));
        this.size = e.size;
      }
      ye.prototype.clear = tt;
      ye.prototype["delete"] = nt;
      ye.prototype.get = it;
      ye.prototype.has = st;
      ye.prototype.set = ve;
      var xe = ye;
      function Ee(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length;
        while (++n < o) {
          if (e(t[n], n, t) === false) {
            break;
          }
        }
        return t;
      }
      var Se = Ee;
      var Pe = (function () {
        try {
          var t = Nt(Object, "defineProperty");
          t({}, "", {});
          return t;
        } catch (t) {}
      })();
      var De = Pe;
      function Te(t, e, n) {
        if (e == "__proto__" && De) {
          De(t, e, {
            configurable: true,
            enumerable: true,
            value: n,
            writable: true,
          });
        } else {
          t[e] = n;
        }
      }
      var Be = Te;
      var Ie = Object.prototype;
      var Oe = Ie.hasOwnProperty;
      function Re(t, e, n) {
        var o = t[e];
        if (!(Oe.call(t, e) && V(o, n)) || (n === undefined && !(e in t))) {
          Be(t, e, n);
        }
      }
      var Fe = Re;
      function Ne(t, e, n, o) {
        var i = !n;
        n || (n = {});
        var r = -1,
          s = e.length;
        while (++r < s) {
          var a = e[r];
          var c = o ? o(n[a], t[a], a, n, t) : undefined;
          if (c === undefined) {
            c = t[a];
          }
          if (i) {
            Be(n, a, c);
          } else {
            Fe(n, a, c);
          }
        }
        return n;
      }
      var Me = Ne;
      function Ve(t, e) {
        var n = -1,
          o = Array(t);
        while (++n < t) {
          o[n] = e(n);
        }
        return o;
      }
      var Le = Ve;
      var ze = "[object Arguments]";
      function je(t) {
        return E(t) && _(t) == ze;
      }
      var Ke = je;
      var qe = Object.prototype;
      var $e = qe.hasOwnProperty;
      var We = qe.propertyIsEnumerable;
      var Ge = Ke(
        (function () {
          return arguments;
        })()
      )
        ? Ke
        : function (t) {
            return E(t) && $e.call(t, "callee") && !We.call(t, "callee");
          };
      var Ue = Ge;
      var He = Array.isArray;
      var Je = He;
      var Ye = n(6);
      var Qe = 9007199254740991;
      var Xe = /^(?:0|[1-9]\d*)$/;
      function Ze(t, e) {
        var n = typeof t;
        e = e == null ? Qe : e;
        return (
          !!e &&
          (n == "number" || (n != "symbol" && Xe.test(t))) &&
          t > -1 &&
          t % 1 == 0 &&
          t < e
        );
      }
      var tn = Ze;
      var en = 9007199254740991;
      function nn(t) {
        return typeof t == "number" && t > -1 && t % 1 == 0 && t <= en;
      }
      var on = nn;
      var rn = "[object Arguments]",
        sn = "[object Array]",
        an = "[object Boolean]",
        cn = "[object Date]",
        ln = "[object Error]",
        dn = "[object Function]",
        un = "[object Map]",
        hn = "[object Number]",
        fn = "[object Object]",
        gn = "[object RegExp]",
        pn = "[object Set]",
        mn = "[object String]",
        kn = "[object WeakMap]";
      var bn = "[object ArrayBuffer]",
        wn = "[object DataView]",
        _n = "[object Float32Array]",
        An = "[object Float64Array]",
        Cn = "[object Int8Array]",
        vn = "[object Int16Array]",
        yn = "[object Int32Array]",
        xn = "[object Uint8Array]",
        En = "[object Uint8ClampedArray]",
        Sn = "[object Uint16Array]",
        Pn = "[object Uint32Array]";
      var Dn = {};
      Dn[_n] = Dn[An] = Dn[Cn] = Dn[vn] = Dn[yn] = Dn[xn] = Dn[En] = Dn[
        Sn
      ] = Dn[Pn] = true;
      Dn[rn] = Dn[sn] = Dn[bn] = Dn[an] = Dn[wn] = Dn[cn] = Dn[ln] = Dn[
        dn
      ] = Dn[un] = Dn[hn] = Dn[fn] = Dn[gn] = Dn[pn] = Dn[mn] = Dn[kn] = false;
      function Tn(t) {
        return E(t) && on(t.length) && !!Dn[_(t)];
      }
      var Bn = Tn;
      function In(t) {
        return function (e) {
          return t(e);
        };
      }
      var On = In;
      var Rn = n(7);
      var Fn = Rn["a"] && Rn["a"].isTypedArray;
      var Nn = Fn ? On(Fn) : Bn;
      var Mn = Nn;
      var Vn = Object.prototype;
      var Ln = Vn.hasOwnProperty;
      function zn(t, e) {
        var n = Je(t),
          o = !n && Ue(t),
          i = !n && !o && Object(Ye["a"])(t),
          r = !n && !o && !i && Mn(t),
          s = n || o || i || r,
          a = s ? Le(t.length, String) : [],
          c = a.length;
        for (var l in t) {
          if (
            (e || Ln.call(t, l)) &&
            !(
              s &&
              (l == "length" ||
                (i && (l == "offset" || l == "parent")) ||
                (r &&
                  (l == "buffer" || l == "byteLength" || l == "byteOffset")) ||
                tn(l, c))
            )
          ) {
            a.push(l);
          }
        }
        return a;
      }
      var jn = zn;
      var Kn = Object.prototype;
      function qn(t) {
        var e = t && t.constructor,
          n = (typeof e == "function" && e.prototype) || Kn;
        return t === n;
      }
      var $n = qn;
      var Wn = C(Object.keys, Object);
      var Gn = Wn;
      var Un = Object.prototype;
      var Hn = Un.hasOwnProperty;
      function Jn(t) {
        if (!$n(t)) {
          return Gn(t);
        }
        var e = [];
        for (var n in Object(t)) {
          if (Hn.call(t, n) && n != "constructor") {
            e.push(n);
          }
        }
        return e;
      }
      var Yn = Jn;
      function Qn(t) {
        return t != null && on(t.length) && !gt(t);
      }
      var Xn = Qn;
      function Zn(t) {
        return Xn(t) ? jn(t) : Yn(t);
      }
      var to = Zn;
      function eo(t, e) {
        return t && Me(e, to(e), t);
      }
      var no = eo;
      function oo(t) {
        var e = [];
        if (t != null) {
          for (var n in Object(t)) {
            e.push(n);
          }
        }
        return e;
      }
      var io = oo;
      var ro = Object.prototype;
      var so = ro.hasOwnProperty;
      function ao(t) {
        if (!ct(t)) {
          return io(t);
        }
        var e = $n(t),
          n = [];
        for (var o in t) {
          if (!(o == "constructor" && (e || !so.call(t, o)))) {
            n.push(o);
          }
        }
        return n;
      }
      var co = ao;
      function lo(t) {
        return Xn(t) ? jn(t, true) : co(t);
      }
      var uo = lo;
      function ho(t, e) {
        return t && Me(e, uo(e), t);
      }
      var fo = ho;
      var go = n(10);
      function po(t, e) {
        var n = -1,
          o = t.length;
        e || (e = Array(o));
        while (++n < o) {
          e[n] = t[n];
        }
        return e;
      }
      var mo = po;
      function ko(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length,
          i = 0,
          r = [];
        while (++n < o) {
          var s = t[n];
          if (e(s, n, t)) {
            r[i++] = s;
          }
        }
        return r;
      }
      var bo = ko;
      function wo() {
        return [];
      }
      var _o = wo;
      var Ao = Object.prototype;
      var Co = Ao.propertyIsEnumerable;
      var vo = Object.getOwnPropertySymbols;
      var yo = !vo
        ? _o
        : function (t) {
            if (t == null) {
              return [];
            }
            t = Object(t);
            return bo(vo(t), function (e) {
              return Co.call(t, e);
            });
          };
      var xo = yo;
      function Eo(t, e) {
        return Me(t, xo(t), e);
      }
      var So = Eo;
      function Po(t, e) {
        var n = -1,
          o = e.length,
          i = t.length;
        while (++n < o) {
          t[i + n] = e[n];
        }
        return t;
      }
      var Do = Po;
      var To = Object.getOwnPropertySymbols;
      var Bo = !To
        ? _o
        : function (t) {
            var e = [];
            while (t) {
              Do(e, xo(t));
              t = y(t);
            }
            return e;
          };
      var Io = Bo;
      function Oo(t, e) {
        return Me(t, Io(t), e);
      }
      var Ro = Oo;
      function Fo(t, e, n) {
        var o = e(t);
        return Je(t) ? o : Do(o, n(t));
      }
      var No = Fo;
      function Mo(t) {
        return No(t, to, xo);
      }
      var Vo = Mo;
      function Lo(t) {
        return No(t, uo, Io);
      }
      var zo = Lo;
      var jo = Nt(o["a"], "DataView");
      var Ko = jo;
      var qo = Nt(o["a"], "Promise");
      var $o = qo;
      var Wo = Nt(o["a"], "Set");
      var Go = Wo;
      var Uo = Nt(o["a"], "WeakMap");
      var Ho = Uo;
      var Jo = "[object Map]",
        Yo = "[object Object]",
        Qo = "[object Promise]",
        Xo = "[object Set]",
        Zo = "[object WeakMap]";
      var ti = "[object DataView]";
      var ei = vt(Ko),
        ni = vt(Vt),
        oi = vt($o),
        ii = vt(Go),
        ri = vt(Ho);
      var si = _;
      if (
        (Ko && si(new Ko(new ArrayBuffer(1))) != ti) ||
        (Vt && si(new Vt()) != Jo) ||
        ($o && si($o.resolve()) != Qo) ||
        (Go && si(new Go()) != Xo) ||
        (Ho && si(new Ho()) != Zo)
      ) {
        si = function (t) {
          var e = _(t),
            n = e == Yo ? t.constructor : undefined,
            o = n ? vt(n) : "";
          if (o) {
            switch (o) {
              case ei:
                return ti;
              case ni:
                return Jo;
              case oi:
                return Qo;
              case ii:
                return Xo;
              case ri:
                return Zo;
            }
          }
          return e;
        };
      }
      var ai = si;
      var ci = Object.prototype;
      var li = ci.hasOwnProperty;
      function di(t) {
        var e = t.length,
          n = new t.constructor(e);
        if (e && typeof t[0] == "string" && li.call(t, "index")) {
          n.index = t.index;
          n.input = t.input;
        }
        return n;
      }
      var ui = di;
      var hi = o["a"].Uint8Array;
      var fi = hi;
      function gi(t) {
        var e = new t.constructor(t.byteLength);
        new fi(e).set(new fi(t));
        return e;
      }
      var pi = gi;
      function mi(t, e) {
        var n = e ? pi(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.byteLength);
      }
      var ki = mi;
      var bi = /\w*$/;
      function wi(t) {
        var e = new t.constructor(t.source, bi.exec(t));
        e.lastIndex = t.lastIndex;
        return e;
      }
      var _i = wi;
      var Ai = r ? r.prototype : undefined,
        Ci = Ai ? Ai.valueOf : undefined;
      function vi(t) {
        return Ci ? Object(Ci.call(t)) : {};
      }
      var yi = vi;
      function xi(t, e) {
        var n = e ? pi(t.buffer) : t.buffer;
        return new t.constructor(n, t.byteOffset, t.length);
      }
      var Ei = xi;
      var Si = "[object Boolean]",
        Pi = "[object Date]",
        Di = "[object Map]",
        Ti = "[object Number]",
        Bi = "[object RegExp]",
        Ii = "[object Set]",
        Oi = "[object String]",
        Ri = "[object Symbol]";
      var Fi = "[object ArrayBuffer]",
        Ni = "[object DataView]",
        Mi = "[object Float32Array]",
        Vi = "[object Float64Array]",
        Li = "[object Int8Array]",
        zi = "[object Int16Array]",
        ji = "[object Int32Array]",
        Ki = "[object Uint8Array]",
        qi = "[object Uint8ClampedArray]",
        $i = "[object Uint16Array]",
        Wi = "[object Uint32Array]";
      function Gi(t, e, n) {
        var o = t.constructor;
        switch (e) {
          case Fi:
            return pi(t);
          case Si:
          case Pi:
            return new o(+t);
          case Ni:
            return ki(t, n);
          case Mi:
          case Vi:
          case Li:
          case zi:
          case ji:
          case Ki:
          case qi:
          case $i:
          case Wi:
            return Ei(t, n);
          case Di:
            return new o();
          case Ti:
          case Oi:
            return new o(t);
          case Bi:
            return _i(t);
          case Ii:
            return new o();
          case Ri:
            return yi(t);
        }
      }
      var Ui = Gi;
      var Hi = Object.create;
      var Ji = (function () {
        function t() {}
        return function (e) {
          if (!ct(e)) {
            return {};
          }
          if (Hi) {
            return Hi(e);
          }
          t.prototype = e;
          var n = new t();
          t.prototype = undefined;
          return n;
        };
      })();
      var Yi = Ji;
      function Qi(t) {
        return typeof t.constructor == "function" && !$n(t) ? Yi(y(t)) : {};
      }
      var Xi = Qi;
      var Zi = "[object Map]";
      function tr(t) {
        return E(t) && ai(t) == Zi;
      }
      var er = tr;
      var nr = Rn["a"] && Rn["a"].isMap;
      var or = nr ? On(nr) : er;
      var ir = or;
      var rr = "[object Set]";
      function sr(t) {
        return E(t) && ai(t) == rr;
      }
      var ar = sr;
      var cr = Rn["a"] && Rn["a"].isSet;
      var lr = cr ? On(cr) : ar;
      var dr = lr;
      var ur = 1,
        hr = 2,
        fr = 4;
      var gr = "[object Arguments]",
        pr = "[object Array]",
        mr = "[object Boolean]",
        kr = "[object Date]",
        br = "[object Error]",
        wr = "[object Function]",
        _r = "[object GeneratorFunction]",
        Ar = "[object Map]",
        Cr = "[object Number]",
        vr = "[object Object]",
        yr = "[object RegExp]",
        xr = "[object Set]",
        Er = "[object String]",
        Sr = "[object Symbol]",
        Pr = "[object WeakMap]";
      var Dr = "[object ArrayBuffer]",
        Tr = "[object DataView]",
        Br = "[object Float32Array]",
        Ir = "[object Float64Array]",
        Or = "[object Int8Array]",
        Rr = "[object Int16Array]",
        Fr = "[object Int32Array]",
        Nr = "[object Uint8Array]",
        Mr = "[object Uint8ClampedArray]",
        Vr = "[object Uint16Array]",
        Lr = "[object Uint32Array]";
      var zr = {};
      zr[gr] = zr[pr] = zr[Dr] = zr[Tr] = zr[mr] = zr[kr] = zr[Br] = zr[
        Ir
      ] = zr[Or] = zr[Rr] = zr[Fr] = zr[Ar] = zr[Cr] = zr[vr] = zr[yr] = zr[
        xr
      ] = zr[Er] = zr[Sr] = zr[Nr] = zr[Mr] = zr[Vr] = zr[Lr] = true;
      zr[br] = zr[wr] = zr[Pr] = false;
      function jr(t, e, n, o, i, r) {
        var s,
          a = e & ur,
          c = e & hr,
          l = e & fr;
        if (n) {
          s = i ? n(t, o, i, r) : n(t);
        }
        if (s !== undefined) {
          return s;
        }
        if (!ct(t)) {
          return t;
        }
        var d = Je(t);
        if (d) {
          s = ui(t);
          if (!a) {
            return mo(t, s);
          }
        } else {
          var u = ai(t),
            h = u == wr || u == _r;
          if (Object(Ye["a"])(t)) {
            return Object(go["a"])(t, a);
          }
          if (u == vr || u == gr || (h && !i)) {
            s = c || h ? {} : Xi(t);
            if (!a) {
              return c ? Ro(t, fo(s, t)) : So(t, no(s, t));
            }
          } else {
            if (!zr[u]) {
              return i ? t : {};
            }
            s = Ui(t, u, a);
          }
        }
        r || (r = new xe());
        var f = r.get(t);
        if (f) {
          return f;
        }
        r.set(t, s);
        if (dr(t)) {
          t.forEach(function (o) {
            s.add(jr(o, e, n, o, t, r));
          });
        } else if (ir(t)) {
          t.forEach(function (o, i) {
            s.set(i, jr(o, e, n, i, t, r));
          });
        }
        var g = l ? (c ? zo : Vo) : c ? keysIn : to;
        var p = d ? undefined : g(t);
        Se(p || t, function (o, i) {
          if (p) {
            i = o;
            o = t[i];
          }
          Fe(s, i, jr(o, e, n, i, t, r));
        });
        return s;
      }
      var Kr = jr;
      var qr = 1,
        $r = 4;
      function Wr(t, e) {
        e = typeof e == "function" ? e : undefined;
        return Kr(t, qr | $r, e);
      }
      var Gr = Wr;
      function Ur(t) {
        return E(t) && t.nodeType === 1 && !R(t);
      }
      var Hr = Ur;
      class Jr {
        constructor(t, e) {
          this._config = {};
          if (e) {
            this.define(Yr(e));
          }
          if (t) {
            this._setObjectToTarget(this._config, t);
          }
        }
        set(t, e) {
          this._setToTarget(this._config, t, e);
        }
        define(t, e) {
          const n = true;
          this._setToTarget(this._config, t, e, n);
        }
        get(t) {
          return this._getFromSource(this._config, t);
        }
        *names() {
          for (const t of Object.keys(this._config)) {
            yield t;
          }
        }
        _setToTarget(t, e, n, o = false) {
          if (R(e)) {
            this._setObjectToTarget(t, e, o);
            return;
          }
          const i = e.split(".");
          e = i.pop();
          for (const e of i) {
            if (!R(t[e])) {
              t[e] = {};
            }
            t = t[e];
          }
          if (R(n)) {
            if (!R(t[e])) {
              t[e] = {};
            }
            t = t[e];
            this._setObjectToTarget(t, n, o);
            return;
          }
          if (o && typeof t[e] != "undefined") {
            return;
          }
          t[e] = n;
        }
        _getFromSource(t, e) {
          const n = e.split(".");
          e = n.pop();
          for (const e of n) {
            if (!R(t[e])) {
              t = null;
              break;
            }
            t = t[e];
          }
          return t ? Yr(t[e]) : undefined;
        }
        _setObjectToTarget(t, e, n) {
          Object.keys(e).forEach((o) => {
            this._setToTarget(t, o, e[o], n);
          });
        }
      }
      function Yr(t) {
        return Gr(t, Qr);
      }
      function Qr(t) {
        return Hr(t) ? t : undefined;
      }
      function Xr() {
        return function t() {
          t.called = true;
        };
      }
      var Zr = Xr;
      class ts {
        constructor(t, e) {
          this.source = t;
          this.name = e;
          this.path = [];
          this.stop = Zr();
          this.off = Zr();
        }
      }
      const es = new Array(256)
        .fill()
        .map((t, e) => ("0" + e.toString(16)).slice(-2));
      function ns() {
        const t = (Math.random() * 4294967296) >>> 0;
        const e = (Math.random() * 4294967296) >>> 0;
        const n = (Math.random() * 4294967296) >>> 0;
        const o = (Math.random() * 4294967296) >>> 0;
        return (
          "e" +
          es[(t >> 0) & 255] +
          es[(t >> 8) & 255] +
          es[(t >> 16) & 255] +
          es[(t >> 24) & 255] +
          es[(e >> 0) & 255] +
          es[(e >> 8) & 255] +
          es[(e >> 16) & 255] +
          es[(e >> 24) & 255] +
          es[(n >> 0) & 255] +
          es[(n >> 8) & 255] +
          es[(n >> 16) & 255] +
          es[(n >> 24) & 255] +
          es[(o >> 0) & 255] +
          es[(o >> 8) & 255] +
          es[(o >> 16) & 255] +
          es[(o >> 24) & 255]
        );
      }
      const os = {
        get(t) {
          if (typeof t != "number") {
            return this[t] || this.normal;
          } else {
            return t;
          }
        },
        highest: 1e5,
        high: 1e3,
        normal: 0,
        low: -1e3,
        lowest: -1e5,
      };
      var is = os;
      var rs = n(8);
      var ss = n(0);
      const as = Symbol("listeningTo");
      const cs = Symbol("emitterId");
      const ls = {
        on(t, e, n = {}) {
          this.listenTo(this, t, e, n);
        },
        once(t, e, n) {
          let o = false;
          const i = function (t, ...n) {
            if (!o) {
              o = true;
              t.off();
              e.call(this, t, ...n);
            }
          };
          this.listenTo(this, t, i, n);
        },
        off(t, e) {
          this.stopListening(this, t, e);
        },
        listenTo(t, e, n, o = {}) {
          let i, r;
          if (!this[as]) {
            this[as] = {};
          }
          const s = this[as];
          if (!fs(t)) {
            hs(t);
          }
          const a = fs(t);
          if (!(i = s[a])) {
            i = s[a] = { emitter: t, callbacks: {} };
          }
          if (!(r = i.callbacks[e])) {
            r = i.callbacks[e] = [];
          }
          r.push(n);
          ms(t, e);
          const c = ks(t, e);
          const l = is.get(o.priority);
          const d = { callback: n, priority: l };
          for (const t of c) {
            let e = false;
            for (let n = 0; n < t.length; n++) {
              if (t[n].priority < l) {
                t.splice(n, 0, d);
                e = true;
                break;
              }
            }
            if (!e) {
              t.push(d);
            }
          }
        },
        stopListening(t, e, n) {
          const o = this[as];
          let i = t && fs(t);
          const r = o && i && o[i];
          const s = r && e && r.callbacks[e];
          if (!o || (t && !r) || (e && !s)) {
            return;
          }
          if (n) {
            _s(t, e, n);
          } else if (s) {
            while ((n = s.pop())) {
              _s(t, e, n);
            }
            delete r.callbacks[e];
          } else if (r) {
            for (e in r.callbacks) {
              this.stopListening(t, e);
            }
            delete o[i];
          } else {
            for (i in o) {
              this.stopListening(o[i].emitter);
            }
            delete this[as];
          }
        },
        fire(t, ...e) {
          try {
            const n = t instanceof ts ? t : new ts(this, t);
            const o = n.name;
            let i = bs(this, o);
            n.path.push(this);
            if (i) {
              const t = [n, ...e];
              i = Array.from(i);
              for (let e = 0; e < i.length; e++) {
                i[e].callback.apply(this, t);
                if (n.off.called) {
                  delete n.off.called;
                  _s(this, o, i[e].callback);
                }
                if (n.stop.called) {
                  break;
                }
              }
            }
            if (this._delegations) {
              const t = this._delegations.get(o);
              const i = this._delegations.get("*");
              if (t) {
                ws(t, n, e);
              }
              if (i) {
                ws(i, n, e);
              }
            }
            return n.return;
          } catch (t) {
            ss["a"].rethrowUnexpectedError(t, this);
          }
        },
        delegate(...t) {
          return {
            to: (e, n) => {
              if (!this._delegations) {
                this._delegations = new Map();
              }
              t.forEach((t) => {
                const o = this._delegations.get(t);
                if (!o) {
                  this._delegations.set(t, new Map([[e, n]]));
                } else {
                  o.set(e, n);
                }
              });
            },
          };
        },
        stopDelegating(t, e) {
          if (!this._delegations) {
            return;
          }
          if (!t) {
            this._delegations.clear();
          } else if (!e) {
            this._delegations.delete(t);
          } else {
            const n = this._delegations.get(t);
            if (n) {
              n.delete(e);
            }
          }
        },
      };
      var ds = ls;
      function us(t, e) {
        if (t[as] && t[as][e]) {
          return t[as][e].emitter;
        }
        return null;
      }
      function hs(t, e) {
        if (!t[cs]) {
          t[cs] = e || ns();
        }
      }
      function fs(t) {
        return t[cs];
      }
      function gs(t) {
        if (!t._events) {
          Object.defineProperty(t, "_events", { value: {} });
        }
        return t._events;
      }
      function ps() {
        return { callbacks: [], childEvents: [] };
      }
      function ms(t, e) {
        const n = gs(t);
        if (n[e]) {
          return;
        }
        let o = e;
        let i = null;
        const r = [];
        while (o !== "") {
          if (n[o]) {
            break;
          }
          n[o] = ps();
          r.push(n[o]);
          if (i) {
            n[o].childEvents.push(i);
          }
          i = o;
          o = o.substr(0, o.lastIndexOf(":"));
        }
        if (o !== "") {
          for (const t of r) {
            t.callbacks = n[o].callbacks.slice();
          }
          n[o].childEvents.push(i);
        }
      }
      function ks(t, e) {
        const n = gs(t)[e];
        if (!n) {
          return [];
        }
        let o = [n.callbacks];
        for (let e = 0; e < n.childEvents.length; e++) {
          const i = ks(t, n.childEvents[e]);
          o = o.concat(i);
        }
        return o;
      }
      function bs(t, e) {
        let n;
        if (!t._events || !(n = t._events[e]) || !n.callbacks.length) {
          if (e.indexOf(":") > -1) {
            return bs(t, e.substr(0, e.lastIndexOf(":")));
          } else {
            return null;
          }
        }
        return n.callbacks;
      }
      function ws(t, e, n) {
        for (let [o, i] of t) {
          if (!i) {
            i = e.name;
          } else if (typeof i == "function") {
            i = i(e.name);
          }
          const t = new ts(e.source, i);
          t.path = [...e.path];
          o.fire(t, ...n);
        }
      }
      function _s(t, e, n) {
        const o = ks(t, e);
        for (const t of o) {
          for (let e = 0; e < t.length; e++) {
            if (t[e].callback == n) {
              t.splice(e, 1);
              e--;
            }
          }
        }
      }
      function As(t) {
        return !!(t && t[Symbol.iterator]);
      }
      function Cs(t, ...e) {
        e.forEach((e) => {
          Object.getOwnPropertyNames(e)
            .concat(Object.getOwnPropertySymbols(e))
            .forEach((n) => {
              if (n in t.prototype) {
                return;
              }
              const o = Object.getOwnPropertyDescriptor(e, n);
              o.enumerable = false;
              Object.defineProperty(t.prototype, n, o);
            });
        });
      }
      class vs {
        constructor(t = {}, e = {}) {
          const n = As(t);
          if (!n) {
            e = t;
          }
          this._items = [];
          this._itemMap = new Map();
          this._idProperty = e.idProperty || "id";
          this._bindToExternalToInternalMap = new WeakMap();
          this._bindToInternalToExternalMap = new WeakMap();
          this._skippedIndexesFromExternal = [];
          if (n) {
            for (const e of t) {
              this._items.push(e);
              this._itemMap.set(this._getItemIdBeforeAdding(e), e);
            }
          }
        }
        get length() {
          return this._items.length;
        }
        get first() {
          return this._items[0] || null;
        }
        get last() {
          return this._items[this.length - 1] || null;
        }
        add(t, e) {
          return this.addMany([t], e);
        }
        addMany(t, e) {
          if (e === undefined) {
            e = this._items.length;
          } else if (e > this._items.length || e < 0) {
            throw new ss["a"]("collection-add-item-invalid-index", this);
          }
          for (let n = 0; n < t.length; n++) {
            const o = t[n];
            const i = this._getItemIdBeforeAdding(o);
            const r = e + n;
            this._items.splice(r, 0, o);
            this._itemMap.set(i, o);
            this.fire("add", o, r);
          }
          this.fire("change", { added: t, removed: [], index: e });
          return this;
        }
        get(t) {
          let e;
          if (typeof t == "string") {
            e = this._itemMap.get(t);
          } else if (typeof t == "number") {
            e = this._items[t];
          } else {
            throw new ss["a"]("collection-get-invalid-arg", this);
          }
          return e || null;
        }
        has(t) {
          if (typeof t == "string") {
            return this._itemMap.has(t);
          } else {
            const e = this._idProperty;
            const n = t[e];
            return this._itemMap.has(n);
          }
        }
        getIndex(t) {
          let e;
          if (typeof t == "string") {
            e = this._itemMap.get(t);
          } else {
            e = t;
          }
          return this._items.indexOf(e);
        }
        remove(t) {
          const [e, n] = this._remove(t);
          this.fire("change", { added: [], removed: [e], index: n });
          return e;
        }
        map(t, e) {
          return this._items.map(t, e);
        }
        find(t, e) {
          return this._items.find(t, e);
        }
        filter(t, e) {
          return this._items.filter(t, e);
        }
        clear() {
          if (this._bindToCollection) {
            this.stopListening(this._bindToCollection);
            this._bindToCollection = null;
          }
          const t = Array.from(this._items);
          while (this.length) {
            this._remove(0);
          }
          this.fire("change", { added: [], removed: t, index: 0 });
        }
        bindTo(t) {
          if (this._bindToCollection) {
            throw new ss["a"]("collection-bind-to-rebind", this);
          }
          this._bindToCollection = t;
          return {
            as: (t) => {
              this._setUpBindToBinding((e) => new t(e));
            },
            using: (t) => {
              if (typeof t == "function") {
                this._setUpBindToBinding((e) => t(e));
              } else {
                this._setUpBindToBinding((e) => e[t]);
              }
            },
          };
        }
        _setUpBindToBinding(t) {
          const e = this._bindToCollection;
          const n = (n, o, i) => {
            const r = e._bindToCollection == this;
            const s = e._bindToInternalToExternalMap.get(o);
            if (r && s) {
              this._bindToExternalToInternalMap.set(o, s);
              this._bindToInternalToExternalMap.set(s, o);
            } else {
              const n = t(o);
              if (!n) {
                this._skippedIndexesFromExternal.push(i);
                return;
              }
              let r = i;
              for (const t of this._skippedIndexesFromExternal) {
                if (i > t) {
                  r--;
                }
              }
              for (const t of e._skippedIndexesFromExternal) {
                if (r >= t) {
                  r++;
                }
              }
              this._bindToExternalToInternalMap.set(o, n);
              this._bindToInternalToExternalMap.set(n, o);
              this.add(n, r);
              for (let t = 0; t < e._skippedIndexesFromExternal.length; t++) {
                if (r <= e._skippedIndexesFromExternal[t]) {
                  e._skippedIndexesFromExternal[t]++;
                }
              }
            }
          };
          for (const t of e) {
            n(null, t, e.getIndex(t));
          }
          this.listenTo(e, "add", n);
          this.listenTo(e, "remove", (t, e, n) => {
            const o = this._bindToExternalToInternalMap.get(e);
            if (o) {
              this.remove(o);
            }
            this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce(
              (t, e) => {
                if (n < e) {
                  t.push(e - 1);
                }
                if (n > e) {
                  t.push(e);
                }
                return t;
              },
              []
            );
          });
        }
        _getItemIdBeforeAdding(t) {
          const e = this._idProperty;
          let n;
          if (e in t) {
            n = t[e];
            if (typeof n != "string") {
              throw new ss["a"]("collection-add-invalid-id", this);
            }
            if (this.get(n)) {
              throw new ss["a"]("collection-add-item-already-exists", this);
            }
          } else {
            t[e] = n = ns();
          }
          return n;
        }
        _remove(t) {
          let e, n, o;
          let i = false;
          const r = this._idProperty;
          if (typeof t == "string") {
            n = t;
            o = this._itemMap.get(n);
            i = !o;
            if (o) {
              e = this._items.indexOf(o);
            }
          } else if (typeof t == "number") {
            e = t;
            o = this._items[e];
            i = !o;
            if (o) {
              n = o[r];
            }
          } else {
            o = t;
            n = o[r];
            e = this._items.indexOf(o);
            i = e == -1 || !this._itemMap.get(n);
          }
          if (i) {
            throw new ss["a"]("collection-remove-404", this);
          }
          this._items.splice(e, 1);
          this._itemMap.delete(n);
          const s = this._bindToInternalToExternalMap.get(o);
          this._bindToInternalToExternalMap.delete(o);
          this._bindToExternalToInternalMap.delete(s);
          this.fire("remove", o, e);
          return [o, e];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
      }
      Cs(vs, ds);
      class ys {
        constructor(t, e = [], n = []) {
          this._context = t;
          this._plugins = new Map();
          this._availablePlugins = new Map();
          for (const t of e) {
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t);
            }
          }
          this._contextPlugins = new Map();
          for (const [t, e] of n) {
            this._contextPlugins.set(t, e);
            this._contextPlugins.set(e, t);
            if (t.pluginName) {
              this._availablePlugins.set(t.pluginName, t);
            }
          }
        }
        *[Symbol.iterator]() {
          for (const t of this._plugins) {
            if (typeof t[0] == "function") {
              yield t;
            }
          }
        }
        get(t) {
          const e = this._plugins.get(t);
          if (!e) {
            let e = t;
            if (typeof t == "function") {
              e = t.pluginName || t.name;
            }
            throw new ss["a"](
              "plugincollection-plugin-not-loaded",
              this._context,
              { plugin: e }
            );
          }
          return e;
        }
        has(t) {
          return this._plugins.has(t);
        }
        init(t, e = []) {
          const n = this;
          const o = this._context;
          const i = new Set();
          const r = [];
          const s = g(t);
          const a = g(e);
          const c = f(t);
          if (c) {
            const t = "plugincollection-plugin-not-found";
            Object(ss["b"])(t, { plugins: c });
            return Promise.reject(new ss["a"](t, o, { plugins: c }));
          }
          return Promise.all(s.map(l))
            .then(() => d(r, "init"))
            .then(() => d(r, "afterInit"))
            .then(() => r);
          function l(t) {
            if (a.includes(t)) {
              return;
            }
            if (n._plugins.has(t) || i.has(t)) {
              return;
            }
            return u(t).catch((e) => {
              Object(ss["b"])("plugincollection-load", { plugin: t });
              throw e;
            });
          }
          function d(t, e) {
            return t.reduce((t, o) => {
              if (!o[e]) {
                return t;
              }
              if (n._contextPlugins.has(o)) {
                return t;
              }
              return t.then(o[e].bind(o));
            }, Promise.resolve());
          }
          function u(t) {
            return new Promise((s) => {
              i.add(t);
              if (t.requires) {
                t.requires.forEach((n) => {
                  const i = h(n);
                  if (t.isContextPlugin && !i.isContextPlugin) {
                    throw new ss["a"](
                      "plugincollection-context-required",
                      null,
                      { plugin: i.name, requiredBy: t.name }
                    );
                  }
                  if (e.includes(i)) {
                    throw new ss["a"]("plugincollection-required", o, {
                      plugin: i.name,
                      requiredBy: t.name,
                    });
                  }
                  l(i);
                });
              }
              const a = n._contextPlugins.get(t) || new t(o);
              n._add(t, a);
              r.push(a);
              s();
            });
          }
          function h(t) {
            if (typeof t == "function") {
              return t;
            }
            return n._availablePlugins.get(t);
          }
          function f(t) {
            const e = [];
            for (const n of t) {
              if (!h(n)) {
                e.push(n);
              }
            }
            return e.length ? e : null;
          }
          function g(t) {
            return t.map((t) => h(t)).filter((t) => !!t);
          }
        }
        destroy() {
          const t = [];
          for (const [, e] of this) {
            if (
              typeof e.destroy == "function" &&
              !this._contextPlugins.has(e)
            ) {
              t.push(e.destroy());
            }
          }
          return Promise.all(t);
        }
        _add(t, e) {
          this._plugins.set(t, e);
          const n = t.pluginName;
          if (!n) {
            return;
          }
          if (this._plugins.has(n)) {
            throw new ss["a"]("plugincollection-plugin-name-conflict", null, {
              pluginName: n,
              plugin1: this._plugins.get(n).constructor,
              plugin2: t,
            });
          }
          this._plugins.set(n, e);
        }
      }
      Cs(ys, ds);
      if (!window.CKEDITOR_TRANSLATIONS) {
        window.CKEDITOR_TRANSLATIONS = {};
      }
      function xs(t, e, n) {
        if (!window.CKEDITOR_TRANSLATIONS[t]) {
          window.CKEDITOR_TRANSLATIONS[t] = {};
        }
        const o = window.CKEDITOR_TRANSLATIONS[t];
        o.dictionary = o.dictionary || {};
        o.getPluralForm = n || o.getPluralForm;
        Object.assign(o.dictionary, e);
      }
      function Es(t, e, n = 1) {
        if (typeof n !== "number") {
          throw new ss["a"]("translation-service-quantity-not-a-number", null, {
            quantity: n,
          });
        }
        const o = Ds();
        if (o === 1) {
          t = Object.keys(window.CKEDITOR_TRANSLATIONS)[0];
        }
        const i = e.id || e.string;
        if (o === 0 || !Ps(t, i)) {
          if (n !== 1) {
            return e.plural;
          }
          return e.string;
        }
        const r = window.CKEDITOR_TRANSLATIONS[t].dictionary;
        const s =
          window.CKEDITOR_TRANSLATIONS[t].getPluralForm ||
          ((t) => (t === 1 ? 0 : 1));
        if (typeof r[i] === "string") {
          return r[i];
        }
        const a = Number(s(n));
        return r[i][a];
      }
      function Ss() {
        window.CKEDITOR_TRANSLATIONS = {};
      }
      function Ps(t, e) {
        return (
          !!window.CKEDITOR_TRANSLATIONS[t] &&
          !!window.CKEDITOR_TRANSLATIONS[t].dictionary[e]
        );
      }
      function Ds() {
        return Object.keys(window.CKEDITOR_TRANSLATIONS).length;
      }
      const Ts = ["ar", "fa", "he", "ku", "ug"];
      class Bs {
        constructor(t = {}) {
          this.uiLanguage = t.uiLanguage || "en";
          this.contentLanguage = t.contentLanguage || this.uiLanguage;
          this.uiLanguageDirection = Os(this.uiLanguage);
          this.contentLanguageDirection = Os(this.contentLanguage);
          this.t = (t, e) => this._t(t, e);
        }
        get language() {
          console.warn(
            "locale-deprecated-language-property: " +
              "The Locale#language property has been deprecated and will be removed in the near future. " +
              "Please use #uiLanguage and #contentLanguage properties instead."
          );
          return this.uiLanguage;
        }
        _t(t, e = []) {
          if (!Array.isArray(e)) {
            e = [e];
          }
          if (typeof t === "string") {
            t = { string: t };
          }
          const n = !!t.plural;
          const o = n ? e[0] : 1;
          const i = Es(this.uiLanguage, t, o);
          return Is(i, e);
        }
      }
      function Is(t, e) {
        return t.replace(/%(\d+)/g, (t, n) => (n < e.length ? e[n] : t));
      }
      function Os(t) {
        return Ts.includes(t) ? "rtl" : "ltr";
      }
      class Rs {
        constructor(t) {
          this.config = new Jr(t, this.constructor.defaultConfig);
          const e = this.constructor.builtinPlugins;
          this.config.define("plugins", e);
          this.plugins = new ys(this, e);
          const n = this.config.get("language") || {};
          this.locale = new Bs({
            uiLanguage: typeof n === "string" ? n : n.ui,
            contentLanguage: this.config.get("language.content"),
          });
          this.t = this.locale.t;
          this.editors = new vs();
          this._contextOwner = null;
        }
        initPlugins() {
          const t = this.config.get("plugins") || [];
          for (const e of t) {
            if (typeof e != "function") {
              throw new ss["a"]("context-initplugins-constructor-only", null, {
                Plugin: e,
              });
            }
            if (e.isContextPlugin !== true) {
              throw new ss["a"]("context-initplugins-invalid-plugin", null, {
                Plugin: e,
              });
            }
          }
          return this.plugins.init(t);
        }
        destroy() {
          return Promise.all(
            Array.from(this.editors, (t) => t.destroy())
          ).then(() => this.plugins.destroy());
        }
        _addEditor(t, e) {
          if (this._contextOwner) {
            throw new ss["a"]("context-addeditor-private-context");
          }
          this.editors.add(t);
          if (e) {
            this._contextOwner = t;
          }
        }
        _removeEditor(t) {
          if (this.editors.has(t)) {
            this.editors.remove(t);
          }
          if (this._contextOwner === t) {
            return this.destroy();
          }
          return Promise.resolve();
        }
        _getEditorConfig() {
          const t = {};
          for (const e of this.config.names()) {
            if (!["plugins", "removePlugins", "extraPlugins"].includes(e)) {
              t[e] = this.config.get(e);
            }
          }
          return t;
        }
        static create(t) {
          return new Promise((e) => {
            const n = new this(t);
            e(n.initPlugins().then(() => n));
          });
        }
      }
      function Fs(t, e) {
        const n = Math.min(t.length, e.length);
        for (let o = 0; o < n; o++) {
          if (t[o] != e[o]) {
            return o;
          }
        }
        if (t.length == e.length) {
          return "same";
        } else if (t.length < e.length) {
          return "prefix";
        } else {
          return "extension";
        }
      }
      var Ns = 4;
      function Ms(t) {
        return Kr(t, Ns);
      }
      var Vs = Ms;
      class Ls {
        constructor(t) {
          this.document = t;
          this.parent = null;
        }
        get index() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildIndex(this)) == -1) {
            throw new ss["a"]("view-node-not-found-in-parent", this);
          }
          return t;
        }
        get nextSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t + 1)) || null;
        }
        get previousSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t - 1)) || null;
        }
        get root() {
          let t = this;
          while (t.parent) {
            t = t.parent;
          }
          return t;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const t = [];
          let e = this;
          while (e.parent) {
            t.unshift(e.index);
            e = e.parent;
          }
          return t;
        }
        getAncestors(t = { includeSelf: false, parentFirst: false }) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e);
          const o = t.getAncestors(e);
          let i = 0;
          while (n[i] == o[i] && n[i]) {
            i++;
          }
          return i === 0 ? null : n[i - 1];
        }
        isBefore(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getPath();
          const n = t.getPath();
          const o = Fs(e, n);
          switch (o) {
            case "prefix":
              return true;
            case "extension":
              return false;
            default:
              return e[o] < n[o];
          }
        }
        isAfter(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          return !this.isBefore(t);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _fireChange(t, e) {
          this.fire("change:" + t, e);
          if (this.parent) {
            this.parent._fireChange(t, e);
          }
        }
        toJSON() {
          const t = Vs(this);
          delete t.parent;
          return t;
        }
        is(t) {
          return t === "node" || t === "view:node";
        }
      }
      Cs(Ls, ds);
      class zs extends Ls {
        constructor(t, e) {
          super(t);
          this._textData = e;
        }
        is(t) {
          return (
            t === "$text" ||
            t === "view:$text" ||
            t === "text" ||
            t === "view:text" ||
            t === "node" ||
            t === "view:node"
          );
        }
        get data() {
          return this._textData;
        }
        get _data() {
          return this.data;
        }
        set _data(t) {
          this._fireChange("text", this);
          this._textData = t;
        }
        isSimilar(t) {
          if (!(t instanceof zs)) {
            return false;
          }
          return this === t || this.data === t.data;
        }
        _clone() {
          return new zs(this.document, this.data);
        }
      }
      class js {
        constructor(t, e, n) {
          this.textNode = t;
          if (e < 0 || e > t.data.length) {
            throw new ss["a"]("view-textproxy-wrong-offsetintext", this);
          }
          if (n < 0 || e + n > t.data.length) {
            throw new ss["a"]("view-textproxy-wrong-length", this);
          }
          this.data = t.data.substring(e, e + n);
          this.offsetInText = e;
        }
        get offsetSize() {
          return this.data.length;
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        get document() {
          return this.textNode.document;
        }
        is(t) {
          return (
            t === "$textProxy" ||
            t === "view:$textProxy" ||
            t === "textProxy" ||
            t === "view:textProxy"
          );
        }
        getAncestors(t = { includeSelf: false, parentFirst: false }) {
          const e = [];
          let n = t.includeSelf ? this.textNode : this.parent;
          while (n !== null) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
      }
      function Ks(t) {
        const e = new Map();
        for (const n in t) {
          e.set(n, t[n]);
        }
        return e;
      }
      function qs(t) {
        if (As(t)) {
          return new Map(t);
        } else {
          return Ks(t);
        }
      }
      class $s {
        constructor(...t) {
          this._patterns = [];
          this.add(...t);
        }
        add(...t) {
          for (let e of t) {
            if (typeof e == "string" || e instanceof RegExp) {
              e = { name: e };
            }
            if (
              e.classes &&
              (typeof e.classes == "string" || e.classes instanceof RegExp)
            ) {
              e.classes = [e.classes];
            }
            this._patterns.push(e);
          }
        }
        match(...t) {
          for (const e of t) {
            for (const t of this._patterns) {
              const n = Ws(e, t);
              if (n) {
                return { element: e, pattern: t, match: n };
              }
            }
          }
          return null;
        }
        matchAll(...t) {
          const e = [];
          for (const n of t) {
            for (const t of this._patterns) {
              const o = Ws(n, t);
              if (o) {
                e.push({ element: n, pattern: t, match: o });
              }
            }
          }
          return e.length > 0 ? e : null;
        }
        getElementName() {
          if (this._patterns.length !== 1) {
            return null;
          }
          const t = this._patterns[0];
          const e = t.name;
          return typeof t != "function" && e && !(e instanceof RegExp)
            ? e
            : null;
        }
      }
      function Ws(t, e) {
        if (typeof e == "function") {
          return e(t);
        }
        const n = {};
        if (e.name) {
          n.name = Gs(e.name, t.name);
          if (!n.name) {
            return null;
          }
        }
        if (e.attributes) {
          n.attributes = Us(e.attributes, t);
          if (!n.attributes) {
            return null;
          }
        }
        if (e.classes) {
          n.classes = Hs(e.classes, t);
          if (!n.classes) {
            return false;
          }
        }
        if (e.styles) {
          n.styles = Js(e.styles, t);
          if (!n.styles) {
            return false;
          }
        }
        return n;
      }
      function Gs(t, e) {
        if (t instanceof RegExp) {
          return t.test(e);
        }
        return t === e;
      }
      function Us(t, e) {
        const n = [];
        for (const o in t) {
          const i = t[o];
          if (e.hasAttribute(o)) {
            const t = e.getAttribute(o);
            if (i === true) {
              n.push(o);
            } else if (i instanceof RegExp) {
              if (i.test(t)) {
                n.push(o);
              } else {
                return null;
              }
            } else if (t === i) {
              n.push(o);
            } else {
              return null;
            }
          } else {
            return null;
          }
        }
        return n;
      }
      function Hs(t, e) {
        const n = [];
        for (const o of t) {
          if (o instanceof RegExp) {
            const t = e.getClassNames();
            for (const e of t) {
              if (o.test(e)) {
                n.push(e);
              }
            }
            if (n.length === 0) {
              return null;
            }
          } else if (e.hasClass(o)) {
            n.push(o);
          } else {
            return null;
          }
        }
        return n;
      }
      function Js(t, e) {
        const n = [];
        for (const o in t) {
          const i = t[o];
          if (e.hasStyle(o)) {
            const t = e.getStyle(o);
            if (i instanceof RegExp) {
              if (i.test(t)) {
                n.push(o);
              } else {
                return null;
              }
            } else if (t === i) {
              n.push(o);
            } else {
              return null;
            }
          } else {
            return null;
          }
        }
        return n;
      }
      var Ys = "[object Symbol]";
      function Qs(t) {
        return typeof t == "symbol" || (E(t) && _(t) == Ys);
      }
      var Xs = Qs;
      var Zs = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
        ta = /^\w*$/;
      function ea(t, e) {
        if (Je(t)) {
          return false;
        }
        var n = typeof t;
        if (
          n == "number" ||
          n == "symbol" ||
          n == "boolean" ||
          t == null ||
          Xs(t)
        ) {
          return true;
        }
        return ta.test(t) || !Zs.test(t) || (e != null && t in Object(e));
      }
      var na = ea;
      var oa = "Expected a function";
      function ia(t, e) {
        if (typeof t != "function" || (e != null && typeof e != "function")) {
          throw new TypeError(oa);
        }
        var n = function () {
          var o = arguments,
            i = e ? e.apply(this, o) : o[0],
            r = n.cache;
          if (r.has(i)) {
            return r.get(i);
          }
          var s = t.apply(this, o);
          n.cache = r.set(i, s) || r;
          return s;
        };
        n.cache = new (ia.Cache || _e)();
        return n;
      }
      ia.Cache = _e;
      var ra = ia;
      var sa = 500;
      function aa(t) {
        var e = ra(t, function (t) {
          if (n.size === sa) {
            n.clear();
          }
          return t;
        });
        var n = e.cache;
        return e;
      }
      var ca = aa;
      var la = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var da = /\\(\\)?/g;
      var ua = ca(function (t) {
        var e = [];
        if (t.charCodeAt(0) === 46) {
          e.push("");
        }
        t.replace(la, function (t, n, o, i) {
          e.push(o ? i.replace(da, "$1") : n || t);
        });
        return e;
      });
      var ha = ua;
      function fa(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length,
          i = Array(o);
        while (++n < o) {
          i[n] = e(t[n], n, t);
        }
        return i;
      }
      var ga = fa;
      var pa = 1 / 0;
      var ma = r ? r.prototype : undefined,
        ka = ma ? ma.toString : undefined;
      function ba(t) {
        if (typeof t == "string") {
          return t;
        }
        if (Je(t)) {
          return ga(t, ba) + "";
        }
        if (Xs(t)) {
          return ka ? ka.call(t) : "";
        }
        var e = t + "";
        return e == "0" && 1 / t == -pa ? "-0" : e;
      }
      var wa = ba;
      function _a(t) {
        return t == null ? "" : wa(t);
      }
      var Aa = _a;
      function Ca(t, e) {
        if (Je(t)) {
          return t;
        }
        return na(t, e) ? [t] : ha(Aa(t));
      }
      var va = Ca;
      function ya(t) {
        var e = t == null ? 0 : t.length;
        return e ? t[e - 1] : undefined;
      }
      var xa = ya;
      var Ea = 1 / 0;
      function Sa(t) {
        if (typeof t == "string" || Xs(t)) {
          return t;
        }
        var e = t + "";
        return e == "0" && 1 / t == -Ea ? "-0" : e;
      }
      var Pa = Sa;
      function Da(t, e) {
        e = va(e, t);
        var n = 0,
          o = e.length;
        while (t != null && n < o) {
          t = t[Pa(e[n++])];
        }
        return n && n == o ? t : undefined;
      }
      var Ta = Da;
      function Ba(t, e, n) {
        var o = -1,
          i = t.length;
        if (e < 0) {
          e = -e > i ? 0 : i + e;
        }
        n = n > i ? i : n;
        if (n < 0) {
          n += i;
        }
        i = e > n ? 0 : (n - e) >>> 0;
        e >>>= 0;
        var r = Array(i);
        while (++o < i) {
          r[o] = t[o + e];
        }
        return r;
      }
      var Ia = Ba;
      function Oa(t, e) {
        return e.length < 2 ? t : Ta(t, Ia(e, 0, -1));
      }
      var Ra = Oa;
      function Fa(t, e) {
        e = va(e, t);
        t = Ra(t, e);
        return t == null || delete t[Pa(xa(e))];
      }
      var Na = Fa;
      function Ma(t, e) {
        return t == null ? true : Na(t, e);
      }
      var Va = Ma;
      function La(t, e, n) {
        var o = t == null ? undefined : Ta(t, e);
        return o === undefined ? n : o;
      }
      var za = La;
      function ja(t, e, n) {
        if (
          (n !== undefined && !V(t[e], n)) ||
          (n === undefined && !(e in t))
        ) {
          Be(t, e, n);
        }
      }
      var Ka = ja;
      function qa(t) {
        return function (e, n, o) {
          var i = -1,
            r = Object(e),
            s = o(e),
            a = s.length;
          while (a--) {
            var c = s[t ? a : ++i];
            if (n(r[c], c, r) === false) {
              break;
            }
          }
          return e;
        };
      }
      var $a = qa;
      var Wa = $a();
      var Ga = Wa;
      function Ua(t) {
        return E(t) && Xn(t);
      }
      var Ha = Ua;
      function Ja(t, e) {
        if (e === "constructor" && typeof t[e] === "function") {
          return;
        }
        if (e == "__proto__") {
          return;
        }
        return t[e];
      }
      var Ya = Ja;
      function Qa(t) {
        return Me(t, uo(t));
      }
      var Xa = Qa;
      function Za(t, e, n, o, i, r, s) {
        var a = Ya(t, n),
          c = Ya(e, n),
          l = s.get(c);
        if (l) {
          Ka(t, n, l);
          return;
        }
        var d = r ? r(a, c, n + "", t, e, s) : undefined;
        var u = d === undefined;
        if (u) {
          var h = Je(c),
            f = !h && Object(Ye["a"])(c),
            g = !h && !f && Mn(c);
          d = c;
          if (h || f || g) {
            if (Je(a)) {
              d = a;
            } else if (Ha(a)) {
              d = mo(a);
            } else if (f) {
              u = false;
              d = Object(go["a"])(c, true);
            } else if (g) {
              u = false;
              d = Ei(c, true);
            } else {
              d = [];
            }
          } else if (R(c) || Ue(c)) {
            d = a;
            if (Ue(a)) {
              d = Xa(a);
            } else if (!ct(a) || gt(a)) {
              d = Xi(c);
            }
          } else {
            u = false;
          }
        }
        if (u) {
          s.set(c, d);
          i(d, c, o, r, s);
          s["delete"](c);
        }
        Ka(t, n, d);
      }
      var tc = Za;
      function ec(t, e, n, o, i) {
        if (t === e) {
          return;
        }
        Ga(
          e,
          function (r, s) {
            i || (i = new xe());
            if (ct(r)) {
              tc(t, e, s, n, ec, o, i);
            } else {
              var a = o ? o(Ya(t, s), r, s + "", t, e, i) : undefined;
              if (a === undefined) {
                a = r;
              }
              Ka(t, s, a);
            }
          },
          uo
        );
      }
      var nc = ec;
      function oc(t) {
        return t;
      }
      var ic = oc;
      function rc(t, e, n) {
        switch (n.length) {
          case 0:
            return t.call(e);
          case 1:
            return t.call(e, n[0]);
          case 2:
            return t.call(e, n[0], n[1]);
          case 3:
            return t.call(e, n[0], n[1], n[2]);
        }
        return t.apply(e, n);
      }
      var sc = rc;
      var ac = Math.max;
      function cc(t, e, n) {
        e = ac(e === undefined ? t.length - 1 : e, 0);
        return function () {
          var o = arguments,
            i = -1,
            r = ac(o.length - e, 0),
            s = Array(r);
          while (++i < r) {
            s[i] = o[e + i];
          }
          i = -1;
          var a = Array(e + 1);
          while (++i < e) {
            a[i] = o[i];
          }
          a[e] = n(s);
          return sc(t, this, a);
        };
      }
      var lc = cc;
      function dc(t) {
        return function () {
          return t;
        };
      }
      var uc = dc;
      var hc = !De
        ? ic
        : function (t, e) {
            return De(t, "toString", {
              configurable: true,
              enumerable: false,
              value: uc(e),
              writable: true,
            });
          };
      var fc = hc;
      var gc = 800,
        pc = 16;
      var mc = Date.now;
      function kc(t) {
        var e = 0,
          n = 0;
        return function () {
          var o = mc(),
            i = pc - (o - n);
          n = o;
          if (i > 0) {
            if (++e >= gc) {
              return arguments[0];
            }
          } else {
            e = 0;
          }
          return t.apply(undefined, arguments);
        };
      }
      var bc = kc;
      var wc = bc(fc);
      var _c = wc;
      function Ac(t, e) {
        return _c(lc(t, e, ic), t + "");
      }
      var Cc = Ac;
      function vc(t, e, n) {
        if (!ct(n)) {
          return false;
        }
        var o = typeof e;
        if (
          o == "number" ? Xn(n) && tn(e, n.length) : o == "string" && e in n
        ) {
          return V(n[e], t);
        }
        return false;
      }
      var yc = vc;
      function xc(t) {
        return Cc(function (e, n) {
          var o = -1,
            i = n.length,
            r = i > 1 ? n[i - 1] : undefined,
            s = i > 2 ? n[2] : undefined;
          r = t.length > 3 && typeof r == "function" ? (i--, r) : undefined;
          if (s && yc(n[0], n[1], s)) {
            r = i < 3 ? undefined : r;
            i = 1;
          }
          e = Object(e);
          while (++o < i) {
            var a = n[o];
            if (a) {
              t(e, a, o, r);
            }
          }
          return e;
        });
      }
      var Ec = xc;
      var Sc = Ec(function (t, e, n) {
        nc(t, e, n);
      });
      var Pc = Sc;
      function Dc(t, e, n, o) {
        if (!ct(t)) {
          return t;
        }
        e = va(e, t);
        var i = -1,
          r = e.length,
          s = r - 1,
          a = t;
        while (a != null && ++i < r) {
          var c = Pa(e[i]),
            l = n;
          if (i != s) {
            var d = a[c];
            l = o ? o(d, c, a) : undefined;
            if (l === undefined) {
              l = ct(d) ? d : tn(e[i + 1]) ? [] : {};
            }
          }
          Fe(a, c, l);
          a = a[c];
        }
        return t;
      }
      var Tc = Dc;
      function Bc(t, e, n) {
        return t == null ? t : Tc(t, e, n);
      }
      var Ic = Bc;
      class Oc {
        constructor(t) {
          this._styles = {};
          this._styleProcessor = t;
        }
        get isEmpty() {
          const t = Object.entries(this._styles);
          const e = Array.from(t);
          return !e.length;
        }
        get size() {
          if (this.isEmpty) {
            return 0;
          }
          return this.getStyleNames().length;
        }
        setTo(t) {
          this.clear();
          const e = Array.from(Fc(t).entries());
          for (const [t, n] of e) {
            this._styleProcessor.toNormalizedForm(t, n, this._styles);
          }
        }
        has(t) {
          if (this.isEmpty) {
            return false;
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles);
          const n = e.find(([e]) => e === t);
          return Array.isArray(n);
        }
        set(t, e) {
          if (ct(t)) {
            for (const [e, n] of Object.entries(t)) {
              this._styleProcessor.toNormalizedForm(e, n, this._styles);
            }
          } else {
            this._styleProcessor.toNormalizedForm(t, e, this._styles);
          }
        }
        remove(t) {
          const e = Nc(t);
          Va(this._styles, e);
          delete this._styles[t];
          this._cleanEmptyObjectsOnPath(e);
        }
        getNormalized(t) {
          return this._styleProcessor.getNormalized(t, this._styles);
        }
        toString() {
          if (this.isEmpty) {
            return "";
          }
          return (
            this._getStylesEntries()
              .map((t) => t.join(":"))
              .sort()
              .join(";") + ";"
          );
        }
        getAsString(t) {
          if (this.isEmpty) {
            return;
          }
          if (this._styles[t] && !ct(this._styles[t])) {
            return this._styles[t];
          }
          const e = this._styleProcessor.getReducedForm(t, this._styles);
          const n = e.find(([e]) => e === t);
          if (Array.isArray(n)) {
            return n[1];
          }
        }
        getStyleNames() {
          if (this.isEmpty) {
            return [];
          }
          const t = this._getStylesEntries();
          return t.map(([t]) => t);
        }
        clear() {
          this._styles = {};
        }
        _getStylesEntries() {
          const t = [];
          const e = Object.keys(this._styles);
          for (const n of e) {
            t.push(...this._styleProcessor.getReducedForm(n, this._styles));
          }
          return t;
        }
        _cleanEmptyObjectsOnPath(t) {
          const e = t.split(".");
          const n = e.length > 1;
          if (!n) {
            return;
          }
          const o = e.splice(0, e.length - 1).join(".");
          const i = za(this._styles, o);
          if (!i) {
            return;
          }
          const r = !Array.from(Object.keys(i)).length;
          if (r) {
            this.remove(o);
          }
        }
      }
      class Rc {
        constructor() {
          this._normalizers = new Map();
          this._extractors = new Map();
          this._reducers = new Map();
          this._consumables = new Map();
        }
        toNormalizedForm(t, e, n) {
          if (ct(e)) {
            Mc(n, Nc(t), e);
            return;
          }
          if (this._normalizers.has(t)) {
            const o = this._normalizers.get(t);
            const { path: i, value: r } = o(e);
            Mc(n, i, r);
          } else {
            Mc(n, t, e);
          }
        }
        getNormalized(t, e) {
          if (!t) {
            return Pc({}, e);
          }
          if (e[t] !== undefined) {
            return e[t];
          }
          if (this._extractors.has(t)) {
            const n = this._extractors.get(t);
            if (typeof n === "string") {
              return za(e, n);
            }
            const o = n(t, e);
            if (o) {
              return o;
            }
          }
          return za(e, Nc(t));
        }
        getReducedForm(t, e) {
          const n = this.getNormalized(t, e);
          if (n === undefined) {
            return [];
          }
          if (this._reducers.has(t)) {
            const e = this._reducers.get(t);
            return e(n);
          }
          return [[t, n]];
        }
        getRelatedStyles(t) {
          return this._consumables.get(t) || [];
        }
        setNormalizer(t, e) {
          this._normalizers.set(t, e);
        }
        setExtractor(t, e) {
          this._extractors.set(t, e);
        }
        setReducer(t, e) {
          this._reducers.set(t, e);
        }
        setStyleRelation(t, e) {
          this._mapStyleNames(t, e);
          for (const n of e) {
            this._mapStyleNames(n, [t]);
          }
        }
        _mapStyleNames(t, e) {
          if (!this._consumables.has(t)) {
            this._consumables.set(t, []);
          }
          this._consumables.get(t).push(...e);
        }
      }
      function Fc(t) {
        let e = null;
        let n = 0;
        let o = 0;
        let i = null;
        const r = new Map();
        if (t === "") {
          return r;
        }
        if (t.charAt(t.length - 1) != ";") {
          t = t + ";";
        }
        for (let s = 0; s < t.length; s++) {
          const a = t.charAt(s);
          if (e === null) {
            switch (a) {
              case ":":
                if (!i) {
                  i = t.substr(n, s - n);
                  o = s + 1;
                }
                break;
              case '"':
              case "'":
                e = a;
                break;
              case ";": {
                const e = t.substr(o, s - o);
                if (i) {
                  r.set(i.trim(), e.trim());
                }
                i = null;
                n = s + 1;
                break;
              }
            }
          } else if (a === e) {
            e = null;
          }
        }
        return r;
      }
      function Nc(t) {
        return t.replace("-", ".");
      }
      function Mc(t, e, n) {
        let o = n;
        if (ct(n)) {
          o = Pc({}, za(t, e), n);
        }
        Ic(t, e, o);
      }
      class Vc extends Ls {
        constructor(t, e, n, o) {
          super(t);
          this.name = e;
          this._attrs = Lc(n);
          this._children = [];
          if (o) {
            this._insertChild(0, o);
          }
          this._classes = new Set();
          if (this._attrs.has("class")) {
            const t = this._attrs.get("class");
            zc(this._classes, t);
            this._attrs.delete("class");
          }
          this._styles = new Oc(this.document.stylesProcessor);
          if (this._attrs.has("style")) {
            this._styles.setTo(this._attrs.get("style"));
            this._attrs.delete("style");
          }
          this._customProperties = new Map();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this._children.length === 0;
        }
        is(t, e = null) {
          if (!e) {
            return (
              t === "element" ||
              t === "view:element" ||
              t === "node" ||
              t === "view:node"
            );
          } else {
            return e === this.name && (t === "element" || t === "view:element");
          }
        }
        getChild(t) {
          return this._children[t];
        }
        getChildIndex(t) {
          return this._children.indexOf(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        *getAttributeKeys() {
          if (this._classes.size > 0) {
            yield "class";
          }
          if (!this._styles.isEmpty) {
            yield "style";
          }
          yield* this._attrs.keys();
        }
        *getAttributes() {
          yield* this._attrs.entries();
          if (this._classes.size > 0) {
            yield ["class", this.getAttribute("class")];
          }
          if (!this._styles.isEmpty) {
            yield ["style", this.getAttribute("style")];
          }
        }
        getAttribute(t) {
          if (t == "class") {
            if (this._classes.size > 0) {
              return [...this._classes].join(" ");
            }
            return undefined;
          }
          if (t == "style") {
            const t = this._styles.toString();
            return t == "" ? undefined : t;
          }
          return this._attrs.get(t);
        }
        hasAttribute(t) {
          if (t == "class") {
            return this._classes.size > 0;
          }
          if (t == "style") {
            return !this._styles.isEmpty;
          }
          return this._attrs.has(t);
        }
        isSimilar(t) {
          if (!(t instanceof Vc)) {
            return false;
          }
          if (this === t) {
            return true;
          }
          if (this.name != t.name) {
            return false;
          }
          if (
            this._attrs.size !== t._attrs.size ||
            this._classes.size !== t._classes.size ||
            this._styles.size !== t._styles.size
          ) {
            return false;
          }
          for (const [e, n] of this._attrs) {
            if (!t._attrs.has(e) || t._attrs.get(e) !== n) {
              return false;
            }
          }
          for (const e of this._classes) {
            if (!t._classes.has(e)) {
              return false;
            }
          }
          for (const e of this._styles.getStyleNames()) {
            if (
              !t._styles.has(e) ||
              t._styles.getAsString(e) !== this._styles.getAsString(e)
            ) {
              return false;
            }
          }
          return true;
        }
        hasClass(...t) {
          for (const e of t) {
            if (!this._classes.has(e)) {
              return false;
            }
          }
          return true;
        }
        getClassNames() {
          return this._classes.keys();
        }
        getStyle(t) {
          return this._styles.getAsString(t);
        }
        getNormalizedStyle(t) {
          return this._styles.getNormalized(t);
        }
        getStyleNames() {
          return this._styles.getStyleNames();
        }
        hasStyle(...t) {
          for (const e of t) {
            if (!this._styles.has(e)) {
              return false;
            }
          }
          return true;
        }
        findAncestor(...t) {
          const e = new $s(...t);
          let n = this.parent;
          while (n) {
            if (e.match(n)) {
              return n;
            }
            n = n.parent;
          }
          return null;
        }
        getCustomProperty(t) {
          return this._customProperties.get(t);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        getIdentity() {
          const t = Array.from(this._classes).sort().join(",");
          const e = this._styles.toString();
          const n = Array.from(this._attrs)
            .map((t) => `${t[0]}="${t[1]}"`)
            .sort()
            .join(" ");
          return (
            this.name +
            (t == "" ? "" : ` class="${t}"`) +
            (!e ? "" : ` style="${e}"`) +
            (n == "" ? "" : ` ${n}`)
          );
        }
        _clone(t = false) {
          const e = [];
          if (t) {
            for (const n of this.getChildren()) {
              e.push(n._clone(t));
            }
          }
          const n = new this.constructor(
            this.document,
            this.name,
            this._attrs,
            e
          );
          n._classes = new Set(this._classes);
          n._styles.set(this._styles.getNormalized());
          n._customProperties = new Map(this._customProperties);
          n.getFillerOffset = this.getFillerOffset;
          return n;
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          this._fireChange("children", this);
          let n = 0;
          const o = jc(this.document, e);
          for (const e of o) {
            if (e.parent !== null) {
              e._remove();
            }
            e.parent = this;
            e.document = this.document;
            this._children.splice(t, 0, e);
            t++;
            n++;
          }
          return n;
        }
        _removeChildren(t, e = 1) {
          this._fireChange("children", this);
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null;
          }
          return this._children.splice(t, e);
        }
        _setAttribute(t, e) {
          e = String(e);
          this._fireChange("attributes", this);
          if (t == "class") {
            zc(this._classes, e);
          } else if (t == "style") {
            this._styles.setTo(e);
          } else {
            this._attrs.set(t, e);
          }
        }
        _removeAttribute(t) {
          this._fireChange("attributes", this);
          if (t == "class") {
            if (this._classes.size > 0) {
              this._classes.clear();
              return true;
            }
            return false;
          }
          if (t == "style") {
            if (!this._styles.isEmpty) {
              this._styles.clear();
              return true;
            }
            return false;
          }
          return this._attrs.delete(t);
        }
        _addClass(t) {
          this._fireChange("attributes", this);
          t = Array.isArray(t) ? t : [t];
          t.forEach((t) => this._classes.add(t));
        }
        _removeClass(t) {
          this._fireChange("attributes", this);
          t = Array.isArray(t) ? t : [t];
          t.forEach((t) => this._classes.delete(t));
        }
        _setStyle(t, e) {
          this._fireChange("attributes", this);
          this._styles.set(t, e);
        }
        _removeStyle(t) {
          this._fireChange("attributes", this);
          t = Array.isArray(t) ? t : [t];
          t.forEach((t) => this._styles.remove(t));
        }
        _setCustomProperty(t, e) {
          this._customProperties.set(t, e);
        }
        _removeCustomProperty(t) {
          return this._customProperties.delete(t);
        }
      }
      function Lc(t) {
        t = qs(t);
        for (const [e, n] of t) {
          if (n === null) {
            t.delete(e);
          } else if (typeof n != "string") {
            t.set(e, String(n));
          }
        }
        return t;
      }
      function zc(t, e) {
        const n = e.split(/\s+/);
        t.clear();
        n.forEach((e) => t.add(e));
      }
      function jc(t, e) {
        if (typeof e == "string") {
          return [new zs(t, e)];
        }
        if (!As(e)) {
          e = [e];
        }
        return Array.from(e).map((e) => {
          if (typeof e == "string") {
            return new zs(t, e);
          }
          if (e instanceof js) {
            return new zs(t, e.data);
          }
          return e;
        });
      }
      class Kc extends Vc {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = qc;
        }
        is(t, e = null) {
          if (!e) {
            return (
              t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element" ||
              t === "node" ||
              t === "view:node"
            );
          } else {
            return (
              e === this.name &&
              (t === "containerElement" ||
                t === "view:containerElement" ||
                t === "element" ||
                t === "view:element")
            );
          }
        }
      }
      function qc() {
        const t = [...this.getChildren()];
        const e = t[this.childCount - 1];
        if (e && e.is("element", "br")) {
          return this.childCount;
        }
        for (const e of t) {
          if (!e.is("uiElement")) {
            return null;
          }
        }
        return this.childCount;
      }
      var $c = Ec(function (t, e) {
        Me(e, uo(e), t);
      });
      var Wc = $c;
      const Gc = Symbol("observableProperties");
      const Uc = Symbol("boundObservables");
      const Hc = Symbol("boundProperties");
      const Jc = {
        set(t, e) {
          if (ct(t)) {
            Object.keys(t).forEach((e) => {
              this.set(e, t[e]);
            }, this);
            return;
          }
          Qc(this);
          const n = this[Gc];
          if (t in this && !n.has(t)) {
            throw new ss["a"]("observable-set-cannot-override", this);
          }
          Object.defineProperty(this, t, {
            enumerable: true,
            configurable: true,
            get() {
              return n.get(t);
            },
            set(e) {
              const o = n.get(t);
              let i = this.fire("set:" + t, t, e, o);
              if (i === undefined) {
                i = e;
              }
              if (o !== i || !n.has(t)) {
                n.set(t, i);
                this.fire("change:" + t, t, i, o);
              }
            },
          });
          this[t] = e;
        },
        bind(...t) {
          if (!t.length || !el(t)) {
            throw new ss["a"]("observable-bind-wrong-properties", this);
          }
          if (new Set(t).size !== t.length) {
            throw new ss["a"]("observable-bind-duplicate-properties", this);
          }
          Qc(this);
          const e = this[Hc];
          t.forEach((t) => {
            if (e.has(t)) {
              throw new ss["a"]("observable-bind-rebind", this);
            }
          });
          const n = new Map();
          t.forEach((t) => {
            const o = { property: t, to: [] };
            e.set(t, o);
            n.set(t, o);
          });
          return {
            to: Xc,
            toMany: Zc,
            _observable: this,
            _bindProperties: t,
            _to: [],
            _bindings: n,
          };
        },
        unbind(...t) {
          if (!this[Gc]) {
            return;
          }
          const e = this[Hc];
          const n = this[Uc];
          if (t.length) {
            if (!el(t)) {
              throw new ss["a"]("observable-unbind-wrong-properties", this);
            }
            t.forEach((t) => {
              const o = e.get(t);
              if (!o) {
                return;
              }
              let i, r, s, a;
              o.to.forEach((t) => {
                i = t[0];
                r = t[1];
                s = n.get(i);
                a = s[r];
                a.delete(o);
                if (!a.size) {
                  delete s[r];
                }
                if (!Object.keys(s).length) {
                  n.delete(i);
                  this.stopListening(i, "change");
                }
              });
              e.delete(t);
            });
          } else {
            n.forEach((t, e) => {
              this.stopListening(e, "change");
            });
            n.clear();
            e.clear();
          }
        },
        decorate(t) {
          const e = this[t];
          if (!e) {
            throw new ss["a"](
              "observablemixin-cannot-decorate-undefined",
              this,
              { object: this, methodName: t }
            );
          }
          this.on(t, (t, n) => {
            t.return = e.apply(this, n);
          });
          this[t] = function (...e) {
            return this.fire(t, e);
          };
        },
      };
      Wc(Jc, ds);
      var Yc = Jc;
      function Qc(t) {
        if (t[Gc]) {
          return;
        }
        Object.defineProperty(t, Gc, { value: new Map() });
        Object.defineProperty(t, Uc, { value: new Map() });
        Object.defineProperty(t, Hc, { value: new Map() });
      }
      function Xc(...t) {
        const e = nl(...t);
        const n = Array.from(this._bindings.keys());
        const o = n.length;
        if (!e.callback && e.to.length > 1) {
          throw new ss["a"]("observable-bind-to-no-callback", this);
        }
        if (o > 1 && e.callback) {
          throw new ss["a"]("observable-bind-to-extra-callback", this);
        }
        e.to.forEach((t) => {
          if (t.properties.length && t.properties.length !== o) {
            throw new ss["a"]("observable-bind-to-properties-length", this);
          }
          if (!t.properties.length) {
            t.properties = this._bindProperties;
          }
        });
        this._to = e.to;
        if (e.callback) {
          this._bindings.get(n[0]).callback = e.callback;
        }
        sl(this._observable, this._to);
        il(this);
        this._bindProperties.forEach((t) => {
          rl(this._observable, t);
        });
      }
      function Zc(t, e, n) {
        if (this._bindings.size > 1) {
          throw new ss["a"]("observable-bind-to-many-not-one-binding", this);
        }
        this.to(...tl(t, e), n);
      }
      function tl(t, e) {
        const n = t.map((t) => [t, e]);
        return Array.prototype.concat.apply([], n);
      }
      function el(t) {
        return t.every((t) => typeof t == "string");
      }
      function nl(...t) {
        if (!t.length) {
          throw new ss["a"]("observable-bind-to-parse-error", null);
        }
        const e = { to: [] };
        let n;
        if (typeof t[t.length - 1] == "function") {
          e.callback = t.pop();
        }
        t.forEach((t) => {
          if (typeof t == "string") {
            n.properties.push(t);
          } else if (typeof t == "object") {
            n = { observable: t, properties: [] };
            e.to.push(n);
          } else {
            throw new ss["a"]("observable-bind-to-parse-error", null);
          }
        });
        return e;
      }
      function ol(t, e, n, o) {
        const i = t[Uc];
        const r = i.get(n);
        const s = r || {};
        if (!s[o]) {
          s[o] = new Set();
        }
        s[o].add(e);
        if (!r) {
          i.set(n, s);
        }
      }
      function il(t) {
        let e;
        t._bindings.forEach((n, o) => {
          t._to.forEach((i) => {
            e = i.properties[n.callback ? 0 : t._bindProperties.indexOf(o)];
            n.to.push([i.observable, e]);
            ol(t._observable, n, i.observable, e);
          });
        });
      }
      function rl(t, e) {
        const n = t[Hc];
        const o = n.get(e);
        let i;
        if (o.callback) {
          i = o.callback.apply(
            t,
            o.to.map((t) => t[0][t[1]])
          );
        } else {
          i = o.to[0];
          i = i[0][i[1]];
        }
        if (Object.prototype.hasOwnProperty.call(t, e)) {
          t[e] = i;
        } else {
          t.set(e, i);
        }
      }
      function sl(t, e) {
        e.forEach((e) => {
          const n = t[Uc];
          let o;
          if (!n.get(e.observable)) {
            t.listenTo(e.observable, "change", (i, r) => {
              o = n.get(e.observable)[r];
              if (o) {
                o.forEach((e) => {
                  rl(t, e.property);
                });
              }
            });
          }
        });
      }
      class al extends Kc {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.set("isReadOnly", false);
          this.set("isFocused", false);
          this.bind("isReadOnly").to(t);
          this.bind("isFocused").to(
            t,
            "isFocused",
            (e) => e && t.selection.editableElement == this
          );
          this.listenTo(t.selection, "change", () => {
            this.isFocused = t.isFocused && t.selection.editableElement == this;
          });
        }
        is(t, e = null) {
          if (!e) {
            return (
              t === "editableElement" ||
              t === "view:editableElement" ||
              t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element" ||
              t === "node" ||
              t === "view:node"
            );
          } else {
            return (
              e === this.name &&
              (t === "editableElement" ||
                t === "view:editableElement" ||
                t === "containerElement" ||
                t === "view:containerElement" ||
                t === "element" ||
                t === "view:element")
            );
          }
        }
        destroy() {
          this.stopListening();
        }
      }
      Cs(al, Yc);
      const cl = Symbol("rootName");
      class ll extends al {
        constructor(t, e) {
          super(t, e);
          this.rootName = "main";
        }
        is(t, e = null) {
          if (!e) {
            return (
              t === "rootElement" ||
              t === "view:rootElement" ||
              t === "editableElement" ||
              t === "view:editableElement" ||
              t === "containerElement" ||
              t === "view:containerElement" ||
              t === "element" ||
              t === "view:element" ||
              t === "node" ||
              t === "view:node"
            );
          } else {
            return (
              e === this.name &&
              (t === "rootElement" ||
                t === "view:rootElement" ||
                t === "editableElement" ||
                t === "view:editableElement" ||
                t === "containerElement" ||
                t === "view:containerElement" ||
                t === "element" ||
                t === "view:element")
            );
          }
        }
        get rootName() {
          return this.getCustomProperty(cl);
        }
        set rootName(t) {
          this._setCustomProperty(cl, t);
        }
        set _name(t) {
          this.name = t;
        }
      }
      class dl {
        constructor(t = {}) {
          if (!t.boundaries && !t.startPosition) {
            throw new ss["a"]("view-tree-walker-no-start-position", null);
          }
          if (
            t.direction &&
            t.direction != "forward" &&
            t.direction != "backward"
          ) {
            throw new ss["a"](
              "view-tree-walker-unknown-direction",
              t.startPosition,
              { direction: t.direction }
            );
          }
          this.boundaries = t.boundaries || null;
          if (t.startPosition) {
            this.position = ul._createAt(t.startPosition);
          } else {
            this.position = ul._createAt(
              t.boundaries[t.direction == "backward" ? "end" : "start"]
            );
          }
          this.direction = t.direction || "forward";
          this.singleCharacters = !!t.singleCharacters;
          this.shallow = !!t.shallow;
          this.ignoreElementEnd = !!t.ignoreElementEnd;
          this._boundaryStartParent = this.boundaries
            ? this.boundaries.start.parent
            : null;
          this._boundaryEndParent = this.boundaries
            ? this.boundaries.end.parent
            : null;
        }
        [Symbol.iterator]() {
          return this;
        }
        skip(t) {
          let e, n, o;
          do {
            o = this.position;
            ({ done: e, value: n } = this.next());
          } while (!e && t(n));
          if (!e) {
            this.position = o;
          }
        }
        next() {
          if (this.direction == "forward") {
            return this._next();
          } else {
            return this._previous();
          }
        }
        _next() {
          let t = this.position.clone();
          const e = this.position;
          const n = t.parent;
          if (n.parent === null && t.offset === n.childCount) {
            return { done: true };
          }
          if (
            n === this._boundaryEndParent &&
            t.offset == this.boundaries.end.offset
          ) {
            return { done: true };
          }
          let o;
          if (n instanceof zs) {
            if (t.isAtEnd) {
              this.position = ul._createAfter(n);
              return this._next();
            }
            o = n.data[t.offset];
          } else {
            o = n.getChild(t.offset);
          }
          if (o instanceof Vc) {
            if (!this.shallow) {
              t = new ul(o, 0);
            } else {
              t.offset++;
            }
            this.position = t;
            return this._formatReturnValue("elementStart", o, e, t, 1);
          } else if (o instanceof zs) {
            if (this.singleCharacters) {
              t = new ul(o, 0);
              this.position = t;
              return this._next();
            } else {
              let n = o.data.length;
              let i;
              if (o == this._boundaryEndParent) {
                n = this.boundaries.end.offset;
                i = new js(o, 0, n);
                t = ul._createAfter(i);
              } else {
                i = new js(o, 0, o.data.length);
                t.offset++;
              }
              this.position = t;
              return this._formatReturnValue("text", i, e, t, n);
            }
          } else if (typeof o == "string") {
            let o;
            if (this.singleCharacters) {
              o = 1;
            } else {
              const e =
                n === this._boundaryEndParent
                  ? this.boundaries.end.offset
                  : n.data.length;
              o = e - t.offset;
            }
            const i = new js(n, t.offset, o);
            t.offset += o;
            this.position = t;
            return this._formatReturnValue("text", i, e, t, o);
          } else {
            t = ul._createAfter(n);
            this.position = t;
            if (this.ignoreElementEnd) {
              return this._next();
            } else {
              return this._formatReturnValue("elementEnd", n, e, t);
            }
          }
        }
        _previous() {
          let t = this.position.clone();
          const e = this.position;
          const n = t.parent;
          if (n.parent === null && t.offset === 0) {
            return { done: true };
          }
          if (
            n == this._boundaryStartParent &&
            t.offset == this.boundaries.start.offset
          ) {
            return { done: true };
          }
          let o;
          if (n instanceof zs) {
            if (t.isAtStart) {
              this.position = ul._createBefore(n);
              return this._previous();
            }
            o = n.data[t.offset - 1];
          } else {
            o = n.getChild(t.offset - 1);
          }
          if (o instanceof Vc) {
            if (!this.shallow) {
              t = new ul(o, o.childCount);
              this.position = t;
              if (this.ignoreElementEnd) {
                return this._previous();
              } else {
                return this._formatReturnValue("elementEnd", o, e, t);
              }
            } else {
              t.offset--;
              this.position = t;
              return this._formatReturnValue("elementStart", o, e, t, 1);
            }
          } else if (o instanceof zs) {
            if (this.singleCharacters) {
              t = new ul(o, o.data.length);
              this.position = t;
              return this._previous();
            } else {
              let n = o.data.length;
              let i;
              if (o == this._boundaryStartParent) {
                const e = this.boundaries.start.offset;
                i = new js(o, e, o.data.length - e);
                n = i.data.length;
                t = ul._createBefore(i);
              } else {
                i = new js(o, 0, o.data.length);
                t.offset--;
              }
              this.position = t;
              return this._formatReturnValue("text", i, e, t, n);
            }
          } else if (typeof o == "string") {
            let o;
            if (!this.singleCharacters) {
              const e =
                n === this._boundaryStartParent
                  ? this.boundaries.start.offset
                  : 0;
              o = t.offset - e;
            } else {
              o = 1;
            }
            t.offset -= o;
            const i = new js(n, t.offset, o);
            this.position = t;
            return this._formatReturnValue("text", i, e, t, o);
          } else {
            t = ul._createBefore(n);
            this.position = t;
            return this._formatReturnValue("elementStart", n, e, t, 1);
          }
        }
        _formatReturnValue(t, e, n, o, i) {
          if (e instanceof js) {
            if (e.offsetInText + e.data.length == e.textNode.data.length) {
              if (
                this.direction == "forward" &&
                !(this.boundaries && this.boundaries.end.isEqual(this.position))
              ) {
                o = ul._createAfter(e.textNode);
                this.position = o;
              } else {
                n = ul._createAfter(e.textNode);
              }
            }
            if (e.offsetInText === 0) {
              if (
                this.direction == "backward" &&
                !(
                  this.boundaries &&
                  this.boundaries.start.isEqual(this.position)
                )
              ) {
                o = ul._createBefore(e.textNode);
                this.position = o;
              } else {
                n = ul._createBefore(e.textNode);
              }
            }
          }
          return {
            done: false,
            value: {
              type: t,
              item: e,
              previousPosition: n,
              nextPosition: o,
              length: i,
            },
          };
        }
      }
      class ul {
        constructor(t, e) {
          this.parent = t;
          this.offset = e;
        }
        get nodeAfter() {
          if (this.parent.is("$text")) {
            return null;
          }
          return this.parent.getChild(this.offset) || null;
        }
        get nodeBefore() {
          if (this.parent.is("$text")) {
            return null;
          }
          return this.parent.getChild(this.offset - 1) || null;
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          const t = this.parent.is("$text")
            ? this.parent.data.length
            : this.parent.childCount;
          return this.offset === t;
        }
        get root() {
          return this.parent.root;
        }
        get editableElement() {
          let t = this.parent;
          while (!(t instanceof al)) {
            if (t.parent) {
              t = t.parent;
            } else {
              return null;
            }
          }
          return t;
        }
        getShiftedBy(t) {
          const e = ul._createAt(this);
          const n = e.offset + t;
          e.offset = n < 0 ? 0 : n;
          return e;
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this;
          const n = new dl(e);
          n.skip(t);
          return n.position;
        }
        getAncestors() {
          if (this.parent.is("documentFragment")) {
            return [this.parent];
          } else {
            return this.parent.getAncestors({ includeSelf: true });
          }
        }
        getCommonAncestor(t) {
          const e = this.getAncestors();
          const n = t.getAncestors();
          let o = 0;
          while (e[o] == n[o] && e[o]) {
            o++;
          }
          return o === 0 ? null : e[o - 1];
        }
        is(t) {
          return t === "position" || t === "view:position";
        }
        isEqual(t) {
          return this.parent == t.parent && this.offset == t.offset;
        }
        isBefore(t) {
          return this.compareWith(t) == "before";
        }
        isAfter(t) {
          return this.compareWith(t) == "after";
        }
        compareWith(t) {
          if (this.root !== t.root) {
            return "different";
          }
          if (this.isEqual(t)) {
            return "same";
          }
          const e = this.parent.is("node") ? this.parent.getPath() : [];
          const n = t.parent.is("node") ? t.parent.getPath() : [];
          e.push(this.offset);
          n.push(t.offset);
          const o = Fs(e, n);
          switch (o) {
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return e[o] < n[o] ? "before" : "after";
          }
        }
        getWalker(t = {}) {
          t.startPosition = this;
          return new dl(t);
        }
        clone() {
          return new ul(this.parent, this.offset);
        }
        static _createAt(t, e) {
          if (t instanceof ul) {
            return new this(t.parent, t.offset);
          } else {
            const n = t;
            if (e == "end") {
              e = n.is("$text") ? n.data.length : n.childCount;
            } else if (e == "before") {
              return this._createBefore(n);
            } else if (e == "after") {
              return this._createAfter(n);
            } else if (e !== 0 && !e) {
              throw new ss["a"]("view-createpositionat-offset-required", n);
            }
            return new ul(n, e);
          }
        }
        static _createAfter(t) {
          if (t.is("$textProxy")) {
            return new ul(t.textNode, t.offsetInText + t.data.length);
          }
          if (!t.parent) {
            throw new ss["a"]("view-position-after-root", t, { root: t });
          }
          return new ul(t.parent, t.index + 1);
        }
        static _createBefore(t) {
          if (t.is("$textProxy")) {
            return new ul(t.textNode, t.offsetInText);
          }
          if (!t.parent) {
            throw new ss["a"]("view-position-before-root", t, { root: t });
          }
          return new ul(t.parent, t.index);
        }
      }
      class hl {
        constructor(t, e = null) {
          this.start = t.clone();
          this.end = e ? e.clone() : t.clone();
        }
        *[Symbol.iterator]() {
          yield* new dl({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return this.start.parent === this.end.parent;
        }
        get root() {
          return this.start.root;
        }
        getEnlarged() {
          let t = this.start.getLastMatchingPosition(fl, {
            direction: "backward",
          });
          let e = this.end.getLastMatchingPosition(fl);
          if (t.parent.is("$text") && t.isAtStart) {
            t = ul._createBefore(t.parent);
          }
          if (e.parent.is("$text") && e.isAtEnd) {
            e = ul._createAfter(e.parent);
          }
          return new hl(t, e);
        }
        getTrimmed() {
          let t = this.start.getLastMatchingPosition(fl);
          if (t.isAfter(this.end) || t.isEqual(this.end)) {
            return new hl(t, t);
          }
          let e = this.end.getLastMatchingPosition(fl, {
            direction: "backward",
          });
          const n = t.nodeAfter;
          const o = e.nodeBefore;
          if (n && n.is("$text")) {
            t = new ul(n, 0);
          }
          if (o && o.is("$text")) {
            e = new ul(o, o.data.length);
          }
          return new hl(t, e);
        }
        isEqual(t) {
          return (
            this == t ||
            (this.start.isEqual(t.start) && this.end.isEqual(t.end))
          );
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end);
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false;
          }
          const n =
            this.containsPosition(t.start) ||
            (e && this.start.isEqual(t.start));
          const o =
            this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
          return n && o;
        }
        getDifference(t) {
          const e = [];
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new hl(this.start, t.start));
            }
            if (this.containsPosition(t.end)) {
              e.push(new hl(t.end, this.end));
            }
          } else {
            e.push(this.clone());
          }
          return e;
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start;
            let n = this.end;
            if (this.containsPosition(t.start)) {
              e = t.start;
            }
            if (this.containsPosition(t.end)) {
              n = t.end;
            }
            return new hl(e, n);
          }
          return null;
        }
        getWalker(t = {}) {
          t.boundaries = this;
          return new dl(t);
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null;
          }
          let t = this.start.nodeAfter;
          let e = this.end.nodeBefore;
          if (
            this.start.parent.is("$text") &&
            this.start.isAtEnd &&
            this.start.parent.nextSibling
          ) {
            t = this.start.parent.nextSibling;
          }
          if (
            this.end.parent.is("$text") &&
            this.end.isAtStart &&
            this.end.parent.previousSibling
          ) {
            e = this.end.parent.previousSibling;
          }
          if (t && t.is("element") && t === e) {
            return t;
          }
          return null;
        }
        clone() {
          return new hl(this.start, this.end);
        }
        *getItems(t = {}) {
          t.boundaries = this;
          t.ignoreElementEnd = true;
          const e = new dl(t);
          for (const t of e) {
            yield t.item;
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this;
          const e = new dl(t);
          yield e.position;
          for (const t of e) {
            yield t.nextPosition;
          }
        }
        is(t) {
          return t === "range" || t === "view:range";
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start);
        }
        static _createFromParentsAndOffsets(t, e, n, o) {
          return new this(new ul(t, e), new ul(n, o));
        }
        static _createFromPositionAndShift(t, e) {
          const n = t;
          const o = t.getShiftedBy(e);
          return e > 0 ? new this(n, o) : new this(o, n);
        }
        static _createIn(t) {
          return this._createFromParentsAndOffsets(t, 0, t, t.childCount);
        }
        static _createOn(t) {
          const e = t.is("$textProxy") ? t.offsetSize : 1;
          return this._createFromPositionAndShift(ul._createBefore(t), e);
        }
      }
      function fl(t) {
        if (t.item.is("attributeElement") || t.item.is("uiElement")) {
          return true;
        }
        return false;
      }
      function gl(t) {
        let e = 0;
        for (const n of t) {
          e++;
        }
        return e;
      }
      class pl {
        constructor(t = null, e, n) {
          this._ranges = [];
          this._lastRangeBackward = false;
          this._isFake = false;
          this._fakeSelectionLabel = "";
          this.setTo(t, e, n);
        }
        get isFake() {
          return this._isFake;
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel;
        }
        get anchor() {
          if (!this._ranges.length) {
            return null;
          }
          const t = this._ranges[this._ranges.length - 1];
          const e = this._lastRangeBackward ? t.end : t.start;
          return e.clone();
        }
        get focus() {
          if (!this._ranges.length) {
            return null;
          }
          const t = this._ranges[this._ranges.length - 1];
          const e = this._lastRangeBackward ? t.start : t.end;
          return e.clone();
        }
        get isCollapsed() {
          return this.rangeCount === 1 && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        get editableElement() {
          if (this.anchor) {
            return this.anchor.editableElement;
          }
          return null;
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield t.clone();
          }
        }
        getFirstRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e;
            }
          }
          return t ? t.clone() : null;
        }
        getLastRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e;
            }
          }
          return t ? t.clone() : null;
        }
        getFirstPosition() {
          const t = this.getFirstRange();
          return t ? t.start.clone() : null;
        }
        getLastPosition() {
          const t = this.getLastRange();
          return t ? t.end.clone() : null;
        }
        isEqual(t) {
          if (this.isFake != t.isFake) {
            return false;
          }
          if (this.isFake && this.fakeSelectionLabel != t.fakeSelectionLabel) {
            return false;
          }
          if (this.rangeCount != t.rangeCount) {
            return false;
          } else if (this.rangeCount === 0) {
            return true;
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false;
          }
          for (const e of this._ranges) {
            let n = false;
            for (const o of t._ranges) {
              if (e.isEqual(o)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        isSimilar(t) {
          if (this.isBackward != t.isBackward) {
            return false;
          }
          const e = gl(this.getRanges());
          const n = gl(t.getRanges());
          if (e != n) {
            return false;
          }
          if (e == 0) {
            return true;
          }
          for (let e of this.getRanges()) {
            e = e.getTrimmed();
            let n = false;
            for (let o of t.getRanges()) {
              o = o.getTrimmed();
              if (e.start.isEqual(o.start) && e.end.isEqual(o.end)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null;
          }
          return this.getFirstRange().getContainedElement();
        }
        setTo(t, e, n) {
          if (t === null) {
            this._setRanges([]);
            this._setFakeOptions(e);
          } else if (t instanceof pl || t instanceof ml) {
            this._setRanges(t.getRanges(), t.isBackward);
            this._setFakeOptions({
              fake: t.isFake,
              label: t.fakeSelectionLabel,
            });
          } else if (t instanceof hl) {
            this._setRanges([t], e && e.backward);
            this._setFakeOptions(e);
          } else if (t instanceof ul) {
            this._setRanges([new hl(t)]);
            this._setFakeOptions(e);
          } else if (t instanceof Ls) {
            const o = !!n && !!n.backward;
            let i;
            if (e === undefined) {
              throw new ss["a"](
                "view-selection-setto-required-second-parameter",
                this
              );
            } else if (e == "in") {
              i = hl._createIn(t);
            } else if (e == "on") {
              i = hl._createOn(t);
            } else {
              i = new hl(ul._createAt(t, e));
            }
            this._setRanges([i], o);
            this._setFakeOptions(n);
          } else if (As(t)) {
            this._setRanges(t, e && e.backward);
            this._setFakeOptions(e);
          } else {
            throw new ss["a"]("view-selection-setto-not-selectable", this);
          }
          this.fire("change");
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new ss["a"]("view-selection-setfocus-no-ranges", this);
          }
          const n = ul._createAt(t, e);
          if (n.compareWith(this.focus) == "same") {
            return;
          }
          const o = this.anchor;
          this._ranges.pop();
          if (n.compareWith(o) == "before") {
            this._addRange(new hl(n, o), true);
          } else {
            this._addRange(new hl(o, n));
          }
          this.fire("change");
        }
        is(t) {
          return t === "selection" || t === "view:selection";
        }
        _setRanges(t, e = false) {
          t = Array.from(t);
          this._ranges = [];
          for (const e of t) {
            this._addRange(e);
          }
          this._lastRangeBackward = !!e;
        }
        _setFakeOptions(t = {}) {
          this._isFake = !!t.fake;
          this._fakeSelectionLabel = t.fake ? t.label || "" : "";
        }
        _addRange(t, e = false) {
          if (!(t instanceof hl)) {
            throw new ss["a"]("view-selection-add-range-not-range", this);
          }
          this._pushRange(t);
          this._lastRangeBackward = !!e;
        }
        _pushRange(t) {
          for (const e of this._ranges) {
            if (t.isIntersecting(e)) {
              throw new ss["a"]("view-selection-range-intersects", this, {
                addedRange: t,
                intersectingRange: e,
              });
            }
          }
          this._ranges.push(new hl(t.start, t.end));
        }
      }
      Cs(pl, ds);
      class ml {
        constructor(t = null, e, n) {
          this._selection = new pl();
          this._selection.delegate("change").to(this);
          this._selection.setTo(t, e, n);
        }
        get isFake() {
          return this._selection.isFake;
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get editableElement() {
          return this._selection.editableElement;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        *getRanges() {
          yield* this._selection.getRanges();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        isEqual(t) {
          return this._selection.isEqual(t);
        }
        isSimilar(t) {
          return this._selection.isSimilar(t);
        }
        is(t) {
          return (
            t === "selection" ||
            t == "documentSelection" ||
            t == "view:selection" ||
            t == "view:documentSelection"
          );
        }
        _setTo(t, e, n) {
          this._selection.setTo(t, e, n);
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e);
        }
      }
      Cs(ml, ds);
      class kl {
        constructor(t) {
          this.selection = new ml();
          this.roots = new vs({ idProperty: "rootName" });
          this.stylesProcessor = t;
          this.set("isReadOnly", false);
          this.set("isFocused", false);
          this.set("isComposing", false);
          this._postFixers = new Set();
        }
        getRoot(t = "main") {
          return this.roots.get(t);
        }
        registerPostFixer(t) {
          this._postFixers.add(t);
        }
        destroy() {
          this.roots.map((t) => t.destroy());
          this.stopListening();
        }
        _callPostFixers(t) {
          let e = false;
          do {
            for (const n of this._postFixers) {
              e = n(t);
              if (e) {
                break;
              }
            }
          } while (e);
        }
      }
      Cs(kl, Yc);
      const bl = 10;
      class wl extends Vc {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = _l;
          this._priority = bl;
          this._id = null;
          this._clonesGroup = null;
        }
        get priority() {
          return this._priority;
        }
        get id() {
          return this._id;
        }
        getElementsWithSameId() {
          if (this.id === null) {
            throw new ss["a"](
              "attribute-element-get-elements-with-same-id-no-id",
              this
            );
          }
          return new Set(this._clonesGroup);
        }
        is(t, e = null) {
          if (!e) {
            return (
              t === "attributeElement" ||
              t === "view:attributeElement" ||
              t === "element" ||
              t === "view:element" ||
              t === "node" ||
              t === "view:node"
            );
          } else {
            return (
              e === this.name &&
              (t === "attributeElement" ||
                t === "view:attributeElement" ||
                t === "element" ||
                t === "view:element")
            );
          }
        }
        isSimilar(t) {
          if (this.id !== null || t.id !== null) {
            return this.id === t.id;
          }
          return super.isSimilar(t) && this.priority == t.priority;
        }
        _clone(t) {
          const e = super._clone(t);
          e._priority = this._priority;
          e._id = this._id;
          return e;
        }
      }
      wl.DEFAULT_PRIORITY = bl;
      function _l() {
        if (Al(this)) {
          return null;
        }
        let t = this.parent;
        while (t && t.is("attributeElement")) {
          if (Al(t) > 1) {
            return null;
          }
          t = t.parent;
        }
        if (!t || Al(t) > 1) {
          return null;
        }
        return this.childCount;
      }
      function Al(t) {
        return Array.from(t.getChildren()).filter((t) => !t.is("uiElement"))
          .length;
      }
      class Cl extends Vc {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = vl;
        }
        is(t, e = null) {
          if (!e) {
            return (
              t === "emptyElement" ||
              t === "view:emptyElement" ||
              t === "element" ||
              t === "view:element" ||
              t === "node" ||
              t === "view:node"
            );
          } else {
            return (
              e === this.name &&
              (t === "emptyElement" ||
                t === "view:emptyElement" ||
                t === "element" ||
                t === "view:element")
            );
          }
        }
        _insertChild(t, e) {
          if (e && (e instanceof Ls || Array.from(e).length > 0)) {
            throw new ss["a"]("view-emptyelement-cannot-add", [this, e]);
          }
        }
      }
      function vl() {
        return null;
      }
      const yl = navigator.userAgent.toLowerCase();
      const xl = {
        isMac: Sl(yl),
        isGecko: Pl(yl),
        isSafari: Dl(yl),
        isAndroid: Tl(yl),
        isBlink: Bl(yl),
        features: { isRegExpUnicodePropertySupported: Il() },
      };
      var El = xl;
      function Sl(t) {
        return t.indexOf("macintosh") > -1;
      }
      function Pl(t) {
        return !!t.match(/gecko\/\d+/);
      }
      function Dl(t) {
        return t.indexOf(" applewebkit/") > -1 && t.indexOf("chrome") === -1;
      }
      function Tl(t) {
        return t.indexOf("android") > -1;
      }
      function Bl(t) {
        return t.indexOf("chrome/") > -1 && t.indexOf("edge/") < 0;
      }
      function Il() {
        let t = false;
        try {
          t = "".search(new RegExp("[\\p{L}]", "u")) === 0;
        } catch (t) {}
        return t;
      }
      const Ol = { "": "ctrl", "": "shift", "": "alt" };
      const Rl = { ctrl: "", shift: "", alt: "" };
      const Fl = Kl();
      function Nl(t) {
        let e;
        if (typeof t == "string") {
          e = Fl[t.toLowerCase()];
          if (!e) {
            throw new ss["a"]("keyboard-unknown-key", null, { key: t });
          }
        } else {
          e =
            t.keyCode +
            (t.altKey ? Fl.alt : 0) +
            (t.ctrlKey ? Fl.ctrl : 0) +
            (t.shiftKey ? Fl.shift : 0);
        }
        return e;
      }
      function Ml(t) {
        if (typeof t == "string") {
          t = ql(t);
        }
        return t
          .map((t) => (typeof t == "string" ? Nl(t) : t))
          .reduce((t, e) => e + t, 0);
      }
      function Vl(t) {
        if (!El.isMac) {
          return t;
        }
        return ql(t)
          .map((t) => Rl[t.toLowerCase()] || t)
          .reduce((t, e) => {
            if (t.slice(-1) in Ol) {
              return t + e;
            } else {
              return t + "+" + e;
            }
          });
      }
      function Ll(t) {
        return (
          t == Fl.arrowright ||
          t == Fl.arrowleft ||
          t == Fl.arrowup ||
          t == Fl.arrowdown
        );
      }
      function zl(t, e) {
        const n = e === "ltr";
        switch (t) {
          case Fl.arrowleft:
            return n ? "left" : "right";
          case Fl.arrowright:
            return n ? "right" : "left";
          case Fl.arrowup:
            return "up";
          case Fl.arrowdown:
            return "down";
        }
      }
      function jl(t, e) {
        const n = zl(t, e);
        return n === "down" || n === "right";
      }
      function Kl() {
        const t = {
          arrowleft: 37,
          arrowup: 38,
          arrowright: 39,
          arrowdown: 40,
          backspace: 8,
          delete: 46,
          enter: 13,
          space: 32,
          esc: 27,
          tab: 9,
          ctrl: 1114112,
          cmd: 1114112,
          shift: 2228224,
          alt: 4456448,
        };
        for (let e = 65; e <= 90; e++) {
          const n = String.fromCharCode(e);
          t[n.toLowerCase()] = e;
        }
        for (let e = 48; e <= 57; e++) {
          t[e - 48] = e;
        }
        for (let e = 112; e <= 123; e++) {
          t["f" + (e - 111)] = e;
        }
        return t;
      }
      function ql(t) {
        return t.split(/\s*\+\s*/);
      }
      class $l extends Vc {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = Gl;
        }
        is(t, e = null) {
          if (!e) {
            return (
              t === "uiElement" ||
              t === "view:uiElement" ||
              t === "element" ||
              t === "view:element" ||
              t === "node" ||
              t === "view:node"
            );
          } else {
            return (
              e === this.name &&
              (t === "uiElement" ||
                t === "view:uiElement" ||
                t === "element" ||
                t === "view:element")
            );
          }
        }
        _insertChild(t, e) {
          if (e && (e instanceof Ls || Array.from(e).length > 0)) {
            throw new ss["a"]("view-uielement-cannot-add", this);
          }
        }
        render(t) {
          return this.toDomElement(t);
        }
        toDomElement(t) {
          const e = t.createElement(this.name);
          for (const t of this.getAttributeKeys()) {
            e.setAttribute(t, this.getAttribute(t));
          }
          return e;
        }
      }
      function Wl(t) {
        t.document.on("keydown", (e, n) => Ul(e, n, t.domConverter));
      }
      function Gl() {
        return null;
      }
      function Ul(t, e, n) {
        if (e.keyCode == Fl.arrowright) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          const o = t.rangeCount == 1 && t.getRangeAt(0).collapsed;
          if (o || e.shiftKey) {
            const e = t.focusNode;
            const i = t.focusOffset;
            const r = n.domPositionToView(e, i);
            if (r === null) {
              return;
            }
            let s = false;
            const a = r.getLastMatchingPosition((t) => {
              if (t.item.is("uiElement")) {
                s = true;
              }
              if (t.item.is("uiElement") || t.item.is("attributeElement")) {
                return true;
              }
              return false;
            });
            if (s) {
              const e = n.viewPositionToDom(a);
              if (o) {
                t.collapse(e.parent, e.offset);
              } else {
                t.extend(e.parent, e.offset);
              }
            }
          }
        }
      }
      class Hl extends Vc {
        constructor(t, e, n, o) {
          super(t, e, n, o);
          this.getFillerOffset = Jl;
        }
        is(t, e = null) {
          if (!e) {
            return (
              t === "rawElement" ||
              t === "view:rawElement" ||
              t === this.name ||
              t === "view:" + this.name ||
              t === "element" ||
              t === "view:element" ||
              t === "node" ||
              t === "view:node"
            );
          } else {
            return (
              e === this.name &&
              (t === "rawElement" ||
                t === "view:rawElement" ||
                t === "element" ||
                t === "view:element")
            );
          }
        }
        _insertChild(t, e) {
          if (e && (e instanceof Ls || Array.from(e).length > 0)) {
            throw new ss["a"]("view-rawelement-cannot-add", [this, e]);
          }
        }
      }
      function Jl() {
        return null;
      }
      class Yl {
        constructor(t, e) {
          this.document = t;
          this._children = [];
          if (e) {
            this._insertChild(0, e);
          }
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        is(t) {
          return t === "documentFragment" || t === "view:documentFragment";
        }
        _appendChild(t) {
          return this._insertChild(this.childCount, t);
        }
        getChild(t) {
          return this._children[t];
        }
        getChildIndex(t) {
          return this._children.indexOf(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        _insertChild(t, e) {
          this._fireChange("children", this);
          let n = 0;
          const o = Ql(this.document, e);
          for (const e of o) {
            if (e.parent !== null) {
              e._remove();
            }
            e.parent = this;
            this._children.splice(t, 0, e);
            t++;
            n++;
          }
          return n;
        }
        _removeChildren(t, e = 1) {
          this._fireChange("children", this);
          for (let n = t; n < t + e; n++) {
            this._children[n].parent = null;
          }
          return this._children.splice(t, e);
        }
        _fireChange(t, e) {
          this.fire("change:" + t, e);
        }
      }
      Cs(Yl, ds);
      function Ql(t, e) {
        if (typeof e == "string") {
          return [new zs(t, e)];
        }
        if (!As(e)) {
          e = [e];
        }
        return Array.from(e).map((e) => {
          if (typeof e == "string") {
            return new zs(t, e);
          }
          if (e instanceof js) {
            return new zs(t, e.data);
          }
          return e;
        });
      }
      class Xl {
        constructor(t) {
          this.document = t;
          this._cloneGroups = new Map();
        }
        setSelection(t, e, n) {
          this.document.selection._setTo(t, e, n);
        }
        setSelectionFocus(t, e) {
          this.document.selection._setFocus(t, e);
        }
        createText(t) {
          return new zs(this.document, t);
        }
        createAttributeElement(t, e, n = {}) {
          const o = new wl(this.document, t, e);
          if (n.priority) {
            o._priority = n.priority;
          }
          if (n.id) {
            o._id = n.id;
          }
          return o;
        }
        createContainerElement(t, e) {
          return new Kc(this.document, t, e);
        }
        createEditableElement(t, e) {
          const n = new al(this.document, t, e);
          n._document = this.document;
          return n;
        }
        createEmptyElement(t, e) {
          return new Cl(this.document, t, e);
        }
        createUIElement(t, e, n) {
          const o = new $l(this.document, t, e);
          if (n) {
            o.render = n;
          }
          return o;
        }
        createRawElement(t, e, n) {
          const o = new Hl(this.document, t, e);
          o.render = n || (() => {});
          return o;
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e);
        }
        removeAttribute(t, e) {
          e._removeAttribute(t);
        }
        addClass(t, e) {
          e._addClass(t);
        }
        removeClass(t, e) {
          e._removeClass(t);
        }
        setStyle(t, e, n) {
          if (R(t) && n === undefined) {
            n = e;
          }
          n._setStyle(t, e);
        }
        removeStyle(t, e) {
          e._removeStyle(t);
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e);
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t);
        }
        breakAttributes(t) {
          if (t instanceof ul) {
            return this._breakAttributes(t);
          } else {
            return this._breakAttributesRange(t);
          }
        }
        breakContainer(t) {
          const e = t.parent;
          if (!e.is("containerElement")) {
            throw new ss["a"](
              "view-writer-break-non-container-element",
              this.document
            );
          }
          if (!e.parent) {
            throw new ss["a"]("view-writer-break-root", this.document);
          }
          if (t.isAtStart) {
            return ul._createBefore(e);
          } else if (!t.isAtEnd) {
            const n = e._clone(false);
            this.insert(ul._createAfter(e), n);
            const o = new hl(t, ul._createAt(e, "end"));
            const i = new ul(n, 0);
            this.move(o, i);
          }
          return ul._createAfter(e);
        }
        mergeAttributes(t) {
          const e = t.offset;
          const n = t.parent;
          if (n.is("$text")) {
            return t;
          }
          if (n.is("attributeElement") && n.childCount === 0) {
            const t = n.parent;
            const e = n.index;
            n._remove();
            this._removeFromClonedElementsGroup(n);
            return this.mergeAttributes(new ul(t, e));
          }
          const o = n.getChild(e - 1);
          const i = n.getChild(e);
          if (!o || !i) {
            return t;
          }
          if (o.is("$text") && i.is("$text")) {
            return id(o, i);
          } else if (
            o.is("attributeElement") &&
            i.is("attributeElement") &&
            o.isSimilar(i)
          ) {
            const t = o.childCount;
            o._appendChild(i.getChildren());
            i._remove();
            this._removeFromClonedElementsGroup(i);
            return this.mergeAttributes(new ul(o, t));
          }
          return t;
        }
        mergeContainers(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          if (
            !e ||
            !n ||
            !e.is("containerElement") ||
            !n.is("containerElement")
          ) {
            throw new ss["a"](
              "view-writer-merge-containers-invalid-position",
              this.document
            );
          }
          const o = e.getChild(e.childCount - 1);
          const i =
            o instanceof zs ? ul._createAt(o, "end") : ul._createAt(e, "end");
          this.move(hl._createIn(n), ul._createAt(e, "end"));
          this.remove(hl._createOn(n));
          return i;
        }
        insert(t, e) {
          e = As(e) ? [...e] : [e];
          rd(e, this.document);
          const n = td(t);
          if (!n) {
            throw new ss["a"](
              "view-writer-invalid-position-container",
              this.document
            );
          }
          const o = this._breakAttributes(t, true);
          const i = n._insertChild(o.offset, e);
          for (const t of e) {
            this._addToClonedElementsGroup(t);
          }
          const r = o.getShiftedBy(i);
          const s = this.mergeAttributes(o);
          if (i === 0) {
            return new hl(s, s);
          } else {
            if (!s.isEqual(o)) {
              r.offset--;
            }
            const t = this.mergeAttributes(r);
            return new hl(s, t);
          }
        }
        remove(t) {
          const e = t instanceof hl ? t : hl._createOn(t);
          cd(e, this.document);
          if (e.isCollapsed) {
            return new Yl(this.document);
          }
          const { start: n, end: o } = this._breakAttributesRange(e, true);
          const i = n.parent;
          const r = o.offset - n.offset;
          const s = i._removeChildren(n.offset, r);
          for (const t of s) {
            this._removeFromClonedElementsGroup(t);
          }
          const a = this.mergeAttributes(n);
          e.start = a;
          e.end = a.clone();
          return new Yl(this.document, s);
        }
        clear(t, e) {
          cd(t, this.document);
          const n = t.getWalker({
            direction: "backward",
            ignoreElementEnd: true,
          });
          for (const o of n) {
            const n = o.item;
            let i;
            if (n.is("element") && e.isSimilar(n)) {
              i = hl._createOn(n);
            } else if (!o.nextPosition.isAfter(t.start) && n.is("$textProxy")) {
              const t = n
                .getAncestors()
                .find((t) => t.is("element") && e.isSimilar(t));
              if (t) {
                i = hl._createIn(t);
              }
            }
            if (i) {
              if (i.end.isAfter(t.end)) {
                i.end = t.end;
              }
              if (i.start.isBefore(t.start)) {
                i.start = t.start;
              }
              this.remove(i);
            }
          }
        }
        move(t, e) {
          let n;
          if (e.isAfter(t.end)) {
            e = this._breakAttributes(e, true);
            const o = e.parent;
            const i = o.childCount;
            t = this._breakAttributesRange(t, true);
            n = this.remove(t);
            e.offset += o.childCount - i;
          } else {
            n = this.remove(t);
          }
          return this.insert(e, n);
        }
        wrap(t, e) {
          if (!(e instanceof wl)) {
            throw new ss["a"](
              "view-writer-wrap-invalid-attribute",
              this.document
            );
          }
          cd(t, this.document);
          if (!t.isCollapsed) {
            return this._wrapRange(t, e);
          } else {
            let n = t.start;
            if (n.parent.is("element") && !Zl(n.parent)) {
              n = n.getLastMatchingPosition((t) => t.item.is("uiElement"));
            }
            n = this._wrapPosition(n, e);
            const o = this.document.selection;
            if (o.isCollapsed && o.getFirstPosition().isEqual(t.start)) {
              this.setSelection(n);
            }
            return new hl(n);
          }
        }
        unwrap(t, e) {
          if (!(e instanceof wl)) {
            throw new ss["a"](
              "view-writer-unwrap-invalid-attribute",
              this.document
            );
          }
          cd(t, this.document);
          if (t.isCollapsed) {
            return t;
          }
          const { start: n, end: o } = this._breakAttributesRange(t, true);
          const i = n.parent;
          const r = this._unwrapChildren(i, n.offset, o.offset, e);
          const s = this.mergeAttributes(r.start);
          if (!s.isEqual(r.start)) {
            r.end.offset--;
          }
          const a = this.mergeAttributes(r.end);
          return new hl(s, a);
        }
        rename(t, e) {
          const n = new Kc(this.document, t, e.getAttributes());
          this.insert(ul._createAfter(e), n);
          this.move(hl._createIn(e), ul._createAt(n, 0));
          this.remove(hl._createOn(e));
          return n;
        }
        clearClonedElementsGroup(t) {
          this._cloneGroups.delete(t);
        }
        createPositionAt(t, e) {
          return ul._createAt(t, e);
        }
        createPositionAfter(t) {
          return ul._createAfter(t);
        }
        createPositionBefore(t) {
          return ul._createBefore(t);
        }
        createRange(t, e) {
          return new hl(t, e);
        }
        createRangeOn(t) {
          return hl._createOn(t);
        }
        createRangeIn(t) {
          return hl._createIn(t);
        }
        createSelection(t, e, n) {
          return new pl(t, e, n);
        }
        _wrapChildren(t, e, n, o) {
          let i = e;
          const r = [];
          while (i < n) {
            const e = t.getChild(i);
            const n = e.is("$text");
            const s = e.is("attributeElement");
            const a = e.is("emptyElement");
            const c = e.is("uiElement");
            const l = e.is("rawElement");
            if (s && this._wrapAttributeElement(o, e)) {
              r.push(new ul(t, i));
            } else if (n || a || c || l || (s && ed(o, e))) {
              const n = o._clone();
              e._remove();
              n._appendChild(e);
              t._insertChild(i, n);
              this._addToClonedElementsGroup(n);
              r.push(new ul(t, i));
            } else if (s) {
              this._wrapChildren(e, 0, e.childCount, o);
            }
            i++;
          }
          let s = 0;
          for (const t of r) {
            t.offset -= s;
            if (t.offset == e) {
              continue;
            }
            const o = this.mergeAttributes(t);
            if (!o.isEqual(t)) {
              s++;
              n--;
            }
          }
          return hl._createFromParentsAndOffsets(t, e, t, n);
        }
        _unwrapChildren(t, e, n, o) {
          let i = e;
          const r = [];
          while (i < n) {
            const e = t.getChild(i);
            if (!e.is("attributeElement")) {
              i++;
              continue;
            }
            if (e.isSimilar(o)) {
              const o = e.getChildren();
              const s = e.childCount;
              e._remove();
              t._insertChild(i, o);
              this._removeFromClonedElementsGroup(e);
              r.push(new ul(t, i), new ul(t, i + s));
              i += s;
              n += s - 1;
              continue;
            }
            if (this._unwrapAttributeElement(o, e)) {
              r.push(new ul(t, i), new ul(t, i + 1));
              i++;
              continue;
            }
            this._unwrapChildren(e, 0, e.childCount, o);
            i++;
          }
          let s = 0;
          for (const t of r) {
            t.offset -= s;
            if (t.offset == e || t.offset == n) {
              continue;
            }
            const o = this.mergeAttributes(t);
            if (!o.isEqual(t)) {
              s++;
              n--;
            }
          }
          return hl._createFromParentsAndOffsets(t, e, t, n);
        }
        _wrapRange(t, e) {
          const { start: n, end: o } = this._breakAttributesRange(t, true);
          const i = n.parent;
          const r = this._wrapChildren(i, n.offset, o.offset, e);
          const s = this.mergeAttributes(r.start);
          if (!s.isEqual(r.start)) {
            r.end.offset--;
          }
          const a = this.mergeAttributes(r.end);
          return new hl(s, a);
        }
        _wrapPosition(t, e) {
          if (e.isSimilar(t.parent)) {
            return nd(t.clone());
          }
          if (t.parent.is("$text")) {
            t = od(t);
          }
          const n = this.createAttributeElement();
          n._priority = Number.POSITIVE_INFINITY;
          n.isSimilar = () => false;
          t.parent._insertChild(t.offset, n);
          const o = new hl(t, t.getShiftedBy(1));
          this.wrap(o, e);
          const i = new ul(n.parent, n.index);
          n._remove();
          const r = i.nodeBefore;
          const s = i.nodeAfter;
          if (r instanceof zs && s instanceof zs) {
            return id(r, s);
          }
          return nd(i);
        }
        _wrapAttributeElement(t, e) {
          if (!ld(t, e)) {
            return false;
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false;
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            if (e.hasAttribute(n) && e.getAttribute(n) !== t.getAttribute(n)) {
              return false;
            }
          }
          for (const n of t.getStyleNames()) {
            if (e.hasStyle(n) && e.getStyle(n) !== t.getStyle(n)) {
              return false;
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            if (!e.hasAttribute(n)) {
              this.setAttribute(n, t.getAttribute(n), e);
            }
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n)) {
              this.setStyle(n, t.getStyle(n), e);
            }
          }
          for (const n of t.getClassNames()) {
            if (!e.hasClass(n)) {
              this.addClass(n, e);
            }
          }
          return true;
        }
        _unwrapAttributeElement(t, e) {
          if (!ld(t, e)) {
            return false;
          }
          if (t.name !== e.name || t.priority !== e.priority) {
            return false;
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            if (!e.hasAttribute(n) || e.getAttribute(n) !== t.getAttribute(n)) {
              return false;
            }
          }
          if (!e.hasClass(...t.getClassNames())) {
            return false;
          }
          for (const n of t.getStyleNames()) {
            if (!e.hasStyle(n) || e.getStyle(n) !== t.getStyle(n)) {
              return false;
            }
          }
          for (const n of t.getAttributeKeys()) {
            if (n === "class" || n === "style") {
              continue;
            }
            this.removeAttribute(n, e);
          }
          this.removeClass(Array.from(t.getClassNames()), e);
          this.removeStyle(Array.from(t.getStyleNames()), e);
          return true;
        }
        _breakAttributesRange(t, e = false) {
          const n = t.start;
          const o = t.end;
          cd(t, this.document);
          if (t.isCollapsed) {
            const n = this._breakAttributes(t.start, e);
            return new hl(n, n);
          }
          const i = this._breakAttributes(o, e);
          const r = i.parent.childCount;
          const s = this._breakAttributes(n, e);
          i.offset += i.parent.childCount - r;
          return new hl(s, i);
        }
        _breakAttributes(t, e = false) {
          const n = t.offset;
          const o = t.parent;
          if (t.parent.is("emptyElement")) {
            throw new ss["a"](
              "view-writer-cannot-break-empty-element",
              this.document
            );
          }
          if (t.parent.is("uiElement")) {
            throw new ss["a"](
              "view-writer-cannot-break-ui-element",
              this.document
            );
          }
          if (t.parent.is("rawElement")) {
            throw new ss["a"](
              "view-writer-cannot-break-raw-element",
              this.document
            );
          }
          if (!e && o.is("$text") && ad(o.parent)) {
            return t.clone();
          }
          if (ad(o)) {
            return t.clone();
          }
          if (o.is("$text")) {
            return this._breakAttributes(od(t), e);
          }
          const i = o.childCount;
          if (n == i) {
            const t = new ul(o.parent, o.index + 1);
            return this._breakAttributes(t, e);
          } else {
            if (n === 0) {
              const t = new ul(o.parent, o.index);
              return this._breakAttributes(t, e);
            } else {
              const t = o.index + 1;
              const i = o._clone();
              o.parent._insertChild(t, i);
              this._addToClonedElementsGroup(i);
              const r = o.childCount - n;
              const s = o._removeChildren(n, r);
              i._appendChild(s);
              const a = new ul(o.parent, t);
              return this._breakAttributes(a, e);
            }
          }
        }
        _addToClonedElementsGroup(t) {
          if (!t.root.is("rootElement")) {
            return;
          }
          if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._addToClonedElementsGroup(e);
            }
          }
          const e = t.id;
          if (!e) {
            return;
          }
          let n = this._cloneGroups.get(e);
          if (!n) {
            n = new Set();
            this._cloneGroups.set(e, n);
          }
          n.add(t);
          t._clonesGroup = n;
        }
        _removeFromClonedElementsGroup(t) {
          if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._removeFromClonedElementsGroup(e);
            }
          }
          const e = t.id;
          if (!e) {
            return;
          }
          const n = this._cloneGroups.get(e);
          if (!n) {
            return;
          }
          n.delete(t);
        }
      }
      function Zl(t) {
        return Array.from(t.getChildren()).some((t) => !t.is("uiElement"));
      }
      function td(t) {
        let e = t.parent;
        while (!ad(e)) {
          if (!e) {
            return undefined;
          }
          e = e.parent;
        }
        return e;
      }
      function ed(t, e) {
        if (t.priority < e.priority) {
          return true;
        } else if (t.priority > e.priority) {
          return false;
        }
        return t.getIdentity() < e.getIdentity();
      }
      function nd(t) {
        const e = t.nodeBefore;
        if (e && e.is("$text")) {
          return new ul(e, e.data.length);
        }
        const n = t.nodeAfter;
        if (n && n.is("$text")) {
          return new ul(n, 0);
        }
        return t;
      }
      function od(t) {
        if (t.offset == t.parent.data.length) {
          return new ul(t.parent.parent, t.parent.index + 1);
        }
        if (t.offset === 0) {
          return new ul(t.parent.parent, t.parent.index);
        }
        const e = t.parent.data.slice(t.offset);
        t.parent._data = t.parent.data.slice(0, t.offset);
        t.parent.parent._insertChild(
          t.parent.index + 1,
          new zs(t.root.document, e)
        );
        return new ul(t.parent.parent, t.parent.index + 1);
      }
      function id(t, e) {
        const n = t.data.length;
        t._data += e.data;
        e._remove();
        return new ul(t, n);
      }
      function rd(t, e) {
        for (const n of t) {
          if (!sd.some((t) => n instanceof t)) {
            throw new ss["a"]("view-writer-insert-invalid-node-type", e);
          }
          if (!n.is("$text")) {
            rd(n.getChildren(), e);
          }
        }
      }
      const sd = [zs, wl, Kc, Cl, Hl, $l];
      function ad(t) {
        return t && (t.is("containerElement") || t.is("documentFragment"));
      }
      function cd(t, e) {
        const n = td(t.start);
        const o = td(t.end);
        if (!n || !o || n !== o) {
          throw new ss["a"]("view-writer-invalid-range-container", e);
        }
      }
      function ld(t, e) {
        return t.id === null && e.id === null;
      }
      function dd(t) {
        return Object.prototype.toString.call(t) == "[object Text]";
      }
      const ud = (t) => t.createTextNode("");
      const hd = (t) => {
        const e = t.createElement("br");
        // e.dataset.ckeFiller = true;
        return e;
      };
      const fd = 7;
      const gd = (() => {
        let t = "";
        for (let e = 0; e < fd; e++) {
          t += "";
        }
        return t;
      })();
      function pd(t) {
        return dd(t) && t.data.substr(0, fd) === gd;
      }
      function md(t) {
        return t.data.length == fd && pd(t);
      }
      function kd(t) {
        if (pd(t)) {
          return t.data.slice(fd);
        } else {
          return t.data;
        }
      }
      function bd(t) {
        t.document.on("keydown", wd);
      }
      function wd(t, e) {
        if (e.keyCode == Fl.arrowleft) {
          const t = e.domTarget.ownerDocument.defaultView.getSelection();
          if (t.rangeCount == 1 && t.getRangeAt(0).collapsed) {
            const e = t.getRangeAt(0).startContainer;
            const n = t.getRangeAt(0).startOffset;
            if (pd(e) && n <= fd) {
              t.collapse(e, 0);
            }
          }
        }
      }
      function _d(t, e, n, o = false) {
        n =
          n ||
          function (t, e) {
            return t === e;
          };
        if (!Array.isArray(t)) {
          t = Array.prototype.slice.call(t);
        }
        if (!Array.isArray(e)) {
          e = Array.prototype.slice.call(e);
        }
        const i = Ad(t, e, n);
        return o ? xd(i, e.length) : yd(e, i);
      }
      function Ad(t, e, n) {
        const o = Cd(t, e, n);
        if (o === -1) {
          return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
        }
        const i = vd(t, o);
        const r = vd(e, o);
        const s = Cd(i, r, n);
        const a = t.length - s;
        const c = e.length - s;
        return { firstIndex: o, lastIndexOld: a, lastIndexNew: c };
      }
      function Cd(t, e, n) {
        for (let o = 0; o < Math.max(t.length, e.length); o++) {
          if (t[o] === undefined || e[o] === undefined || !n(t[o], e[o])) {
            return o;
          }
        }
        return -1;
      }
      function vd(t, e) {
        return t.slice(e).reverse();
      }
      function yd(t, e) {
        const n = [];
        const { firstIndex: o, lastIndexOld: i, lastIndexNew: r } = e;
        if (r - o > 0) {
          n.push({ index: o, type: "insert", values: t.slice(o, r) });
        }
        if (i - o > 0) {
          n.push({ index: o + (r - o), type: "delete", howMany: i - o });
        }
        return n;
      }
      function xd(t, e) {
        const { firstIndex: n, lastIndexOld: o, lastIndexNew: i } = t;
        if (n === -1) {
          return Array(e).fill("equal");
        }
        let r = [];
        if (n > 0) {
          r = r.concat(Array(n).fill("equal"));
        }
        if (i - n > 0) {
          r = r.concat(Array(i - n).fill("insert"));
        }
        if (o - n > 0) {
          r = r.concat(Array(o - n).fill("delete"));
        }
        if (i < e) {
          r = r.concat(Array(e - i).fill("equal"));
        }
        return r;
      }
      function Ed(t, e, n) {
        n =
          n ||
          function (t, e) {
            return t === e;
          };
        const o = t.length;
        const i = e.length;
        if (o > 200 || i > 200 || o + i > 300) {
          return Ed.fastDiff(t, e, n, true);
        }
        let r, s;
        if (i < o) {
          const n = t;
          t = e;
          e = n;
          r = "delete";
          s = "insert";
        } else {
          r = "insert";
          s = "delete";
        }
        const a = t.length;
        const c = e.length;
        const l = c - a;
        const d = {};
        const u = {};
        function h(o) {
          const i = (u[o - 1] !== undefined ? u[o - 1] : -1) + 1;
          const l = u[o + 1] !== undefined ? u[o + 1] : -1;
          const h = i > l ? -1 : 1;
          if (d[o + h]) {
            d[o] = d[o + h].slice(0);
          }
          if (!d[o]) {
            d[o] = [];
          }
          d[o].push(i > l ? r : s);
          let f = Math.max(i, l);
          let g = f - o;
          while (g < a && f < c && n(t[g], e[f])) {
            g++;
            f++;
            d[o].push("equal");
          }
          return f;
        }
        let f = 0;
        let g;
        do {
          for (g = -f; g < l; g++) {
            u[g] = h(g);
          }
          for (g = l + f; g > l; g--) {
            u[g] = h(g);
          }
          u[l] = h(l);
          f++;
        } while (u[l] !== c);
        return d[l].slice(1);
      }
      Ed.fastDiff = _d;
      function Sd(t, e, n) {
        t.insertBefore(n, t.childNodes[e] || null);
      }
      function Pd(t) {
        const e = t.parentNode;
        if (e) {
          e.removeChild(t);
        }
      }
      function Dd(t) {
        if (t) {
          if (t.defaultView) {
            return t instanceof t.defaultView.Document;
          } else if (t.ownerDocument && t.ownerDocument.defaultView) {
            return t instanceof t.ownerDocument.defaultView.Node;
          }
        }
        return false;
      }
      class Td {
        constructor(t, e) {
          this.domDocuments = new Set();
          this.domConverter = t;
          this.markedAttributes = new Set();
          this.markedChildren = new Set();
          this.markedTexts = new Set();
          this.selection = e;
          this.isFocused = false;
          this._inlineFiller = null;
          this._fakeSelectionContainer = null;
        }
        markToSync(t, e) {
          if (t === "text") {
            if (this.domConverter.mapViewToDom(e.parent)) {
              this.markedTexts.add(e);
            }
          } else {
            if (!this.domConverter.mapViewToDom(e)) {
              return;
            }
            if (t === "attributes") {
              this.markedAttributes.add(e);
            } else if (t === "children") {
              this.markedChildren.add(e);
            } else {
              throw new ss["a"]("view-renderer-unknown-type", this);
            }
          }
        }
        render() {
          let t;
          for (const t of this.markedChildren) {
            this._updateChildrenMappings(t);
          }
          if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
            this._removeInlineFiller();
          }
          if (this._inlineFiller) {
            t = this._getInlineFillerPosition();
          } else if (this._needsInlineFillerAtSelection()) {
            t = this.selection.getFirstPosition();
            this.markedChildren.add(t.parent);
          }
          for (const t of this.markedAttributes) {
            this._updateAttrs(t);
          }
          for (const e of this.markedChildren) {
            this._updateChildren(e, { inlineFillerPosition: t });
          }
          for (const e of this.markedTexts) {
            if (
              !this.markedChildren.has(e.parent) &&
              this.domConverter.mapViewToDom(e.parent)
            ) {
              this._updateText(e, { inlineFillerPosition: t });
            }
          }
          if (t) {
            const e = this.domConverter.viewPositionToDom(t);
            const n = e.parent.ownerDocument;
            if (!pd(e.parent)) {
              this._inlineFiller = Id(n, e.parent, e.offset);
            } else {
              this._inlineFiller = e.parent;
            }
          } else {
            this._inlineFiller = null;
          }
          this._updateSelection();
          this._updateFocus();
          this.markedTexts.clear();
          this.markedAttributes.clear();
          this.markedChildren.clear();
        }
        _updateChildrenMappings(t) {
          const e = this.domConverter.mapViewToDom(t);
          if (!e) {
            return;
          }
          const n = this.domConverter.mapViewToDom(t).childNodes;
          const o = Array.from(
            this.domConverter.viewChildrenToDom(t, e.ownerDocument, {
              withChildren: false,
            })
          );
          const i = this._diffNodeLists(n, o);
          const r = this._findReplaceActions(i, n, o);
          if (r.indexOf("replace") !== -1) {
            const e = { equal: 0, insert: 0, delete: 0 };
            for (const i of r) {
              if (i === "replace") {
                const i = e.equal + e.insert;
                const r = e.equal + e.delete;
                const s = t.getChild(i);
                if (s && !(s.is("uiElement") || s.is("rawElement"))) {
                  this._updateElementMappings(s, n[r]);
                }
                Pd(o[i]);
                e.equal++;
              } else {
                e[i]++;
              }
            }
          }
        }
        _updateElementMappings(t, e) {
          this.domConverter.unbindDomElement(e);
          this.domConverter.bindElements(e, t);
          this.markedChildren.add(t);
          this.markedAttributes.add(t);
        }
        _getInlineFillerPosition() {
          const t = this.selection.getFirstPosition();
          if (t.parent.is("$text")) {
            return ul._createBefore(this.selection.getFirstPosition().parent);
          } else {
            return t;
          }
        }
        _isSelectionInInlineFiller() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false;
          }
          const t = this.selection.getFirstPosition();
          const e = this.domConverter.viewPositionToDom(t);
          if (e && dd(e.parent) && pd(e.parent)) {
            return true;
          }
          return false;
        }
        _removeInlineFiller() {
          const t = this._inlineFiller;
          if (!pd(t)) {
            throw new ss["a"]("view-renderer-filler-was-lost", this);
          }
          if (md(t)) {
            t.parentNode.removeChild(t);
          } else {
            t.data = t.data.substr(fd);
          }
          this._inlineFiller = null;
        }
        _needsInlineFillerAtSelection() {
          if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
            return false;
          }
          const t = this.selection.getFirstPosition();
          const e = t.parent;
          const n = t.offset;
          if (!this.domConverter.mapViewToDom(e.root)) {
            return false;
          }
          if (!e.is("element")) {
            return false;
          }
          if (!Bd(e)) {
            return false;
          }
          if (n === e.getFillerOffset()) {
            return false;
          }
          const o = t.nodeBefore;
          const i = t.nodeAfter;
          if (o instanceof zs || i instanceof zs) {
            return false;
          }
          return true;
        }
        _updateText(t, e) {
          const n = this.domConverter.findCorrespondingDomText(t);
          const o = this.domConverter.viewToDom(t, n.ownerDocument);
          const i = n.data;
          let r = o.data;
          const s = e.inlineFillerPosition;
          if (s && s.parent == t.parent && s.offset == t.index) {
            r = gd + r;
          }
          if (i != r) {
            const t = _d(i, r);
            for (const e of t) {
              if (e.type === "insert") {
                n.insertData(e.index, e.values.join(""));
              } else {
                n.deleteData(e.index, e.howMany);
              }
            }
          }
        }
        _updateAttrs(t) {
          const e = this.domConverter.mapViewToDom(t);
          if (!e) {
            return;
          }
          const n = Array.from(e.attributes).map((t) => t.name);
          const o = t.getAttributeKeys();
          for (const n of o) {
            e.setAttribute(n, t.getAttribute(n));
          }
          for (const o of n) {
            if (!t.hasAttribute(o)) {
              e.removeAttribute(o);
            }
          }
        }
        _updateChildren(t, e) {
          const n = this.domConverter.mapViewToDom(t);
          if (!n) {
            return;
          }
          const o = e.inlineFillerPosition;
          const i = this.domConverter.mapViewToDom(t).childNodes;
          const r = Array.from(
            this.domConverter.viewChildrenToDom(t, n.ownerDocument, {
              bind: true,
              inlineFillerPosition: o,
            })
          );
          if (o && o.parent === t) {
            Id(n.ownerDocument, r, o.offset);
          }
          const s = this._diffNodeLists(i, r);
          let a = 0;
          const c = new Set();
          for (const t of s) {
            if (t === "delete") {
              c.add(i[a]);
              Pd(i[a]);
            } else if (t === "equal") {
              a++;
            }
          }
          a = 0;
          for (const t of s) {
            if (t === "insert") {
              Sd(n, a, r[a]);
              a++;
            } else if (t === "equal") {
              this._markDescendantTextToSync(this.domConverter.domToView(r[a]));
              a++;
            }
          }
          for (const t of c) {
            if (!t.parentNode) {
              this.domConverter.unbindDomElement(t);
            }
          }
        }
        _diffNodeLists(t, e) {
          t = Nd(t, this._fakeSelectionContainer);
          return Ed(t, e, Rd.bind(null, this.domConverter));
        }
        _findReplaceActions(t, e, n) {
          if (t.indexOf("insert") === -1 || t.indexOf("delete") === -1) {
            return t;
          }
          let o = [];
          let i = [];
          let r = [];
          const s = { equal: 0, insert: 0, delete: 0 };
          for (const a of t) {
            if (a === "insert") {
              r.push(n[s.equal + s.insert]);
            } else if (a === "delete") {
              i.push(e[s.equal + s.delete]);
            } else {
              o = o.concat(
                Ed(i, r, Od).map((t) => (t === "equal" ? "replace" : t))
              );
              o.push("equal");
              i = [];
              r = [];
            }
            s[a]++;
          }
          return o.concat(
            Ed(i, r, Od).map((t) => (t === "equal" ? "replace" : t))
          );
        }
        _markDescendantTextToSync(t) {
          if (!t) {
            return;
          }
          if (t.is("$text")) {
            this.markedTexts.add(t);
          } else if (t.is("element")) {
            for (const e of t.getChildren()) {
              this._markDescendantTextToSync(e);
            }
          }
        }
        _updateSelection() {
          if (this.selection.rangeCount === 0) {
            this._removeDomSelection();
            this._removeFakeSelection();
            return;
          }
          const t = this.domConverter.mapViewToDom(
            this.selection.editableElement
          );
          if (!this.isFocused || !t) {
            return;
          }
          if (this.selection.isFake) {
            this._updateFakeSelection(t);
          } else {
            this._removeFakeSelection();
            this._updateDomSelection(t);
          }
        }
        _updateFakeSelection(t) {
          const e = t.ownerDocument;
          if (!this._fakeSelectionContainer) {
            this._fakeSelectionContainer = Md(e);
          }
          const n = this._fakeSelectionContainer;
          this.domConverter.bindFakeSelection(n, this.selection);
          if (!this._fakeSelectionNeedsUpdate(t)) {
            return;
          }
          if (!n.parentElement || n.parentElement != t) {
            t.appendChild(n);
          }
          n.textContent = this.selection.fakeSelectionLabel || "";
          const o = e.getSelection();
          const i = e.createRange();
          o.removeAllRanges();
          i.selectNodeContents(n);
          o.addRange(i);
        }
        _updateDomSelection(t) {
          const e = t.ownerDocument.defaultView.getSelection();
          if (!this._domSelectionNeedsUpdate(e)) {
            return;
          }
          const n = this.domConverter.viewPositionToDom(this.selection.anchor);
          const o = this.domConverter.viewPositionToDom(this.selection.focus);
          t.focus();
          e.collapse(n.parent, n.offset);
          e.extend(o.parent, o.offset);
          if (El.isGecko) {
            Fd(o, e);
          }
        }
        _domSelectionNeedsUpdate(t) {
          if (!this.domConverter.isDomSelectionCorrect(t)) {
            return true;
          }
          const e = t && this.domConverter.domSelectionToView(t);
          if (e && this.selection.isEqual(e)) {
            return false;
          }
          if (!this.selection.isCollapsed && this.selection.isSimilar(e)) {
            return false;
          }
          return true;
        }
        _fakeSelectionNeedsUpdate(t) {
          const e = this._fakeSelectionContainer;
          const n = t.ownerDocument.getSelection();
          if (!e || e.parentElement !== t) {
            return true;
          }
          if (n.anchorNode !== e && !e.contains(n.anchorNode)) {
            return true;
          }
          return e.textContent !== this.selection.fakeSelectionLabel;
        }
        _removeDomSelection() {
          for (const t of this.domDocuments) {
            const e = t.getSelection();
            if (e.rangeCount) {
              const e = t.activeElement;
              const n = this.domConverter.mapDomToView(e);
              if (e && n) {
                t.getSelection().removeAllRanges();
              }
            }
          }
        }
        _removeFakeSelection() {
          const t = this._fakeSelectionContainer;
          if (t) {
            t.remove();
          }
        }
        _updateFocus() {
          if (this.isFocused) {
            const t = this.selection.editableElement;
            if (t) {
              this.domConverter.focus(t);
            }
          }
        }
      }
      Cs(Td, Yc);
      function Bd(t) {
        if (t.getAttribute("contenteditable") == "false") {
          return false;
        }
        const e = t.findAncestor((t) => t.hasAttribute("contenteditable"));
        return !e || e.getAttribute("contenteditable") == "true";
      }
      function Id(t, e, n) {
        const o = e instanceof Array ? e : e.childNodes;
        const i = o[n];
        if (dd(i)) {
          i.data = gd + i.data;
          return i;
        } else {
          const i = t.createTextNode(gd);
          if (Array.isArray(e)) {
            o.splice(n, 0, i);
          } else {
            Sd(e, n, i);
          }
          return i;
        }
      }
      function Od(t, e) {
        return (
          Dd(t) &&
          Dd(e) &&
          !dd(t) &&
          !dd(e) &&
          t.nodeType !== Node.COMMENT_NODE &&
          e.nodeType !== Node.COMMENT_NODE &&
          t.tagName.toLowerCase() === e.tagName.toLowerCase()
        );
      }
      function Rd(t, e, n) {
        if (e === n) {
          return true;
        } else if (dd(e) && dd(n)) {
          return e.data === n.data;
        } else if (t.isBlockFiller(e) && t.isBlockFiller(n)) {
          return true;
        }
        return false;
      }
      function Fd(t, e) {
        const n = t.parent;
        if (
          n.nodeType != Node.ELEMENT_NODE ||
          t.offset != n.childNodes.length - 1
        ) {
          return;
        }
        const o = n.childNodes[t.offset];
        if (o && o.tagName == "BR") {
          e.addRange(e.getRangeAt(0));
        }
      }
      function Nd(t, e) {
        const n = Array.from(t);
        if (n.length == 0 || !e) {
          return n;
        }
        const o = n[n.length - 1];
        if (o == e) {
          n.pop();
        }
        return n;
      }
      function Md(t) {
        const e = t.createElement("div");
        Object.assign(e.style, {
          position: "fixed",
          top: 0,
          left: "-9999px",
          width: "42px",
        });
        e.textContent = "";
        return e;
      }
      var Vd = { window: window, document: document };
      function Ld(t) {
        let e = 0;
        while (t.previousSibling) {
          t = t.previousSibling;
          e++;
        }
        return e;
      }
      function zd(t) {
        const e = [];
        while (t && t.nodeType != Node.DOCUMENT_NODE) {
          e.unshift(t);
          t = t.parentNode;
        }
        return e;
      }
      function jd(t, e) {
        const n = zd(t);
        const o = zd(e);
        let i = 0;
        while (n[i] == o[i] && n[i]) {
          i++;
        }
        return i === 0 ? null : n[i - 1];
      }
      const Kd = hd(document);
      class qd {
        constructor(t, e = {}) {
          this.document = t;
          this.blockFillerMode = e.blockFillerMode || "br";
          this.preElements = ["pre"];
          this.blockElements = [
            "p",
            "div",
            "h1",
            "h2",
            "h3",
            "h4",
            "h5",
            "h6",
            "li",
            "dd",
            "dt",
            "figcaption",
            "td",
            "th",
          ];
          this._blockFiller = this.blockFillerMode == "br" ? hd : ud;
          this._domToViewMapping = new WeakMap();
          this._viewToDomMapping = new WeakMap();
          this._fakeSelectionMapping = new WeakMap();
        }
        bindFakeSelection(t, e) {
          this._fakeSelectionMapping.set(t, new pl(e));
        }
        fakeSelectionToView(t) {
          return this._fakeSelectionMapping.get(t);
        }
        bindElements(t, e) {
          this._domToViewMapping.set(t, e);
          this._viewToDomMapping.set(e, t);
        }
        unbindDomElement(t) {
          const e = this._domToViewMapping.get(t);
          if (e) {
            this._domToViewMapping.delete(t);
            this._viewToDomMapping.delete(e);
            for (const e of t.childNodes) {
              this.unbindDomElement(e);
            }
          }
        }
        bindDocumentFragments(t, e) {
          this._domToViewMapping.set(t, e);
          this._viewToDomMapping.set(e, t);
        }
        viewToDom(t, e, n = {}) {
          if (t.is("$text")) {
            const n = this._processDataFromViewText(t);
            return e.createTextNode(n);
          } else {
            if (this.mapViewToDom(t)) {
              return this.mapViewToDom(t);
            }
            let o;
            if (t.is("documentFragment")) {
              o = e.createDocumentFragment();
              if (n.bind) {
                this.bindDocumentFragments(o, t);
              }
            } else if (t.is("uiElement")) {
              o = t.render(e);
              if (n.bind) {
                this.bindElements(o, t);
              }
              return o;
            } else {
              if (t.hasAttribute("xmlns")) {
                o = e.createElementNS(t.getAttribute("xmlns"), t.name);
              } else {
                o = e.createElement(t.name);
              }
              if (t.is("rawElement")) {
                t.render(o);
              }
              if (n.bind) {
                this.bindElements(o, t);
              }
              for (const e of t.getAttributeKeys()) {
                o.setAttribute(e, t.getAttribute(e));
              }
            }
            if (n.withChildren || n.withChildren === undefined) {
              for (const i of this.viewChildrenToDom(t, e, n)) {
                o.appendChild(i);
              }
            }
            return o;
          }
        }
        *viewChildrenToDom(t, e, n = {}) {
          const o = t.getFillerOffset && t.getFillerOffset();
          let i = 0;
          for (const r of t.getChildren()) {
            if (o === i) {
              yield this._blockFiller(e);
            }
            yield this.viewToDom(r, e, n);
            i++;
          }
          if (o === i) {
            yield this._blockFiller(e);
          }
        }
        viewRangeToDom(t) {
          const e = this.viewPositionToDom(t.start);
          const n = this.viewPositionToDom(t.end);
          const o = document.createRange();
          o.setStart(e.parent, e.offset);
          o.setEnd(n.parent, n.offset);
          return o;
        }
        viewPositionToDom(t) {
          const e = t.parent;
          if (e.is("$text")) {
            const n = this.findCorrespondingDomText(e);
            if (!n) {
              return null;
            }
            let o = t.offset;
            if (pd(n)) {
              o += fd;
            }
            return { parent: n, offset: o };
          } else {
            let n, o, i;
            if (t.offset === 0) {
              n = this.mapViewToDom(e);
              if (!n) {
                return null;
              }
              i = n.childNodes[0];
            } else {
              const e = t.nodeBefore;
              o = e.is("$text")
                ? this.findCorrespondingDomText(e)
                : this.mapViewToDom(t.nodeBefore);
              if (!o) {
                return null;
              }
              n = o.parentNode;
              i = o.nextSibling;
            }
            if (dd(i) && pd(i)) {
              return { parent: i, offset: fd };
            }
            const r = o ? Ld(o) + 1 : 0;
            return { parent: n, offset: r };
          }
        }
        domToView(t, e = {}) {
          if (this.isBlockFiller(t, this.blockFillerMode)) {
            return null;
          }
          const n = this.getHostViewElement(t, this._domToViewMapping);
          if (n) {
            return n;
          }
          if (dd(t)) {
            if (md(t)) {
              return null;
            } else {
              const e = this._processDataFromDomText(t);
              return e === "" ? null : new zs(this.document, e);
            }
          } else if (this.isComment(t)) {
            return null;
          } else {
            if (this.mapDomToView(t)) {
              return this.mapDomToView(t);
            }
            let n;
            if (this.isDocumentFragment(t)) {
              n = new Yl(this.document);
              if (e.bind) {
                this.bindDocumentFragments(t, n);
              }
            } else {
              const o = e.keepOriginalCase
                ? t.tagName
                : t.tagName.toLowerCase();
              n = new Vc(this.document, o);
              if (e.bind) {
                this.bindElements(t, n);
              }
              const i = t.attributes;
              for (let t = i.length - 1; t >= 0; t--) {
                n._setAttribute(i[t].name, i[t].value);
              }
            }
            if (e.withChildren || e.withChildren === undefined) {
              for (const o of this.domChildrenToView(t, e)) {
                n._appendChild(o);
              }
            }
            return n;
          }
        }
        *domChildrenToView(t, e = {}) {
          for (let n = 0; n < t.childNodes.length; n++) {
            const o = t.childNodes[n];
            const i = this.domToView(o, e);
            if (i !== null) {
              yield i;
            }
          }
        }
        domSelectionToView(t) {
          if (t.rangeCount === 1) {
            let e = t.getRangeAt(0).startContainer;
            if (dd(e)) {
              e = e.parentNode;
            }
            const n = this.fakeSelectionToView(e);
            if (n) {
              return n;
            }
          }
          const e = this.isDomSelectionBackward(t);
          const n = [];
          for (let e = 0; e < t.rangeCount; e++) {
            const o = t.getRangeAt(e);
            const i = this.domRangeToView(o);
            if (i) {
              n.push(i);
            }
          }
          return new pl(n, { backward: e });
        }
        domRangeToView(t) {
          const e = this.domPositionToView(t.startContainer, t.startOffset);
          const n = this.domPositionToView(t.endContainer, t.endOffset);
          if (e && n) {
            return new hl(e, n);
          }
          return null;
        }
        domPositionToView(t, e) {
          if (this.isBlockFiller(t, this.blockFillerMode)) {
            return this.domPositionToView(t.parentNode, Ld(t));
          }
          const n = this.mapDomToView(t);
          if (n && (n.is("uiElement") || n.is("rawElement"))) {
            return ul._createBefore(n);
          }
          if (dd(t)) {
            if (md(t)) {
              return this.domPositionToView(t.parentNode, Ld(t));
            }
            const n = this.findCorrespondingViewText(t);
            let o = e;
            if (!n) {
              return null;
            }
            if (pd(t)) {
              o -= fd;
              o = o < 0 ? 0 : o;
            }
            return new ul(n, o);
          } else {
            if (e === 0) {
              const e = this.mapDomToView(t);
              if (e) {
                return new ul(e, 0);
              }
            } else {
              const n = t.childNodes[e - 1];
              const o = dd(n)
                ? this.findCorrespondingViewText(n)
                : this.mapDomToView(n);
              if (o && o.parent) {
                return new ul(o.parent, o.index + 1);
              }
            }
            return null;
          }
        }
        mapDomToView(t) {
          const e = this.getHostViewElement(t);
          return e || this._domToViewMapping.get(t);
        }
        findCorrespondingViewText(t) {
          if (md(t)) {
            return null;
          }
          const e = this.getHostViewElement(t);
          if (e) {
            return e;
          }
          const n = t.previousSibling;
          if (n) {
            if (!this.isElement(n)) {
              return null;
            }
            const t = this.mapDomToView(n);
            if (t) {
              const e = t.nextSibling;
              if (e instanceof zs) {
                return t.nextSibling;
              } else {
                return null;
              }
            }
          } else {
            const e = this.mapDomToView(t.parentNode);
            if (e) {
              const t = e.getChild(0);
              if (t instanceof zs) {
                return t;
              } else {
                return null;
              }
            }
          }
          return null;
        }
        mapViewToDom(t) {
          return this._viewToDomMapping.get(t);
        }
        findCorrespondingDomText(t) {
          const e = t.previousSibling;
          if (e && this.mapViewToDom(e)) {
            return this.mapViewToDom(e).nextSibling;
          }
          if (!e && t.parent && this.mapViewToDom(t.parent)) {
            return this.mapViewToDom(t.parent).childNodes[0];
          }
          return null;
        }
        focus(t) {
          const e = this.mapViewToDom(t);
          if (e && e.ownerDocument.activeElement !== e) {
            const { scrollX: t, scrollY: n } = Vd.window;
            const o = [];
            Wd(e, (t) => {
              const { scrollLeft: e, scrollTop: n } = t;
              o.push([e, n]);
            });
            e.focus();
            Wd(e, (t) => {
              const [e, n] = o.shift();
              t.scrollLeft = e;
              t.scrollTop = n;
            });
            Vd.window.scrollTo(t, n);
          }
        }
        isElement(t) {
          return t && t.nodeType == Node.ELEMENT_NODE;
        }
        isDocumentFragment(t) {
          return t && t.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
        }
        isComment(t) {
          return t && t.nodeType == Node.COMMENT_NODE;
        }
        isBlockFiller(t) {
          if (this.blockFillerMode == "br") {
            return t.isEqualNode(Kd);
          }
          if (
            t.tagName === "BR" &&
            Ud(t, this.blockElements) &&
            t.parentNode.childNodes.length === 1
          ) {
            return true;
          }
          return Gd(t, this.blockElements);
        }
        isDomSelectionBackward(t) {
          if (t.isCollapsed) {
            return false;
          }
          const e = document.createRange();
          e.setStart(t.anchorNode, t.anchorOffset);
          e.setEnd(t.focusNode, t.focusOffset);
          const n = e.collapsed;
          e.detach();
          return n;
        }
        getHostViewElement(t) {
          const e = zd(t);
          e.pop();
          while (e.length) {
            const t = e.pop();
            const n = this._domToViewMapping.get(t);
            if (n && (n.is("uiElement") || n.is("rawElement"))) {
              return n;
            }
          }
          return null;
        }
        isDomSelectionCorrect(t) {
          return (
            this._isDomSelectionPositionCorrect(t.anchorNode, t.anchorOffset) &&
            this._isDomSelectionPositionCorrect(t.focusNode, t.focusOffset)
          );
        }
        _isDomSelectionPositionCorrect(t, e) {
          if (dd(t) && pd(t) && e < fd) {
            return false;
          }
          if (this.isElement(t) && pd(t.childNodes[e])) {
            return false;
          }
          const n = this.mapDomToView(t);
          if (n && (n.is("uiElement") || n.is("rawElement"))) {
            return false;
          }
          return true;
        }
        _processDataFromViewText(t) {
          let e = t.data;
          if (t.getAncestors().some((t) => this.preElements.includes(t.name))) {
            return e;
          }
          if (e.charAt(0) == " ") {
            const n = this._getTouchingViewTextNode(t, false);
            const o = n && this._nodeEndsWithSpace(n);
            if (o || !n) {
              e = "" + e.substr(1);
            }
          }
          if (e.charAt(e.length - 1) == " ") {
            const n = this._getTouchingViewTextNode(t, true);
            if (
              e.charAt(e.length - 2) == " " ||
              !n ||
              n.data.charAt(0) == " "
            ) {
              e = e.substr(0, e.length - 1) + "";
            }
          }
          return e.replace(/ {2}/g, " ");
        }
        _nodeEndsWithSpace(t) {
          if (t.getAncestors().some((t) => this.preElements.includes(t.name))) {
            return false;
          }
          const e = this._processDataFromViewText(t);
          return e.charAt(e.length - 1) == " ";
        }
        _processDataFromDomText(t) {
          let e = t.data;
          if ($d(t, this.preElements)) {
            return kd(t);
          }
          e = e.replace(/[ \n\t\r]{1,}/g, " ");
          const n = this._getTouchingInlineDomNode(t, false);
          const o = this._getTouchingInlineDomNode(t, true);
          const i = this._checkShouldLeftTrimDomText(n);
          const r = this._checkShouldRightTrimDomText(t, o);
          if (i) {
            e = e.replace(/^ /, "");
          }
          if (r) {
            e = e.replace(/ $/, "");
          }
          e = kd(new Text(e));
          e = e.replace(/ \u00A0/g, "  ");
          if (
            /( |\u00A0)\u00A0$/.test(e) ||
            !o ||
            (o.data && o.data.charAt(0) == " ")
          ) {
            e = e.replace(/\u00A0$/, " ");
          }
          if (i) {
            e = e.replace(/^\u00A0/, " ");
          }
          return e;
        }
        _checkShouldLeftTrimDomText(t) {
          if (!t) {
            return true;
          }
          if (Hr(t)) {
            return true;
          }
          return /[^\S\u00A0]/.test(t.data.charAt(t.data.length - 1));
        }
        _checkShouldRightTrimDomText(t, e) {
          if (e) {
            return false;
          }
          return !pd(t);
        }
        _getTouchingViewTextNode(t, e) {
          const n = new dl({
            startPosition: e ? ul._createAfter(t) : ul._createBefore(t),
            direction: e ? "forward" : "backward",
          });
          for (const t of n) {
            if (t.item.is("containerElement")) {
              return null;
            } else if (t.item.is("element", "br")) {
              return null;
            } else if (t.item.is("$textProxy")) {
              return t.item;
            }
          }
          return null;
        }
        _getTouchingInlineDomNode(t, e) {
          if (!t.parentNode) {
            return null;
          }
          const n = e ? "nextNode" : "previousNode";
          const o = t.ownerDocument;
          const i = zd(t)[0];
          const r = o.createTreeWalker(
            i,
            NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT,
            {
              acceptNode(t) {
                if (dd(t)) {
                  return NodeFilter.FILTER_ACCEPT;
                }
                if (t.tagName == "BR") {
                  return NodeFilter.FILTER_ACCEPT;
                }
                return NodeFilter.FILTER_SKIP;
              },
            }
          );
          r.currentNode = t;
          const s = r[n]();
          if (s !== null) {
            const e = jd(t, s);
            if (
              e &&
              !$d(t, this.blockElements, e) &&
              !$d(s, this.blockElements, e)
            ) {
              return s;
            }
          }
          return null;
        }
      }
      function $d(t, e, n) {
        let o = zd(t);
        if (n) {
          o = o.slice(o.indexOf(n) + 1);
        }
        return o.some((t) => t.tagName && e.includes(t.tagName.toLowerCase()));
      }
      function Wd(t, e) {
        while (t && t != Vd.document) {
          e(t);
          t = t.parentNode;
        }
      }
      function Gd(t, e) {
        const n = dd(t) && t.data == "";
        return n && Ud(t, e) && t.parentNode.childNodes.length === 1;
      }
      function Ud(t, e) {
        const n = t.parentNode;
        return n && n.tagName && e.includes(n.tagName.toLowerCase());
      }
      function Hd(t) {
        const e = Object.prototype.toString.apply(t);
        if (e == "[object Window]") {
          return true;
        }
        if (e == "[object global]") {
          return true;
        }
        return false;
      }
      const Jd = Wc({}, ds, {
        listenTo(t, ...e) {
          if (Dd(t) || Hd(t)) {
            const n = this._getProxyEmitter(t) || new Qd(t);
            n.attach(...e);
            t = n;
          }
          ds.listenTo.call(this, t, ...e);
        },
        stopListening(t, e, n) {
          if (Dd(t) || Hd(t)) {
            const e = this._getProxyEmitter(t);
            if (!e) {
              return;
            }
            t = e;
          }
          ds.stopListening.call(this, t, e, n);
          if (t instanceof Qd) {
            t.detach(e);
          }
        },
        _getProxyEmitter(t) {
          return us(this, Xd(t));
        },
      });
      var Yd = Jd;
      class Qd {
        constructor(t) {
          hs(this, Xd(t));
          this._domNode = t;
        }
      }
      Wc(Qd.prototype, ds, {
        attach(t, e, n = {}) {
          if (this._domListeners && this._domListeners[t]) {
            return;
          }
          const o = { capture: !!n.useCapture, passive: !!n.usePassive };
          const i = this._createDomListener(t, o);
          this._domNode.addEventListener(t, i, o);
          if (!this._domListeners) {
            this._domListeners = {};
          }
          this._domListeners[t] = i;
        },
        detach(t) {
          let e;
          if (
            this._domListeners[t] &&
            (!(e = this._events[t]) || !e.callbacks.length)
          ) {
            this._domListeners[t].removeListener();
          }
        },
        _createDomListener(t, e) {
          const n = (e) => {
            this.fire(t, e);
          };
          n.removeListener = () => {
            this._domNode.removeEventListener(t, n, e);
            delete this._domListeners[t];
          };
          return n;
        },
      });
      function Xd(t) {
        return t["data-ck-expando"] || (t["data-ck-expando"] = ns());
      }
      class Zd {
        constructor(t) {
          this.view = t;
          this.document = t.document;
          this.isEnabled = false;
        }
        enable() {
          this.isEnabled = true;
        }
        disable() {
          this.isEnabled = false;
        }
        destroy() {
          this.disable();
          this.stopListening();
        }
        checkShouldIgnoreEventFromTarget(t) {
          if (t && t.nodeType === 3) {
            t = t.parentNode;
          }
          if (!t || t.nodeType !== 1) {
            return false;
          }
          return t.matches(
            "[data-cke-ignore-events], [data-cke-ignore-events] *"
          );
        }
      }
      Cs(Zd, Yd);
      var tu = "__lodash_hash_undefined__";
      function eu(t) {
        this.__data__.set(t, tu);
        return this;
      }
      var nu = eu;
      function ou(t) {
        return this.__data__.has(t);
      }
      var iu = ou;
      function ru(t) {
        var e = -1,
          n = t == null ? 0 : t.length;
        this.__data__ = new _e();
        while (++e < n) {
          this.add(t[e]);
        }
      }
      ru.prototype.add = ru.prototype.push = nu;
      ru.prototype.has = iu;
      var su = ru;
      function au(t, e) {
        var n = -1,
          o = t == null ? 0 : t.length;
        while (++n < o) {
          if (e(t[n], n, t)) {
            return true;
          }
        }
        return false;
      }
      var cu = au;
      function lu(t, e) {
        return t.has(e);
      }
      var du = lu;
      var uu = 1,
        hu = 2;
      function fu(t, e, n, o, i, r) {
        var s = n & uu,
          a = t.length,
          c = e.length;
        if (a != c && !(s && c > a)) {
          return false;
        }
        var l = r.get(t);
        if (l && r.get(e)) {
          return l == e;
        }
        var d = -1,
          u = true,
          h = n & hu ? new su() : undefined;
        r.set(t, e);
        r.set(e, t);
        while (++d < a) {
          var f = t[d],
            g = e[d];
          if (o) {
            var p = s ? o(g, f, d, e, t, r) : o(f, g, d, t, e, r);
          }
          if (p !== undefined) {
            if (p) {
              continue;
            }
            u = false;
            break;
          }
          if (h) {
            if (
              !cu(e, function (t, e) {
                if (!du(h, e) && (f === t || i(f, t, n, o, r))) {
                  return h.push(e);
                }
              })
            ) {
              u = false;
              break;
            }
          } else if (!(f === g || i(f, g, n, o, r))) {
            u = false;
            break;
          }
        }
        r["delete"](t);
        r["delete"](e);
        return u;
      }
      var gu = fu;
      function pu(t) {
        var e = -1,
          n = Array(t.size);
        t.forEach(function (t, o) {
          n[++e] = [o, t];
        });
        return n;
      }
      var mu = pu;
      function ku(t) {
        var e = -1,
          n = Array(t.size);
        t.forEach(function (t) {
          n[++e] = t;
        });
        return n;
      }
      var bu = ku;
      var wu = 1,
        _u = 2;
      var Au = "[object Boolean]",
        Cu = "[object Date]",
        vu = "[object Error]",
        yu = "[object Map]",
        xu = "[object Number]",
        Eu = "[object RegExp]",
        Su = "[object Set]",
        Pu = "[object String]",
        Du = "[object Symbol]";
      var Tu = "[object ArrayBuffer]",
        Bu = "[object DataView]";
      var Iu = r ? r.prototype : undefined,
        Ou = Iu ? Iu.valueOf : undefined;
      function Ru(t, e, n, o, i, r, s) {
        switch (n) {
          case Bu:
            if (t.byteLength != e.byteLength || t.byteOffset != e.byteOffset) {
              return false;
            }
            t = t.buffer;
            e = e.buffer;
          case Tu:
            if (t.byteLength != e.byteLength || !r(new fi(t), new fi(e))) {
              return false;
            }
            return true;
          case Au:
          case Cu:
          case xu:
            return V(+t, +e);
          case vu:
            return t.name == e.name && t.message == e.message;
          case Eu:
          case Pu:
            return t == e + "";
          case yu:
            var a = mu;
          case Su:
            var c = o & wu;
            a || (a = bu);
            if (t.size != e.size && !c) {
              return false;
            }
            var l = s.get(t);
            if (l) {
              return l == e;
            }
            o |= _u;
            s.set(t, e);
            var d = gu(a(t), a(e), o, i, r, s);
            s["delete"](t);
            return d;
          case Du:
            if (Ou) {
              return Ou.call(t) == Ou.call(e);
            }
        }
        return false;
      }
      var Fu = Ru;
      var Nu = 1;
      var Mu = Object.prototype;
      var Vu = Mu.hasOwnProperty;
      function Lu(t, e, n, o, i, r) {
        var s = n & Nu,
          a = Vo(t),
          c = a.length,
          l = Vo(e),
          d = l.length;
        if (c != d && !s) {
          return false;
        }
        var u = c;
        while (u--) {
          var h = a[u];
          if (!(s ? h in e : Vu.call(e, h))) {
            return false;
          }
        }
        var f = r.get(t);
        if (f && r.get(e)) {
          return f == e;
        }
        var g = true;
        r.set(t, e);
        r.set(e, t);
        var p = s;
        while (++u < c) {
          h = a[u];
          var m = t[h],
            k = e[h];
          if (o) {
            var b = s ? o(k, m, h, e, t, r) : o(m, k, h, t, e, r);
          }
          if (!(b === undefined ? m === k || i(m, k, n, o, r) : b)) {
            g = false;
            break;
          }
          p || (p = h == "constructor");
        }
        if (g && !p) {
          var w = t.constructor,
            _ = e.constructor;
          if (
            w != _ &&
            "constructor" in t &&
            "constructor" in e &&
            !(
              typeof w == "function" &&
              w instanceof w &&
              typeof _ == "function" &&
              _ instanceof _
            )
          ) {
            g = false;
          }
        }
        r["delete"](t);
        r["delete"](e);
        return g;
      }
      var zu = Lu;
      var ju = 1;
      var Ku = "[object Arguments]",
        qu = "[object Array]",
        $u = "[object Object]";
      var Wu = Object.prototype;
      var Gu = Wu.hasOwnProperty;
      function Uu(t, e, n, o, i, r) {
        var s = Je(t),
          a = Je(e),
          c = s ? qu : ai(t),
          l = a ? qu : ai(e);
        c = c == Ku ? $u : c;
        l = l == Ku ? $u : l;
        var d = c == $u,
          u = l == $u,
          h = c == l;
        if (h && Object(Ye["a"])(t)) {
          if (!Object(Ye["a"])(e)) {
            return false;
          }
          s = true;
          d = false;
        }
        if (h && !d) {
          r || (r = new xe());
          return s || Mn(t) ? gu(t, e, n, o, i, r) : Fu(t, e, c, n, o, i, r);
        }
        if (!(n & ju)) {
          var f = d && Gu.call(t, "__wrapped__"),
            g = u && Gu.call(e, "__wrapped__");
          if (f || g) {
            var p = f ? t.value() : t,
              m = g ? e.value() : e;
            r || (r = new xe());
            return i(p, m, n, o, r);
          }
        }
        if (!h) {
          return false;
        }
        r || (r = new xe());
        return zu(t, e, n, o, i, r);
      }
      var Hu = Uu;
      function Ju(t, e, n, o, i) {
        if (t === e) {
          return true;
        }
        if (t == null || e == null || (!E(t) && !E(e))) {
          return t !== t && e !== e;
        }
        return Hu(t, e, n, o, Ju, i);
      }
      var Yu = Ju;
      function Qu(t, e, n) {
        n = typeof n == "function" ? n : undefined;
        var o = n ? n(t, e) : undefined;
        return o === undefined ? Yu(t, e, undefined, n) : !!o;
      }
      var Xu = Qu;
      class Zu extends Zd {
        constructor(t) {
          super(t);
          this._config = {
            childList: true,
            characterData: true,
            characterDataOldValue: true,
            subtree: true,
          };
          this.domConverter = t.domConverter;
          this.renderer = t._renderer;
          this._domElements = [];
          this._mutationObserver = new window.MutationObserver(
            this._onMutations.bind(this)
          );
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords());
        }
        observe(t) {
          this._domElements.push(t);
          if (this.isEnabled) {
            this._mutationObserver.observe(t, this._config);
          }
        }
        enable() {
          super.enable();
          for (const t of this._domElements) {
            this._mutationObserver.observe(t, this._config);
          }
        }
        disable() {
          super.disable();
          this._mutationObserver.disconnect();
        }
        destroy() {
          super.destroy();
          this._mutationObserver.disconnect();
        }
        _onMutations(t) {
          if (t.length === 0) {
            return;
          }
          const e = this.domConverter;
          const n = new Map();
          const o = new Set();
          for (const n of t) {
            if (n.type === "childList") {
              const t = e.mapDomToView(n.target);
              if (t && (t.is("uiElement") || t.is("rawElement"))) {
                continue;
              }
              if (t && !this._isBogusBrMutation(n)) {
                o.add(t);
              }
            }
          }
          for (const i of t) {
            const t = e.mapDomToView(i.target);
            if (t && (t.is("uiElement") || t.is("rawElement"))) {
              continue;
            }
            if (i.type === "characterData") {
              const t = e.findCorrespondingViewText(i.target);
              if (t && !o.has(t.parent)) {
                n.set(t, {
                  type: "text",
                  oldText: t.data,
                  newText: kd(i.target),
                  node: t,
                });
              } else if (!t && pd(i.target)) {
                o.add(e.mapDomToView(i.target.parentNode));
              }
            }
          }
          const i = [];
          for (const t of n.values()) {
            this.renderer.markToSync("text", t.node);
            i.push(t);
          }
          for (const t of o) {
            const n = e.mapViewToDom(t);
            const o = Array.from(t.getChildren());
            const r = Array.from(
              e.domChildrenToView(n, { withChildren: false })
            );
            if (!Xu(o, r, a)) {
              this.renderer.markToSync("children", t);
              i.push({
                type: "children",
                oldChildren: o,
                newChildren: r,
                node: t,
              });
            }
          }
          const r = t[0].target.ownerDocument.getSelection();
          let s = null;
          if (r && r.anchorNode) {
            const t = e.domPositionToView(r.anchorNode, r.anchorOffset);
            const n = e.domPositionToView(r.focusNode, r.focusOffset);
            if (t && n) {
              s = new pl(t);
              s.setFocus(n);
            }
          }
          if (i.length) {
            this.document.fire("mutations", i, s);
            this.view.forceRender();
          }
          function a(t, e) {
            if (Array.isArray(t)) {
              return;
            }
            if (t === e) {
              return true;
            } else if (t.is("$text") && e.is("$text")) {
              return t.data === e.data;
            }
            return false;
          }
        }
        _isBogusBrMutation(t) {
          let e = null;
          if (
            t.nextSibling === null &&
            t.removedNodes.length === 0 &&
            t.addedNodes.length == 1
          ) {
            e = this.domConverter.domToView(t.addedNodes[0], {
              withChildren: false,
            });
          }
          return e && e.is("element", "br");
        }
      }
      class th {
        constructor(t, e, n) {
          this.view = t;
          this.document = t.document;
          this.domEvent = e;
          this.domTarget = e.target;
          Wc(this, n);
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget);
        }
        preventDefault() {
          this.domEvent.preventDefault();
        }
        stopPropagation() {
          this.domEvent.stopPropagation();
        }
      }
      class eh extends Zd {
        constructor(t) {
          super(t);
          this.useCapture = false;
        }
        observe(t) {
          const e =
            typeof this.domEventType == "string"
              ? [this.domEventType]
              : this.domEventType;
          e.forEach((e) => {
            this.listenTo(
              t,
              e,
              (t, e) => {
                if (
                  this.isEnabled &&
                  !this.checkShouldIgnoreEventFromTarget(e.target)
                ) {
                  this.onDomEvent(e);
                }
              },
              { useCapture: this.useCapture }
            );
          });
        }
        fire(t, e, n) {
          if (this.isEnabled) {
            this.document.fire(t, new th(this.view, e, n));
          }
        }
      }
      class nh extends eh {
        constructor(t) {
          super(t);
          this.domEventType = ["keydown", "keyup"];
        }
        onDomEvent(t) {
          this.fire(t.type, t, {
            keyCode: t.keyCode,
            altKey: t.altKey,
            ctrlKey: t.ctrlKey || t.metaKey,
            shiftKey: t.shiftKey,
            get keystroke() {
              return Nl(this);
            },
          });
        }
      }
      var oh = function () {
        return o["a"].Date.now();
      };
      var ih = oh;
      var rh = 0 / 0;
      var sh = /^\s+|\s+$/g;
      var ah = /^[-+]0x[0-9a-f]+$/i;
      var ch = /^0b[01]+$/i;
      var lh = /^0o[0-7]+$/i;
      var dh = parseInt;
      function uh(t) {
        if (typeof t == "number") {
          return t;
        }
        if (Xs(t)) {
          return rh;
        }
        if (ct(t)) {
          var e = typeof t.valueOf == "function" ? t.valueOf() : t;
          t = ct(e) ? e + "" : e;
        }
        if (typeof t != "string") {
          return t === 0 ? t : +t;
        }
        t = t.replace(sh, "");
        var n = ch.test(t);
        return n || lh.test(t)
          ? dh(t.slice(2), n ? 2 : 8)
          : ah.test(t)
          ? rh
          : +t;
      }
      var hh = uh;
      var fh = "Expected a function";
      var gh = Math.max,
        ph = Math.min;
      function mh(t, e, n) {
        var o,
          i,
          r,
          s,
          a,
          c,
          l = 0,
          d = false,
          u = false,
          h = true;
        if (typeof t != "function") {
          throw new TypeError(fh);
        }
        e = hh(e) || 0;
        if (ct(n)) {
          d = !!n.leading;
          u = "maxWait" in n;
          r = u ? gh(hh(n.maxWait) || 0, e) : r;
          h = "trailing" in n ? !!n.trailing : h;
        }
        function f(e) {
          var n = o,
            r = i;
          o = i = undefined;
          l = e;
          s = t.apply(r, n);
          return s;
        }
        function g(t) {
          l = t;
          a = setTimeout(k, e);
          return d ? f(t) : s;
        }
        function p(t) {
          var n = t - c,
            o = t - l,
            i = e - n;
          return u ? ph(i, r - o) : i;
        }
        function m(t) {
          var n = t - c,
            o = t - l;
          return c === undefined || n >= e || n < 0 || (u && o >= r);
        }
        function k() {
          var t = ih();
          if (m(t)) {
            return b(t);
          }
          a = setTimeout(k, p(t));
        }
        function b(t) {
          a = undefined;
          if (h && o) {
            return f(t);
          }
          o = i = undefined;
          return s;
        }
        function w() {
          if (a !== undefined) {
            clearTimeout(a);
          }
          l = 0;
          o = c = i = a = undefined;
        }
        function _() {
          return a === undefined ? s : b(ih());
        }
        function A() {
          var t = ih(),
            n = m(t);
          o = arguments;
          i = this;
          c = t;
          if (n) {
            if (a === undefined) {
              return g(c);
            }
            if (u) {
              clearTimeout(a);
              a = setTimeout(k, e);
              return f(c);
            }
          }
          if (a === undefined) {
            a = setTimeout(k, e);
          }
          return s;
        }
        A.cancel = w;
        A.flush = _;
        return A;
      }
      var kh = mh;
      class bh extends Zd {
        constructor(t) {
          super(t);
          this._fireSelectionChangeDoneDebounced = kh(
            (t) => this.document.fire("selectionChangeDone", t),
            200
          );
        }
        observe() {
          const t = this.document;
          t.on(
            "keydown",
            (e, n) => {
              const o = t.selection;
              if (o.isFake && Ll(n.keyCode) && this.isEnabled) {
                n.preventDefault();
                this._handleSelectionMove(n.keyCode);
              }
            },
            { priority: "lowest" }
          );
        }
        destroy() {
          super.destroy();
          this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionMove(t) {
          const e = this.document.selection;
          const n = new pl(e.getRanges(), {
            backward: e.isBackward,
            fake: false,
          });
          if (t == Fl.arrowleft || t == Fl.arrowup) {
            n.setTo(n.getFirstPosition());
          }
          if (t == Fl.arrowright || t == Fl.arrowdown) {
            n.setTo(n.getLastPosition());
          }
          const o = { oldSelection: e, newSelection: n, domSelection: null };
          this.document.fire("selectionChange", o);
          this._fireSelectionChangeDoneDebounced(o);
        }
      }
      class wh extends Zd {
        constructor(t) {
          super(t);
          this.mutationObserver = t.getObserver(Zu);
          this.selection = this.document.selection;
          this.domConverter = t.domConverter;
          this._documents = new WeakSet();
          this._fireSelectionChangeDoneDebounced = kh(
            (t) => this.document.fire("selectionChangeDone", t),
            200
          );
          this._clearInfiniteLoopInterval = setInterval(
            () => this._clearInfiniteLoop(),
            1e3
          );
          this._loopbackCounter = 0;
        }
        observe(t) {
          const e = t.ownerDocument;
          if (this._documents.has(e)) {
            return;
          }
          this.listenTo(e, "selectionchange", (t, n) => {
            this._handleSelectionChange(n, e);
          });
          this._documents.add(e);
        }
        destroy() {
          super.destroy();
          clearInterval(this._clearInfiniteLoopInterval);
          this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionChange(t, e) {
          if (!this.isEnabled) {
            return;
          }
          const n = e.defaultView.getSelection();
          if (this.checkShouldIgnoreEventFromTarget(n.anchorNode)) {
            return;
          }
          this.mutationObserver.flush();
          const o = this.domConverter.domSelectionToView(n);
          if (o.rangeCount == 0) {
            this.view.hasDomSelection = false;
            return;
          }
          this.view.hasDomSelection = true;
          if (
            this.selection.isEqual(o) &&
            this.domConverter.isDomSelectionCorrect(n)
          ) {
            return;
          }
          if (++this._loopbackCounter > 60) {
            return;
          }
          if (this.selection.isSimilar(o)) {
            this.view.forceRender();
          } else {
            const t = {
              oldSelection: this.selection,
              newSelection: o,
              domSelection: n,
            };
            this.document.fire("selectionChange", t);
            this._fireSelectionChangeDoneDebounced(t);
          }
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0;
        }
      }
      class _h extends eh {
        constructor(t) {
          super(t);
          this.domEventType = ["focus", "blur"];
          this.useCapture = true;
          const e = this.document;
          e.on("focus", () => {
            e.isFocused = true;
            this._renderTimeoutId = setTimeout(() => t.forceRender(), 50);
          });
          e.on("blur", (n, o) => {
            const i = e.selection.editableElement;
            if (i === null || i === o.target) {
              e.isFocused = false;
              t.forceRender();
            }
          });
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
        destroy() {
          if (this._renderTimeoutId) {
            clearTimeout(this._renderTimeoutId);
          }
          super.destroy();
        }
      }
      class Ah extends eh {
        constructor(t) {
          super(t);
          this.domEventType = [
            "compositionstart",
            "compositionupdate",
            "compositionend",
          ];
          const e = this.document;
          e.on("compositionstart", () => {
            e.isComposing = true;
          });
          e.on("compositionend", () => {
            e.isComposing = false;
          });
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      class Ch extends eh {
        constructor(t) {
          super(t);
          this.domEventType = ["beforeinput"];
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      function vh(t) {
        return Object.prototype.toString.apply(t) == "[object Range]";
      }
      function yh(t) {
        const e = t.ownerDocument.defaultView.getComputedStyle(t);
        return {
          top: parseInt(e.borderTopWidth, 10),
          right: parseInt(e.borderRightWidth, 10),
          bottom: parseInt(e.borderBottomWidth, 10),
          left: parseInt(e.borderLeftWidth, 10),
        };
      }
      const xh = ["top", "right", "bottom", "left", "width", "height"];
      class Eh {
        constructor(t) {
          const e = vh(t);
          Object.defineProperty(this, "_source", {
            value: t._source || t,
            writable: true,
            enumerable: false,
          });
          if (Hr(t) || e) {
            if (e) {
              const e = Eh.getDomRangeRects(t);
              Sh(this, Eh.getBoundingRect(e));
            } else {
              Sh(this, t.getBoundingClientRect());
            }
          } else if (Hd(t)) {
            const { innerWidth: e, innerHeight: n } = t;
            Sh(this, {
              top: 0,
              right: e,
              bottom: n,
              left: 0,
              width: e,
              height: n,
            });
          } else {
            Sh(this, t);
          }
        }
        clone() {
          return new Eh(this);
        }
        moveTo(t, e) {
          this.top = e;
          this.right = t + this.width;
          this.bottom = e + this.height;
          this.left = t;
          return this;
        }
        moveBy(t, e) {
          this.top += e;
          this.right += t;
          this.left += t;
          this.bottom += e;
          return this;
        }
        getIntersection(t) {
          const e = {
            top: Math.max(this.top, t.top),
            right: Math.min(this.right, t.right),
            bottom: Math.min(this.bottom, t.bottom),
            left: Math.max(this.left, t.left),
          };
          e.width = e.right - e.left;
          e.height = e.bottom - e.top;
          if (e.width < 0 || e.height < 0) {
            return null;
          } else {
            return new Eh(e);
          }
        }
        getIntersectionArea(t) {
          const e = this.getIntersection(t);
          if (e) {
            return e.getArea();
          } else {
            return 0;
          }
        }
        getArea() {
          return this.width * this.height;
        }
        getVisible() {
          const t = this._source;
          let e = this.clone();
          if (!Ph(t)) {
            let n = t.parentNode || t.commonAncestorContainer;
            while (n && !Ph(n)) {
              const t = new Eh(n);
              const o = e.getIntersection(t);
              if (o) {
                if (o.getArea() < e.getArea()) {
                  e = o;
                }
              } else {
                return null;
              }
              n = n.parentNode;
            }
          }
          return e;
        }
        isEqual(t) {
          for (const e of xh) {
            if (this[e] !== t[e]) {
              return false;
            }
          }
          return true;
        }
        contains(t) {
          const e = this.getIntersection(t);
          return !!(e && e.isEqual(t));
        }
        excludeScrollbarsAndBorders() {
          const t = this._source;
          let e, n, o;
          if (Hd(t)) {
            e = t.innerWidth - t.document.documentElement.clientWidth;
            n = t.innerHeight - t.document.documentElement.clientHeight;
            o = t.getComputedStyle(t.document.documentElement).direction;
          } else {
            const i = yh(this._source);
            e = t.offsetWidth - t.clientWidth - i.left - i.right;
            n = t.offsetHeight - t.clientHeight - i.top - i.bottom;
            o = t.ownerDocument.defaultView.getComputedStyle(t).direction;
            this.left += i.left;
            this.top += i.top;
            this.right -= i.right;
            this.bottom -= i.bottom;
            this.width = this.right - this.left;
            this.height = this.bottom - this.top;
          }
          this.width -= e;
          if (o === "ltr") {
            this.right -= e;
          } else {
            this.left += e;
          }
          this.height -= n;
          this.bottom -= n;
          return this;
        }
        static getDomRangeRects(t) {
          const e = [];
          const n = Array.from(t.getClientRects());
          if (n.length) {
            for (const t of n) {
              e.push(new Eh(t));
            }
          } else {
            let n = t.startContainer;
            if (dd(n)) {
              n = n.parentNode;
            }
            const o = new Eh(n.getBoundingClientRect());
            o.right = o.left;
            o.width = 0;
            e.push(o);
          }
          return e;
        }
        static getBoundingRect(t) {
          const e = {
            left: Number.POSITIVE_INFINITY,
            top: Number.POSITIVE_INFINITY,
            right: Number.NEGATIVE_INFINITY,
            bottom: Number.NEGATIVE_INFINITY,
          };
          let n = 0;
          for (const o of t) {
            n++;
            e.left = Math.min(e.left, o.left);
            e.top = Math.min(e.top, o.top);
            e.right = Math.max(e.right, o.right);
            e.bottom = Math.max(e.bottom, o.bottom);
          }
          if (n == 0) {
            return null;
          }
          e.width = e.right - e.left;
          e.height = e.bottom - e.top;
          return new Eh(e);
        }
      }
      function Sh(t, e) {
        for (const n of xh) {
          t[n] = e[n];
        }
      }
      function Ph(t) {
        if (!Hr(t)) {
          return false;
        }
        return t === t.ownerDocument.body;
      }
      const Dh = {};
      function Th({ target: t, viewportOffset: e = 0 }) {
        const n = Vh(t);
        let o = n;
        let i = null;
        while (o) {
          let r;
          if (o == n) {
            r = Lh(t);
          } else {
            r = Lh(i);
          }
          Oh(r, () => zh(t, o));
          const s = zh(t, o);
          Ih(o, s, e);
          if (o.parent != o) {
            i = o.frameElement;
            o = o.parent;
            if (!i) {
              return;
            }
          } else {
            o = null;
          }
        }
      }
      function Bh(t) {
        const e = Lh(t);
        Oh(e, () => new Eh(t));
      }
      Object.assign(Dh, {
        scrollViewportToShowTarget: Th,
        scrollAncestorsToShowTarget: Bh,
      });
      function Ih(t, e, n) {
        const o = e.clone().moveBy(0, n);
        const i = e.clone().moveBy(0, -n);
        const r = new Eh(t).excludeScrollbarsAndBorders();
        const s = [i, o];
        if (!s.every((t) => r.contains(t))) {
          let { scrollX: s, scrollY: a } = t;
          if (Fh(i, r)) {
            a -= r.top - e.top + n;
          } else if (Rh(o, r)) {
            a += e.bottom - r.bottom + n;
          }
          if (Nh(e, r)) {
            s -= r.left - e.left + n;
          } else if (Mh(e, r)) {
            s += e.right - r.right + n;
          }
          t.scrollTo(s, a);
        }
      }
      function Oh(t, e) {
        const n = Vh(t);
        let o, i;
        while (t != n.document.body) {
          i = e();
          o = new Eh(t).excludeScrollbarsAndBorders();
          if (!o.contains(i)) {
            if (Fh(i, o)) {
              t.scrollTop -= o.top - i.top;
            } else if (Rh(i, o)) {
              t.scrollTop += i.bottom - o.bottom;
            }
            if (Nh(i, o)) {
              t.scrollLeft -= o.left - i.left;
            } else if (Mh(i, o)) {
              t.scrollLeft += i.right - o.right;
            }
          }
          t = t.parentNode;
        }
      }
      function Rh(t, e) {
        return t.bottom > e.bottom;
      }
      function Fh(t, e) {
        return t.top < e.top;
      }
      function Nh(t, e) {
        return t.left < e.left;
      }
      function Mh(t, e) {
        return t.right > e.right;
      }
      function Vh(t) {
        if (vh(t)) {
          return t.startContainer.ownerDocument.defaultView;
        } else {
          return t.ownerDocument.defaultView;
        }
      }
      function Lh(t) {
        if (vh(t)) {
          let e = t.commonAncestorContainer;
          if (dd(e)) {
            e = e.parentNode;
          }
          return e;
        } else {
          return t.parentNode;
        }
      }
      function zh(t, e) {
        const n = Vh(t);
        const o = new Eh(t);
        if (n === e) {
          return o;
        } else {
          let t = n;
          while (t != e) {
            const e = t.frameElement;
            const n = new Eh(e).excludeScrollbarsAndBorders();
            o.moveBy(n.left, n.top);
            t = t.parent;
          }
        }
        return o;
      }
      class jh {
        constructor(t) {
          this.document = new kl(t);
          this.domConverter = new qd(this.document);
          this.domRoots = new Map();
          this.set("isRenderingInProgress", false);
          this.set("hasDomSelection", false);
          this._renderer = new Td(this.domConverter, this.document.selection);
          this._renderer.bind("isFocused").to(this.document);
          this._initialDomRootAttributes = new WeakMap();
          this._observers = new Map();
          this._ongoingChange = false;
          this._postFixersInProgress = false;
          this._renderingDisabled = false;
          this._hasChangedSinceTheLastRendering = false;
          this._writer = new Xl(this.document);
          this.addObserver(Zu);
          this.addObserver(wh);
          this.addObserver(_h);
          this.addObserver(nh);
          this.addObserver(bh);
          this.addObserver(Ah);
          if (El.isAndroid) {
            this.addObserver(Ch);
          }
          bd(this);
          Wl(this);
          this.on("render", () => {
            this._render();
            this.document.fire("layoutChanged");
            this._hasChangedSinceTheLastRendering = false;
          });
          this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
        }
        attachDomRoot(t, e = "main") {
          const n = this.document.getRoot(e);
          n._name = t.tagName.toLowerCase();
          const o = {};
          for (const { name: e, value: i } of Array.from(t.attributes)) {
            o[e] = i;
            if (e === "class") {
              this._writer.addClass(i.split(" "), n);
            } else {
              this._writer.setAttribute(e, i, n);
            }
          }
          this._initialDomRootAttributes.set(t, o);
          const i = () => {
            this._writer.setAttribute("contenteditable", !n.isReadOnly, n);
            if (n.isReadOnly) {
              this._writer.addClass("ck-read-only", n);
            } else {
              this._writer.removeClass("ck-read-only", n);
            }
          };
          i();
          this.domRoots.set(e, t);
          this.domConverter.bindElements(t, n);
          this._renderer.markToSync("children", n);
          this._renderer.markToSync("attributes", n);
          this._renderer.domDocuments.add(t.ownerDocument);
          n.on("change:children", (t, e) =>
            this._renderer.markToSync("children", e)
          );
          n.on("change:attributes", (t, e) =>
            this._renderer.markToSync("attributes", e)
          );
          n.on("change:text", (t, e) => this._renderer.markToSync("text", e));
          n.on("change:isReadOnly", () => this.change(i));
          n.on("change", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          for (const n of this._observers.values()) {
            n.observe(t, e);
          }
        }
        detachDomRoot(t) {
          const e = this.domRoots.get(t);
          Array.from(e.attributes).forEach(({ name: t }) =>
            e.removeAttribute(t)
          );
          const n = this._initialDomRootAttributes.get(e);
          for (const t in n) {
            e.setAttribute(t, n[t]);
          }
          this.domRoots.delete(t);
          this.domConverter.unbindDomElement(e);
        }
        getDomRoot(t = "main") {
          return this.domRoots.get(t);
        }
        addObserver(t) {
          let e = this._observers.get(t);
          if (e) {
            return e;
          }
          e = new t(this);
          this._observers.set(t, e);
          for (const [t, n] of this.domRoots) {
            e.observe(n, t);
          }
          e.enable();
          return e;
        }
        getObserver(t) {
          return this._observers.get(t);
        }
        disableObservers() {
          for (const t of this._observers.values()) {
            t.disable();
          }
        }
        enableObservers() {
          for (const t of this._observers.values()) {
            t.enable();
          }
        }
        scrollToTheSelection() {
          const t = this.document.selection.getFirstRange();
          if (t) {
            Th({
              target: this.domConverter.viewRangeToDom(t),
              viewportOffset: 20,
            });
          }
        }
        focus() {
          if (!this.document.isFocused) {
            const t = this.document.selection.editableElement;
            if (t) {
              this.domConverter.focus(t);
              this.forceRender();
            } else {
            }
          }
        }
        change(t) {
          if (this.isRenderingInProgress || this._postFixersInProgress) {
            throw new ss["a"]("cannot-change-view-tree", this);
          }
          try {
            if (this._ongoingChange) {
              return t(this._writer);
            }
            this._ongoingChange = true;
            const e = t(this._writer);
            this._ongoingChange = false;
            if (
              !this._renderingDisabled &&
              this._hasChangedSinceTheLastRendering
            ) {
              this._postFixersInProgress = true;
              this.document._callPostFixers(this._writer);
              this._postFixersInProgress = false;
              this.fire("render");
            }
            return e;
          } catch (t) {
            ss["a"].rethrowUnexpectedError(t, this);
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = true;
          this.change(() => {});
        }
        destroy() {
          for (const t of this._observers.values()) {
            t.destroy();
          }
          this.document.destroy();
          this.stopListening();
        }
        createPositionAt(t, e) {
          return ul._createAt(t, e);
        }
        createPositionAfter(t) {
          return ul._createAfter(t);
        }
        createPositionBefore(t) {
          return ul._createBefore(t);
        }
        createRange(t, e) {
          return new hl(t, e);
        }
        createRangeOn(t) {
          return hl._createOn(t);
        }
        createRangeIn(t) {
          return hl._createIn(t);
        }
        createSelection(t, e, n) {
          return new pl(t, e, n);
        }
        _disableRendering(t) {
          this._renderingDisabled = t;
          if (t == false) {
            this.change(() => {});
          }
        }
        _render() {
          this.isRenderingInProgress = true;
          this.disableObservers();
          this._renderer.render();
          this.enableObservers();
          this.isRenderingInProgress = false;
        }
      }
      Cs(jh, Yc);
      class Kh {
        constructor(t) {
          this.parent = null;
          this._attrs = qs(t);
        }
        get index() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildIndex(this)) === null) {
            throw new ss["a"]("model-node-not-found-in-parent", this);
          }
          return t;
        }
        get startOffset() {
          let t;
          if (!this.parent) {
            return null;
          }
          if ((t = this.parent.getChildStartOffset(this)) === null) {
            throw new ss["a"]("model-node-not-found-in-parent", this);
          }
          return t;
        }
        get offsetSize() {
          return 1;
        }
        get endOffset() {
          if (!this.parent) {
            return null;
          }
          return this.startOffset + this.offsetSize;
        }
        get nextSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t + 1)) || null;
        }
        get previousSibling() {
          const t = this.index;
          return (t !== null && this.parent.getChild(t - 1)) || null;
        }
        get root() {
          let t = this;
          while (t.parent) {
            t = t.parent;
          }
          return t;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const t = [];
          let e = this;
          while (e.parent) {
            t.unshift(e.startOffset);
            e = e.parent;
          }
          return t;
        }
        getAncestors(t = { includeSelf: false, parentFirst: false }) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
        getCommonAncestor(t, e = {}) {
          const n = this.getAncestors(e);
          const o = t.getAncestors(e);
          let i = 0;
          while (n[i] == o[i] && n[i]) {
            i++;
          }
          return i === 0 ? null : n[i - 1];
        }
        isBefore(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getPath();
          const n = t.getPath();
          const o = Fs(e, n);
          switch (o) {
            case "prefix":
              return true;
            case "extension":
              return false;
            default:
              return e[o] < n[o];
          }
        }
        isAfter(t) {
          if (this == t) {
            return false;
          }
          if (this.root !== t.root) {
            return false;
          }
          return !this.isBefore(t);
        }
        hasAttribute(t) {
          return this._attrs.has(t);
        }
        getAttribute(t) {
          return this._attrs.get(t);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        toJSON() {
          const t = {};
          if (this._attrs.size) {
            t.attributes = Array.from(this._attrs).reduce((t, e) => {
              t[e[0]] = e[1];
              return t;
            }, {});
          }
          return t;
        }
        is(t) {
          return t === "node" || t === "model:node";
        }
        _clone() {
          return new Kh(this._attrs);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _setAttribute(t, e) {
          this._attrs.set(t, e);
        }
        _setAttributesTo(t) {
          this._attrs = qs(t);
        }
        _removeAttribute(t) {
          return this._attrs.delete(t);
        }
        _clearAttributes() {
          this._attrs.clear();
        }
      }
      class qh extends Kh {
        constructor(t, e) {
          super(e);
          this._data = t || "";
        }
        get offsetSize() {
          return this.data.length;
        }
        get data() {
          return this._data;
        }
        is(t) {
          return (
            t === "$text" ||
            t === "model:$text" ||
            t === "text" ||
            t === "model:text" ||
            t === "node" ||
            t === "model:node"
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.data = this.data;
          return t;
        }
        _clone() {
          return new qh(this.data, this.getAttributes());
        }
        static fromJSON(t) {
          return new qh(t.data, t.attributes);
        }
      }
      class $h {
        constructor(t, e, n) {
          this.textNode = t;
          if (e < 0 || e > t.offsetSize) {
            throw new ss["a"]("model-textproxy-wrong-offsetintext", this);
          }
          if (n < 0 || e + n > t.offsetSize) {
            throw new ss["a"]("model-textproxy-wrong-length", this);
          }
          this.data = t.data.substring(e, e + n);
          this.offsetInText = e;
        }
        get startOffset() {
          return this.textNode.startOffset !== null
            ? this.textNode.startOffset + this.offsetInText
            : null;
        }
        get offsetSize() {
          return this.data.length;
        }
        get endOffset() {
          return this.startOffset !== null
            ? this.startOffset + this.offsetSize
            : null;
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        is(t) {
          return (
            t === "$textProxy" ||
            t === "model:$textProxy" ||
            t === "textProxy" ||
            t === "model:textProxy"
          );
        }
        getPath() {
          const t = this.textNode.getPath();
          if (t.length > 0) {
            t[t.length - 1] += this.offsetInText;
          }
          return t;
        }
        getAncestors(t = { includeSelf: false, parentFirst: false }) {
          const e = [];
          let n = t.includeSelf ? this : this.parent;
          while (n) {
            e[t.parentFirst ? "push" : "unshift"](n);
            n = n.parent;
          }
          return e;
        }
        hasAttribute(t) {
          return this.textNode.hasAttribute(t);
        }
        getAttribute(t) {
          return this.textNode.getAttribute(t);
        }
        getAttributes() {
          return this.textNode.getAttributes();
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys();
        }
      }
      class Wh {
        constructor(t) {
          this._nodes = [];
          if (t) {
            this._insertNodes(0, t);
          }
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]();
        }
        get length() {
          return this._nodes.length;
        }
        get maxOffset() {
          return this._nodes.reduce((t, e) => t + e.offsetSize, 0);
        }
        getNode(t) {
          return this._nodes[t] || null;
        }
        getNodeIndex(t) {
          const e = this._nodes.indexOf(t);
          return e == -1 ? null : e;
        }
        getNodeStartOffset(t) {
          const e = this.getNodeIndex(t);
          return e === null
            ? null
            : this._nodes.slice(0, e).reduce((t, e) => t + e.offsetSize, 0);
        }
        indexToOffset(t) {
          if (t == this._nodes.length) {
            return this.maxOffset;
          }
          const e = this._nodes[t];
          if (!e) {
            throw new ss["a"]("model-nodelist-index-out-of-bounds", this);
          }
          return this.getNodeStartOffset(e);
        }
        offsetToIndex(t) {
          let e = 0;
          for (const n of this._nodes) {
            if (t >= e && t < e + n.offsetSize) {
              return this.getNodeIndex(n);
            }
            e += n.offsetSize;
          }
          if (e != t) {
            throw new ss["a"]("model-nodelist-offset-out-of-bounds", this, {
              offset: t,
              nodeList: this,
            });
          }
          return this.length;
        }
        _insertNodes(t, e) {
          for (const t of e) {
            if (!(t instanceof Kh)) {
              throw new ss["a"]("model-nodelist-insertnodes-not-node", this);
            }
          }
          this._nodes.splice(t, 0, ...e);
        }
        _removeNodes(t, e = 1) {
          return this._nodes.splice(t, e);
        }
        toJSON() {
          return this._nodes.map((t) => t.toJSON());
        }
      }
      class Gh extends Kh {
        constructor(t, e, n) {
          super(e);
          this.name = t;
          this._children = new Wh();
          if (n) {
            this._insertChild(0, n);
          }
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        is(t, e = null) {
          if (!e) {
            return (
              t === "element" ||
              t === "model:element" ||
              t === "node" ||
              t === "model:node"
            );
          }
          return e === this.name && (t === "element" || t === "model:element");
        }
        getChild(t) {
          return this._children.getNode(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t);
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t);
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t);
        }
        getNodeByPath(t) {
          let e = this;
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n));
          }
          return e;
        }
        findAncestor(t, e = { includeSelf: false }) {
          let n = e.includeSelf ? this : this.parent;
          while (n) {
            if (n.name === t) {
              return n;
            }
            n = n.parent;
          }
          return null;
        }
        toJSON() {
          const t = super.toJSON();
          t.name = this.name;
          if (this._children.length > 0) {
            t.children = [];
            for (const e of this._children) {
              t.children.push(e.toJSON());
            }
          }
          return t;
        }
        _clone(t = false) {
          const e = t
            ? Array.from(this._children).map((t) => t._clone(true))
            : null;
          return new Gh(this.name, this.getAttributes(), e);
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          const n = Uh(e);
          for (const t of n) {
            if (t.parent !== null) {
              t._remove();
            }
            t.parent = this;
          }
          this._children._insertNodes(t, n);
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e);
          for (const t of n) {
            t.parent = null;
          }
          return n;
        }
        static fromJSON(t) {
          let e = null;
          if (t.children) {
            e = [];
            for (const n of t.children) {
              if (n.name) {
                e.push(Gh.fromJSON(n));
              } else {
                e.push(qh.fromJSON(n));
              }
            }
          }
          return new Gh(t.name, t.attributes, e);
        }
      }
      function Uh(t) {
        if (typeof t == "string") {
          return [new qh(t)];
        }
        if (!As(t)) {
          t = [t];
        }
        return Array.from(t).map((t) => {
          if (typeof t == "string") {
            return new qh(t);
          }
          if (t instanceof $h) {
            return new qh(t.data, t.getAttributes());
          }
          return t;
        });
      }
      class Hh {
        constructor(t = {}) {
          if (!t.boundaries && !t.startPosition) {
            throw new ss["a"]("model-tree-walker-no-start-position", null);
          }
          const e = t.direction || "forward";
          if (e != "forward" && e != "backward") {
            throw new ss["a"]("model-tree-walker-unknown-direction", t, {
              direction: e,
            });
          }
          this.direction = e;
          this.boundaries = t.boundaries || null;
          if (t.startPosition) {
            this.position = t.startPosition.clone();
          } else {
            this.position = Yh._createAt(
              this.boundaries[this.direction == "backward" ? "end" : "start"]
            );
          }
          this.position.stickiness = "toNone";
          this.singleCharacters = !!t.singleCharacters;
          this.shallow = !!t.shallow;
          this.ignoreElementEnd = !!t.ignoreElementEnd;
          this._boundaryStartParent = this.boundaries
            ? this.boundaries.start.parent
            : null;
          this._boundaryEndParent = this.boundaries
            ? this.boundaries.end.parent
            : null;
          this._visitedParent = this.position.parent;
        }
        [Symbol.iterator]() {
          return this;
        }
        skip(t) {
          let e, n, o, i;
          do {
            o = this.position;
            i = this._visitedParent;
            ({ done: e, value: n } = this.next());
          } while (!e && t(n));
          if (!e) {
            this.position = o;
            this._visitedParent = i;
          }
        }
        next() {
          if (this.direction == "forward") {
            return this._next();
          } else {
            return this._previous();
          }
        }
        _next() {
          const t = this.position;
          const e = this.position.clone();
          const n = this._visitedParent;
          if (n.parent === null && e.offset === n.maxOffset) {
            return { done: true };
          }
          if (
            n === this._boundaryEndParent &&
            e.offset == this.boundaries.end.offset
          ) {
            return { done: true };
          }
          const o = e.parent;
          const i = Qh(e, o);
          const r = i ? i : Xh(e, o, i);
          if (r instanceof Gh) {
            if (!this.shallow) {
              e.path.push(0);
              this._visitedParent = r;
            } else {
              e.offset++;
            }
            this.position = e;
            return Jh("elementStart", r, t, e, 1);
          } else if (r instanceof qh) {
            let o;
            if (this.singleCharacters) {
              o = 1;
            } else {
              let t = r.endOffset;
              if (
                this._boundaryEndParent == n &&
                this.boundaries.end.offset < t
              ) {
                t = this.boundaries.end.offset;
              }
              o = t - e.offset;
            }
            const i = e.offset - r.startOffset;
            const s = new $h(r, i, o);
            e.offset += o;
            this.position = e;
            return Jh("text", s, t, e, o);
          } else {
            e.path.pop();
            e.offset++;
            this.position = e;
            this._visitedParent = n.parent;
            if (this.ignoreElementEnd) {
              return this._next();
            } else {
              return Jh("elementEnd", n, t, e);
            }
          }
        }
        _previous() {
          const t = this.position;
          const e = this.position.clone();
          const n = this._visitedParent;
          if (n.parent === null && e.offset === 0) {
            return { done: true };
          }
          if (
            n == this._boundaryStartParent &&
            e.offset == this.boundaries.start.offset
          ) {
            return { done: true };
          }
          const o = e.parent;
          const i = Qh(e, o);
          const r = i ? i : Zh(e, o, i);
          if (r instanceof Gh) {
            e.offset--;
            if (!this.shallow) {
              e.path.push(r.maxOffset);
              this.position = e;
              this._visitedParent = r;
              if (this.ignoreElementEnd) {
                return this._previous();
              } else {
                return Jh("elementEnd", r, t, e);
              }
            } else {
              this.position = e;
              return Jh("elementStart", r, t, e, 1);
            }
          } else if (r instanceof qh) {
            let o;
            if (this.singleCharacters) {
              o = 1;
            } else {
              let t = r.startOffset;
              if (
                this._boundaryStartParent == n &&
                this.boundaries.start.offset > t
              ) {
                t = this.boundaries.start.offset;
              }
              o = e.offset - t;
            }
            const i = e.offset - r.startOffset;
            const s = new $h(r, i - o, o);
            e.offset -= o;
            this.position = e;
            return Jh("text", s, t, e, o);
          } else {
            e.path.pop();
            this.position = e;
            this._visitedParent = n.parent;
            return Jh("elementStart", n, t, e, 1);
          }
        }
      }
      function Jh(t, e, n, o, i) {
        return {
          done: false,
          value: {
            type: t,
            item: e,
            previousPosition: n,
            nextPosition: o,
            length: i,
          },
        };
      }
      class Yh {
        constructor(t, e, n = "toNone") {
          if (!t.is("element") && !t.is("documentFragment")) {
            throw new ss["a"]("model-position-root-invalid", t);
          }
          if (!(e instanceof Array) || e.length === 0) {
            throw new ss["a"]("model-position-path-incorrect-format", t, {
              path: e,
            });
          }
          if (t.is("rootElement")) {
            e = e.slice();
          } else {
            e = [...t.getPath(), ...e];
            t = t.root;
          }
          this.root = t;
          this.path = e;
          this.stickiness = n;
        }
        get offset() {
          return this.path[this.path.length - 1];
        }
        set offset(t) {
          this.path[this.path.length - 1] = t;
        }
        get parent() {
          let t = this.root;
          for (let e = 0; e < this.path.length - 1; e++) {
            t = t.getChild(t.offsetToIndex(this.path[e]));
            if (!t) {
              throw new ss["a"]("model-position-path-incorrect", this, {
                position: this,
              });
            }
          }
          if (t.is("$text")) {
            throw new ss["a"]("model-position-path-incorrect", this, {
              position: this,
            });
          }
          return t;
        }
        get index() {
          return this.parent.offsetToIndex(this.offset);
        }
        get textNode() {
          return Qh(this, this.parent);
        }
        get nodeAfter() {
          const t = this.parent;
          return Xh(this, t, Qh(this, t));
        }
        get nodeBefore() {
          const t = this.parent;
          return Zh(this, t, Qh(this, t));
        }
        get isAtStart() {
          return this.offset === 0;
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset;
        }
        compareWith(t) {
          if (this.root != t.root) {
            return "different";
          }
          const e = Fs(this.path, t.path);
          switch (e) {
            case "same":
              return "same";
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return this.path[e] < t.path[e] ? "before" : "after";
          }
        }
        getLastMatchingPosition(t, e = {}) {
          e.startPosition = this;
          const n = new Hh(e);
          n.skip(t);
          return n.position;
        }
        getParentPath() {
          return this.path.slice(0, -1);
        }
        getAncestors() {
          const t = this.parent;
          if (t.is("documentFragment")) {
            return [t];
          } else {
            return t.getAncestors({ includeSelf: true });
          }
        }
        findAncestor(t) {
          const e = this.parent;
          if (e.is("element")) {
            return e.findAncestor(t, { includeSelf: true });
          }
          return null;
        }
        getCommonPath(t) {
          if (this.root != t.root) {
            return [];
          }
          const e = Fs(this.path, t.path);
          const n =
            typeof e == "string"
              ? Math.min(this.path.length, t.path.length)
              : e;
          return this.path.slice(0, n);
        }
        getCommonAncestor(t) {
          const e = this.getAncestors();
          const n = t.getAncestors();
          let o = 0;
          while (e[o] == n[o] && e[o]) {
            o++;
          }
          return o === 0 ? null : e[o - 1];
        }
        getShiftedBy(t) {
          const e = this.clone();
          const n = e.offset + t;
          e.offset = n < 0 ? 0 : n;
          return e;
        }
        isAfter(t) {
          return this.compareWith(t) == "after";
        }
        isBefore(t) {
          return this.compareWith(t) == "before";
        }
        isEqual(t) {
          return this.compareWith(t) == "same";
        }
        isTouching(t) {
          let e = null;
          let n = null;
          const o = this.compareWith(t);
          switch (o) {
            case "same":
              return true;
            case "before":
              e = Yh._createAt(this);
              n = Yh._createAt(t);
              break;
            case "after":
              e = Yh._createAt(t);
              n = Yh._createAt(this);
              break;
            default:
              return false;
          }
          let i = e.parent;
          while (e.path.length + n.path.length) {
            if (e.isEqual(n)) {
              return true;
            }
            if (e.path.length > n.path.length) {
              if (e.offset !== i.maxOffset) {
                return false;
              }
              e.path = e.path.slice(0, -1);
              i = i.parent;
              e.offset++;
            } else {
              if (n.offset !== 0) {
                return false;
              }
              n.path = n.path.slice(0, -1);
            }
          }
        }
        is(t) {
          return t === "position" || t === "model:position";
        }
        hasSameParentAs(t) {
          if (this.root !== t.root) {
            return false;
          }
          const e = this.getParentPath();
          const n = t.getParentPath();
          return Fs(e, n) == "same";
        }
        getTransformedByOperation(t) {
          let e;
          switch (t.type) {
            case "insert":
              e = this._getTransformedByInsertOperation(t);
              break;
            case "move":
            case "remove":
            case "reinsert":
              e = this._getTransformedByMoveOperation(t);
              break;
            case "split":
              e = this._getTransformedBySplitOperation(t);
              break;
            case "merge":
              e = this._getTransformedByMergeOperation(t);
              break;
            default:
              e = Yh._createAt(this);
              break;
          }
          return e;
        }
        _getTransformedByInsertOperation(t) {
          return this._getTransformedByInsertion(t.position, t.howMany);
        }
        _getTransformedByMoveOperation(t) {
          return this._getTransformedByMove(
            t.sourcePosition,
            t.targetPosition,
            t.howMany
          );
        }
        _getTransformedBySplitOperation(t) {
          const e = t.movedRange;
          const n =
            e.containsPosition(this) ||
            (e.start.isEqual(this) && this.stickiness == "toNext");
          if (n) {
            return this._getCombined(t.splitPosition, t.moveTargetPosition);
          } else {
            if (t.graveyardPosition) {
              return this._getTransformedByMove(
                t.graveyardPosition,
                t.insertionPosition,
                1
              );
            } else {
              return this._getTransformedByInsertion(t.insertionPosition, 1);
            }
          }
        }
        _getTransformedByMergeOperation(t) {
          const e = t.movedRange;
          const n = e.containsPosition(this) || e.start.isEqual(this);
          let o;
          if (n) {
            o = this._getCombined(t.sourcePosition, t.targetPosition);
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              o = o._getTransformedByDeletion(t.deletionPosition, 1);
            }
          } else if (this.isEqual(t.deletionPosition)) {
            o = Yh._createAt(t.deletionPosition);
          } else {
            o = this._getTransformedByMove(
              t.deletionPosition,
              t.graveyardPosition,
              1
            );
          }
          return o;
        }
        _getTransformedByDeletion(t, e) {
          const n = Yh._createAt(this);
          if (this.root != t.root) {
            return n;
          }
          if (Fs(t.getParentPath(), this.getParentPath()) == "same") {
            if (t.offset < this.offset) {
              if (t.offset + e > this.offset) {
                return null;
              } else {
                n.offset -= e;
              }
            }
          } else if (Fs(t.getParentPath(), this.getParentPath()) == "prefix") {
            const o = t.path.length - 1;
            if (t.offset <= this.path[o]) {
              if (t.offset + e > this.path[o]) {
                return null;
              } else {
                n.path[o] -= e;
              }
            }
          }
          return n;
        }
        _getTransformedByInsertion(t, e) {
          const n = Yh._createAt(this);
          if (this.root != t.root) {
            return n;
          }
          if (Fs(t.getParentPath(), this.getParentPath()) == "same") {
            if (
              t.offset < this.offset ||
              (t.offset == this.offset && this.stickiness != "toPrevious")
            ) {
              n.offset += e;
            }
          } else if (Fs(t.getParentPath(), this.getParentPath()) == "prefix") {
            const o = t.path.length - 1;
            if (t.offset <= this.path[o]) {
              n.path[o] += e;
            }
          }
          return n;
        }
        _getTransformedByMove(t, e, n) {
          e = e._getTransformedByDeletion(t, n);
          if (t.isEqual(e)) {
            return Yh._createAt(this);
          }
          const o = this._getTransformedByDeletion(t, n);
          const i =
            o === null ||
            (t.isEqual(this) && this.stickiness == "toNext") ||
            (t.getShiftedBy(n).isEqual(this) &&
              this.stickiness == "toPrevious");
          if (i) {
            return this._getCombined(t, e);
          } else {
            return o._getTransformedByInsertion(e, n);
          }
        }
        _getCombined(t, e) {
          const n = t.path.length - 1;
          const o = Yh._createAt(e);
          o.stickiness = this.stickiness;
          o.offset = o.offset + this.path[n] - t.offset;
          o.path = [...o.path, ...this.path.slice(n + 1)];
          return o;
        }
        toJSON() {
          return {
            root: this.root.toJSON(),
            path: Array.from(this.path),
            stickiness: this.stickiness,
          };
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness);
        }
        static _createAt(t, e, n = "toNone") {
          if (t instanceof Yh) {
            return new Yh(t.root, t.path, t.stickiness);
          } else {
            const o = t;
            if (e == "end") {
              e = o.maxOffset;
            } else if (e == "before") {
              return this._createBefore(o, n);
            } else if (e == "after") {
              return this._createAfter(o, n);
            } else if (e !== 0 && !e) {
              throw new ss["a"]("model-createpositionat-offset-required", [
                this,
                t,
              ]);
            }
            if (!o.is("element") && !o.is("documentFragment")) {
              throw new ss["a"]("model-position-parent-incorrect", [this, t]);
            }
            const i = o.getPath();
            i.push(e);
            return new this(o.root, i, n);
          }
        }
        static _createAfter(t, e) {
          if (!t.parent) {
            throw new ss["a"]("model-position-after-root", [this, t], {
              root: t,
            });
          }
          return this._createAt(t.parent, t.endOffset, e);
        }
        static _createBefore(t, e) {
          if (!t.parent) {
            throw new ss["a"]("model-position-before-root", t, { root: t });
          }
          return this._createAt(t.parent, t.startOffset, e);
        }
        static fromJSON(t, e) {
          if (t.root === "$graveyard") {
            const n = new Yh(e.graveyard, t.path);
            n.stickiness = t.stickiness;
            return n;
          }
          if (!e.getRoot(t.root)) {
            throw new ss["a"]("model-position-fromjson-no-root", e, {
              rootName: t.root,
            });
          }
          return new Yh(e.getRoot(t.root), t.path, t.stickiness);
        }
      }
      function Qh(t, e) {
        const n = e.getChild(e.offsetToIndex(t.offset));
        if (n && n.is("$text") && n.startOffset < t.offset) {
          return n;
        }
        return null;
      }
      function Xh(t, e, n) {
        if (n !== null) {
          return null;
        }
        return e.getChild(e.offsetToIndex(t.offset));
      }
      function Zh(t, e, n) {
        if (n !== null) {
          return null;
        }
        return e.getChild(e.offsetToIndex(t.offset) - 1);
      }
      class tf {
        constructor(t, e = null) {
          this.start = Yh._createAt(t);
          this.end = e ? Yh._createAt(e) : Yh._createAt(t);
          this.start.stickiness = this.isCollapsed ? "toNone" : "toNext";
          this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
        }
        *[Symbol.iterator]() {
          yield* new Hh({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          const t = this.start.getParentPath();
          const e = this.end.getParentPath();
          return Fs(t, e) == "same";
        }
        get root() {
          return this.start.root;
        }
        containsPosition(t) {
          return t.isAfter(this.start) && t.isBefore(this.end);
        }
        containsRange(t, e = false) {
          if (t.isCollapsed) {
            e = false;
          }
          const n =
            this.containsPosition(t.start) ||
            (e && this.start.isEqual(t.start));
          const o =
            this.containsPosition(t.end) || (e && this.end.isEqual(t.end));
          return n && o;
        }
        containsItem(t) {
          const e = Yh._createBefore(t);
          return this.containsPosition(e) || this.start.isEqual(e);
        }
        is(t) {
          return t === "range" || t === "model:range";
        }
        isEqual(t) {
          return this.start.isEqual(t.start) && this.end.isEqual(t.end);
        }
        isIntersecting(t) {
          return this.start.isBefore(t.end) && this.end.isAfter(t.start);
        }
        getDifference(t) {
          const e = [];
          if (this.isIntersecting(t)) {
            if (this.containsPosition(t.start)) {
              e.push(new tf(this.start, t.start));
            }
            if (this.containsPosition(t.end)) {
              e.push(new tf(t.end, this.end));
            }
          } else {
            e.push(new tf(this.start, this.end));
          }
          return e;
        }
        getIntersection(t) {
          if (this.isIntersecting(t)) {
            let e = this.start;
            let n = this.end;
            if (this.containsPosition(t.start)) {
              e = t.start;
            }
            if (this.containsPosition(t.end)) {
              n = t.end;
            }
            return new tf(e, n);
          }
          return null;
        }
        getJoined(t, e = false) {
          let n = this.isIntersecting(t);
          if (!n) {
            if (this.start.isBefore(t.start)) {
              n = e ? this.end.isTouching(t.start) : this.end.isEqual(t.start);
            } else {
              n = e ? t.end.isTouching(this.start) : t.end.isEqual(this.start);
            }
          }
          if (!n) {
            return null;
          }
          let o = this.start;
          let i = this.end;
          if (t.start.isBefore(o)) {
            o = t.start;
          }
          if (t.end.isAfter(i)) {
            i = t.end;
          }
          return new tf(o, i);
        }
        getMinimalFlatRanges() {
          const t = [];
          const e = this.start.getCommonPath(this.end).length;
          const n = Yh._createAt(this.start);
          let o = n.parent;
          while (n.path.length > e + 1) {
            const e = o.maxOffset - n.offset;
            if (e !== 0) {
              t.push(new tf(n, n.getShiftedBy(e)));
            }
            n.path = n.path.slice(0, -1);
            n.offset++;
            o = o.parent;
          }
          while (n.path.length <= this.end.path.length) {
            const e = this.end.path[n.path.length - 1];
            const o = e - n.offset;
            if (o !== 0) {
              t.push(new tf(n, n.getShiftedBy(o)));
            }
            n.offset = e;
            n.path.push(0);
          }
          return t;
        }
        getWalker(t = {}) {
          t.boundaries = this;
          return new Hh(t);
        }
        *getItems(t = {}) {
          t.boundaries = this;
          t.ignoreElementEnd = true;
          const e = new Hh(t);
          for (const t of e) {
            yield t.item;
          }
        }
        *getPositions(t = {}) {
          t.boundaries = this;
          const e = new Hh(t);
          yield e.position;
          for (const t of e) {
            yield t.nextPosition;
          }
        }
        getTransformedByOperation(t) {
          switch (t.type) {
            case "insert":
              return this._getTransformedByInsertOperation(t);
            case "move":
            case "remove":
            case "reinsert":
              return this._getTransformedByMoveOperation(t);
            case "split":
              return [this._getTransformedBySplitOperation(t)];
            case "merge":
              return [this._getTransformedByMergeOperation(t)];
          }
          return [new tf(this.start, this.end)];
        }
        getTransformedByOperations(t) {
          const e = [new tf(this.start, this.end)];
          for (const n of t) {
            for (let t = 0; t < e.length; t++) {
              const o = e[t].getTransformedByOperation(n);
              e.splice(t, 1, ...o);
              t += o.length - 1;
            }
          }
          for (let t = 0; t < e.length; t++) {
            const n = e[t];
            for (let o = t + 1; o < e.length; o++) {
              const t = e[o];
              if (n.containsRange(t) || t.containsRange(n) || n.isEqual(t)) {
                e.splice(o, 1);
              }
            }
          }
          return e;
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed) {
            return null;
          }
          const t = this.start.nodeAfter;
          const e = this.end.nodeBefore;
          if (t && t.is("element") && t === e) {
            return t;
          }
          return null;
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() };
        }
        clone() {
          return new this.constructor(this.start, this.end);
        }
        _getTransformedByInsertOperation(t, e = false) {
          return this._getTransformedByInsertion(t.position, t.howMany, e);
        }
        _getTransformedByMoveOperation(t, e = false) {
          const n = t.sourcePosition;
          const o = t.howMany;
          const i = t.targetPosition;
          return this._getTransformedByMove(n, i, o, e);
        }
        _getTransformedBySplitOperation(t) {
          const e = this.start._getTransformedBySplitOperation(t);
          let n = this.end._getTransformedBySplitOperation(t);
          if (this.end.isEqual(t.insertionPosition)) {
            n = this.end.getShiftedBy(1);
          }
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1);
          }
          return new tf(e, n);
        }
        _getTransformedByMergeOperation(t) {
          if (
            this.start.isEqual(t.targetPosition) &&
            this.end.isEqual(t.deletionPosition)
          ) {
            return new tf(this.start);
          }
          let e = this.start._getTransformedByMergeOperation(t);
          let n = this.end._getTransformedByMergeOperation(t);
          if (e.root != n.root) {
            n = this.end.getShiftedBy(-1);
          }
          if (e.isAfter(n)) {
            if (t.sourcePosition.isBefore(t.targetPosition)) {
              e = Yh._createAt(n);
              e.offset = 0;
            } else {
              if (!t.deletionPosition.isEqual(e)) {
                n = t.deletionPosition;
              }
              e = t.targetPosition;
            }
            return new tf(e, n);
          }
          return new tf(e, n);
        }
        _getTransformedByInsertion(t, e, n = false) {
          if (n && this.containsPosition(t)) {
            return [
              new tf(this.start, t),
              new tf(
                t.getShiftedBy(e),
                this.end._getTransformedByInsertion(t, e)
              ),
            ];
          } else {
            const n = new tf(this.start, this.end);
            n.start = n.start._getTransformedByInsertion(t, e);
            n.end = n.end._getTransformedByInsertion(t, e);
            return [n];
          }
        }
        _getTransformedByMove(t, e, n, o = false) {
          if (this.isCollapsed) {
            const o = this.start._getTransformedByMove(t, e, n);
            return [new tf(o)];
          }
          const i = tf._createFromPositionAndShift(t, n);
          const r = e._getTransformedByDeletion(t, n);
          if (this.containsPosition(e) && !o) {
            if (
              i.containsPosition(this.start) ||
              i.containsPosition(this.end)
            ) {
              const o = this.start._getTransformedByMove(t, e, n);
              const i = this.end._getTransformedByMove(t, e, n);
              return [new tf(o, i)];
            }
          }
          let s;
          const a = this.getDifference(i);
          let c = null;
          const l = this.getIntersection(i);
          if (a.length == 1) {
            c = new tf(
              a[0].start._getTransformedByDeletion(t, n),
              a[0].end._getTransformedByDeletion(t, n)
            );
          } else if (a.length == 2) {
            c = new tf(this.start, this.end._getTransformedByDeletion(t, n));
          }
          if (c) {
            s = c._getTransformedByInsertion(r, n, l !== null || o);
          } else {
            s = [];
          }
          if (l) {
            const t = new tf(
              l.start._getCombined(i.start, r),
              l.end._getCombined(i.start, r)
            );
            if (s.length == 2) {
              s.splice(1, 0, t);
            } else {
              s.push(t);
            }
          }
          return s;
        }
        _getTransformedByDeletion(t, e) {
          let n = this.start._getTransformedByDeletion(t, e);
          let o = this.end._getTransformedByDeletion(t, e);
          if (n == null && o == null) {
            return null;
          }
          if (n == null) {
            n = t;
          }
          if (o == null) {
            o = t;
          }
          return new tf(n, o);
        }
        static _createFromPositionAndShift(t, e) {
          const n = t;
          const o = t.getShiftedBy(e);
          return e > 0 ? new this(n, o) : new this(o, n);
        }
        static _createIn(t) {
          return new this(Yh._createAt(t, 0), Yh._createAt(t, t.maxOffset));
        }
        static _createOn(t) {
          return this._createFromPositionAndShift(
            Yh._createBefore(t),
            t.offsetSize
          );
        }
        static _createFromRanges(t) {
          if (t.length === 0) {
            throw new ss["a"]("range-create-from-ranges-empty-array", null);
          } else if (t.length == 1) {
            return t[0].clone();
          }
          const e = t[0];
          t.sort((t, e) => (t.start.isAfter(e.start) ? 1 : -1));
          const n = t.indexOf(e);
          const o = new this(e.start, e.end);
          if (n > 0) {
            for (let e = n - 1; true; e++) {
              if (t[e].end.isEqual(o.start)) {
                o.start = Yh._createAt(t[e].start);
              } else {
                break;
              }
            }
          }
          for (let e = n + 1; e < t.length; e++) {
            if (t[e].start.isEqual(o.end)) {
              o.end = Yh._createAt(t[e].end);
            } else {
              break;
            }
          }
          return o;
        }
        static fromJSON(t, e) {
          return new this(Yh.fromJSON(t.start, e), Yh.fromJSON(t.end, e));
        }
      }
      class ef {
        constructor() {
          this._modelToViewMapping = new WeakMap();
          this._viewToModelMapping = new WeakMap();
          this._viewToModelLengthCallbacks = new Map();
          this._markerNameToElements = new Map();
          this._elementToMarkerNames = new Map();
          this._unboundMarkerNames = new Set();
          this.on(
            "modelToViewPosition",
            (t, e) => {
              if (e.viewPosition) {
                return;
              }
              const n = this._modelToViewMapping.get(e.modelPosition.parent);
              e.viewPosition = this.findPositionIn(n, e.modelPosition.offset);
            },
            { priority: "low" }
          );
          this.on(
            "viewToModelPosition",
            (t, e) => {
              if (e.modelPosition) {
                return;
              }
              const n = this.findMappedViewAncestor(e.viewPosition);
              const o = this._viewToModelMapping.get(n);
              const i = this._toModelOffset(
                e.viewPosition.parent,
                e.viewPosition.offset,
                n
              );
              e.modelPosition = Yh._createAt(o, i);
            },
            { priority: "low" }
          );
        }
        bindElements(t, e) {
          this._modelToViewMapping.set(t, e);
          this._viewToModelMapping.set(e, t);
        }
        unbindViewElement(t) {
          const e = this.toModelElement(t);
          this._viewToModelMapping.delete(t);
          if (this._elementToMarkerNames.has(t)) {
            for (const e of this._elementToMarkerNames.get(t)) {
              this._unboundMarkerNames.add(e);
            }
          }
          if (this._modelToViewMapping.get(e) == t) {
            this._modelToViewMapping.delete(e);
          }
        }
        unbindModelElement(t) {
          const e = this.toViewElement(t);
          this._modelToViewMapping.delete(t);
          if (this._viewToModelMapping.get(e) == t) {
            this._viewToModelMapping.delete(e);
          }
        }
        bindElementToMarker(t, e) {
          const n = this._markerNameToElements.get(e) || new Set();
          n.add(t);
          const o = this._elementToMarkerNames.get(t) || new Set();
          o.add(e);
          this._markerNameToElements.set(e, n);
          this._elementToMarkerNames.set(t, o);
        }
        unbindElementFromMarkerName(t, e) {
          const n = this._markerNameToElements.get(e);
          if (n) {
            n.delete(t);
            if (n.size == 0) {
              this._markerNameToElements.delete(e);
            }
          }
          const o = this._elementToMarkerNames.get(t);
          if (o) {
            o.delete(e);
            if (o.size == 0) {
              this._elementToMarkerNames.delete(t);
            }
          }
        }
        flushUnboundMarkerNames() {
          const t = Array.from(this._unboundMarkerNames);
          this._unboundMarkerNames.clear();
          return t;
        }
        clearBindings() {
          this._modelToViewMapping = new WeakMap();
          this._viewToModelMapping = new WeakMap();
          this._markerNameToElements = new Map();
          this._elementToMarkerNames = new Map();
          this._unboundMarkerNames = new Set();
        }
        toModelElement(t) {
          return this._viewToModelMapping.get(t);
        }
        toViewElement(t) {
          return this._modelToViewMapping.get(t);
        }
        toModelRange(t) {
          return new tf(
            this.toModelPosition(t.start),
            this.toModelPosition(t.end)
          );
        }
        toViewRange(t) {
          return new hl(
            this.toViewPosition(t.start),
            this.toViewPosition(t.end)
          );
        }
        toModelPosition(t) {
          const e = { viewPosition: t, mapper: this };
          this.fire("viewToModelPosition", e);
          return e.modelPosition;
        }
        toViewPosition(t, e = { isPhantom: false }) {
          const n = { modelPosition: t, mapper: this, isPhantom: e.isPhantom };
          this.fire("modelToViewPosition", n);
          return n.viewPosition;
        }
        markerNameToElements(t) {
          const e = this._markerNameToElements.get(t);
          if (!e) {
            return null;
          }
          const n = new Set();
          for (const t of e) {
            if (t.is("attributeElement")) {
              for (const e of t.getElementsWithSameId()) {
                n.add(e);
              }
            } else {
              n.add(t);
            }
          }
          return n;
        }
        registerViewToModelLength(t, e) {
          this._viewToModelLengthCallbacks.set(t, e);
        }
        findMappedViewAncestor(t) {
          let e = t.parent;
          while (!this._viewToModelMapping.has(e)) {
            e = e.parent;
          }
          return e;
        }
        _toModelOffset(t, e, n) {
          if (n != t) {
            const o = this._toModelOffset(t.parent, t.index, n);
            const i = this._toModelOffset(t, e, t);
            return o + i;
          }
          if (t.is("$text")) {
            return e;
          }
          let o = 0;
          for (let n = 0; n < e; n++) {
            o += this.getModelLength(t.getChild(n));
          }
          return o;
        }
        getModelLength(t) {
          if (this._viewToModelLengthCallbacks.get(t.name)) {
            const e = this._viewToModelLengthCallbacks.get(t.name);
            return e(t);
          } else if (this._viewToModelMapping.has(t)) {
            return 1;
          } else if (t.is("$text")) {
            return t.data.length;
          } else if (t.is("uiElement")) {
            return 0;
          } else {
            let e = 0;
            for (const n of t.getChildren()) {
              e += this.getModelLength(n);
            }
            return e;
          }
        }
        findPositionIn(t, e) {
          let n;
          let o = 0;
          let i = 0;
          let r = 0;
          if (t.is("$text")) {
            return new ul(t, e);
          }
          while (i < e) {
            n = t.getChild(r);
            o = this.getModelLength(n);
            i += o;
            r++;
          }
          if (i == e) {
            return this._moveViewPositionToTextNode(new ul(t, r));
          } else {
            return this.findPositionIn(n, e - (i - o));
          }
        }
        _moveViewPositionToTextNode(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          if (e instanceof zs) {
            return new ul(e, e.data.length);
          } else if (n instanceof zs) {
            return new ul(n, 0);
          }
          return t;
        }
      }
      Cs(ef, ds);
      class nf {
        constructor() {
          this._consumable = new Map();
          this._textProxyRegistry = new Map();
        }
        add(t, e) {
          e = of(e);
          if (t instanceof $h) {
            t = this._getSymbolForTextProxy(t);
          }
          if (!this._consumable.has(t)) {
            this._consumable.set(t, new Map());
          }
          this._consumable.get(t).set(e, true);
        }
        consume(t, e) {
          e = of(e);
          if (t instanceof $h) {
            t = this._getSymbolForTextProxy(t);
          }
          if (this.test(t, e)) {
            this._consumable.get(t).set(e, false);
            return true;
          } else {
            return false;
          }
        }
        test(t, e) {
          e = of(e);
          if (t instanceof $h) {
            t = this._getSymbolForTextProxy(t);
          }
          const n = this._consumable.get(t);
          if (n === undefined) {
            return null;
          }
          const o = n.get(e);
          if (o === undefined) {
            return null;
          }
          return o;
        }
        revert(t, e) {
          e = of(e);
          if (t instanceof $h) {
            t = this._getSymbolForTextProxy(t);
          }
          const n = this.test(t, e);
          if (n === false) {
            this._consumable.get(t).set(e, true);
            return true;
          } else if (n === true) {
            return false;
          }
          return null;
        }
        _getSymbolForTextProxy(t) {
          let e = null;
          const n = this._textProxyRegistry.get(t.startOffset);
          if (n) {
            const o = n.get(t.endOffset);
            if (o) {
              e = o.get(t.parent);
            }
          }
          if (!e) {
            e = this._addSymbolForTextProxy(
              t.startOffset,
              t.endOffset,
              t.parent
            );
          }
          return e;
        }
        _addSymbolForTextProxy(t, e, n) {
          const o = Symbol("textProxySymbol");
          let i, r;
          i = this._textProxyRegistry.get(t);
          if (!i) {
            i = new Map();
            this._textProxyRegistry.set(t, i);
          }
          r = i.get(e);
          if (!r) {
            r = new Map();
            i.set(e, r);
          }
          r.set(n, o);
          return o;
        }
      }
      function of(t) {
        const e = t.split(":");
        return e.length > 1 ? e[0] + ":" + e[1] : e[0];
      }
      class rf {
        constructor(t) {
          this.conversionApi = Object.assign({ dispatcher: this }, t);
          this._reconversionEventsMapping = new Map();
        }
        convertChanges(t, e, n) {
          for (const e of t.getMarkersToRemove()) {
            this.convertMarkerRemove(e.name, e.range, n);
          }
          const o = this._mapChangesWithAutomaticReconversion(t);
          for (const t of o) {
            if (t.type === "insert") {
              this.convertInsert(
                tf._createFromPositionAndShift(t.position, t.length),
                n
              );
            } else if (t.type === "remove") {
              this.convertRemove(t.position, t.length, t.name, n);
            } else if (t.type === "reconvert") {
              this.reconvertElement(t.element, n);
            } else {
              this.convertAttribute(
                t.range,
                t.attributeKey,
                t.attributeOldValue,
                t.attributeNewValue,
                n
              );
            }
          }
          for (const t of this.conversionApi.mapper.flushUnboundMarkerNames()) {
            const o = e.get(t).getRange();
            this.convertMarkerRemove(t, o, n);
            this.convertMarkerAdd(t, o, n);
          }
          for (const e of t.getMarkersToAdd()) {
            this.convertMarkerAdd(e.name, e.range, n);
          }
        }
        convertInsert(t, e) {
          this.conversionApi.writer = e;
          this.conversionApi.consumable = this._createInsertConsumable(t);
          for (const e of Array.from(t).map(cf)) {
            this._convertInsertWithAttributes(e);
          }
          this._clearConversionApi();
        }
        convertRemove(t, e, n, o) {
          this.conversionApi.writer = o;
          this.fire(
            "remove:" + n,
            { position: t, length: e },
            this.conversionApi
          );
          this._clearConversionApi();
        }
        convertAttribute(t, e, n, o, i) {
          this.conversionApi.writer = i;
          this.conversionApi.consumable = this._createConsumableForRange(
            t,
            `attribute:${e}`
          );
          for (const i of t) {
            const t = i.item;
            const r = tf._createFromPositionAndShift(
              i.previousPosition,
              i.length
            );
            const s = {
              item: t,
              range: r,
              attributeKey: e,
              attributeOldValue: n,
              attributeNewValue: o,
            };
            this._testAndFire(`attribute:${e}`, s);
          }
          this._clearConversionApi();
        }
        reconvertElement(t, e) {
          const n = tf._createOn(t);
          this.conversionApi.writer = e;
          this.conversionApi.consumable = this._createInsertConsumable(n);
          const o = this.conversionApi.mapper;
          const i = o.toViewElement(t);
          e.remove(i);
          this._convertInsertWithAttributes({ item: t, range: n });
          const r = o.toViewElement(t);
          for (const n of tf._createIn(t)) {
            const { item: t } = n;
            const i = lf(t, o);
            if (i) {
              if (i.root !== r.root) {
                e.move(
                  e.createRangeOn(i),
                  o.toViewPosition(Yh._createBefore(t))
                );
              }
            } else {
              this._convertInsertWithAttributes(cf(n));
            }
          }
          o.unbindViewElement(i);
          this._clearConversionApi();
        }
        convertSelection(t, e, n) {
          const o = Array.from(e.getMarkersAtPosition(t.getFirstPosition()));
          this.conversionApi.writer = n;
          this.conversionApi.consumable = this._createSelectionConsumable(t, o);
          this.fire("selection", { selection: t }, this.conversionApi);
          if (!t.isCollapsed) {
            return;
          }
          for (const e of o) {
            const n = e.getRange();
            if (!sf(t.getFirstPosition(), e, this.conversionApi.mapper)) {
              continue;
            }
            const o = { item: t, markerName: e.name, markerRange: n };
            if (this.conversionApi.consumable.test(t, "addMarker:" + e.name)) {
              this.fire("addMarker:" + e.name, o, this.conversionApi);
            }
          }
          for (const e of t.getAttributeKeys()) {
            const n = {
              item: t,
              range: t.getFirstRange(),
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: t.getAttribute(e),
            };
            if (
              this.conversionApi.consumable.test(
                t,
                "attribute:" + n.attributeKey
              )
            ) {
              this.fire(
                "attribute:" + n.attributeKey + ":$text",
                n,
                this.conversionApi
              );
            }
          }
          this._clearConversionApi();
        }
        convertMarkerAdd(t, e, n) {
          if (!e.root.document || e.root.rootName == "$graveyard") {
            return;
          }
          this.conversionApi.writer = n;
          const o = "addMarker:" + t;
          const i = new nf();
          i.add(e, o);
          this.conversionApi.consumable = i;
          this.fire(o, { markerName: t, markerRange: e }, this.conversionApi);
          if (!i.test(e, o)) {
            return;
          }
          this.conversionApi.consumable = this._createConsumableForRange(e, o);
          for (const n of e.getItems()) {
            if (!this.conversionApi.consumable.test(n, o)) {
              continue;
            }
            const i = {
              item: n,
              range: tf._createOn(n),
              markerName: t,
              markerRange: e,
            };
            this.fire(o, i, this.conversionApi);
          }
          this._clearConversionApi();
        }
        convertMarkerRemove(t, e, n) {
          if (!e.root.document || e.root.rootName == "$graveyard") {
            return;
          }
          this.conversionApi.writer = n;
          this.fire(
            "removeMarker:" + t,
            { markerName: t, markerRange: e },
            this.conversionApi
          );
          this._clearConversionApi();
        }
        _mapReconversionTriggerEvent(t, e) {
          this._reconversionEventsMapping.set(e, t);
        }
        _createInsertConsumable(t) {
          const e = new nf();
          for (const n of t) {
            const t = n.item;
            e.add(t, "insert");
            for (const n of t.getAttributeKeys()) {
              e.add(t, "attribute:" + n);
            }
          }
          return e;
        }
        _createConsumableForRange(t, e) {
          const n = new nf();
          for (const o of t.getItems()) {
            n.add(o, e);
          }
          return n;
        }
        _createSelectionConsumable(t, e) {
          const n = new nf();
          n.add(t, "selection");
          for (const o of e) {
            n.add(t, "addMarker:" + o.name);
          }
          for (const e of t.getAttributeKeys()) {
            n.add(t, "attribute:" + e);
          }
          return n;
        }
        _testAndFire(t, e) {
          if (!this.conversionApi.consumable.test(e.item, t)) {
            return;
          }
          this.fire(af(t, e), e, this.conversionApi);
        }
        _clearConversionApi() {
          delete this.conversionApi.writer;
          delete this.conversionApi.consumable;
        }
        _convertInsertWithAttributes(t) {
          this._testAndFire("insert", t);
          for (const e of t.item.getAttributeKeys()) {
            t.attributeKey = e;
            t.attributeOldValue = null;
            t.attributeNewValue = t.item.getAttribute(e);
            this._testAndFire(`attribute:${e}`, t);
          }
        }
        _mapChangesWithAutomaticReconversion(t) {
          const e = new Set();
          const n = [];
          for (const o of t.getChanges()) {
            const t = o.position || o.range.start;
            const i = t.parent;
            const r = Qh(t, i);
            if (r) {
              n.push(o);
              continue;
            }
            const s = o.type === "attribute" ? Xh(t, i, null) : i;
            if (s.is("$text")) {
              n.push(o);
              continue;
            }
            let a;
            if (o.type === "attribute") {
              a = `attribute:${o.attributeKey}:${s.name}`;
            } else {
              a = `${o.type}:${o.name}`;
            }
            if (this._isReconvertTriggerEvent(a, s.name)) {
              if (e.has(s)) {
                continue;
              }
              e.add(s);
              n.push({ type: "reconvert", element: s });
            } else {
              n.push(o);
            }
          }
          return n;
        }
        _isReconvertTriggerEvent(t, e) {
          return this._reconversionEventsMapping.get(t) === e;
        }
      }
      Cs(rf, ds);
      function sf(t, e, n) {
        const o = e.getRange();
        const i = Array.from(t.getAncestors());
        i.shift();
        i.reverse();
        const r = i.some((t) => {
          if (o.containsItem(t)) {
            const e = n.toViewElement(t);
            return !!e.getCustomProperty("addHighlight");
          }
        });
        return !r;
      }
      function af(t, e) {
        const n = e.item.name || "$text";
        return `${t}:${n}`;
      }
      function cf(t) {
        const e = t.item;
        const n = tf._createFromPositionAndShift(t.previousPosition, t.length);
        return { item: e, range: n };
      }
      function lf(t, e) {
        if (t.is("textProxy")) {
          const n = e.toViewPosition(Yh._createBefore(t));
          const o = n.parent;
          return o.is("$text") ? o : null;
        }
        return e.toViewElement(t);
      }
      class df {
        constructor(t, e, n) {
          this._lastRangeBackward = false;
          this._ranges = [];
          this._attrs = new Map();
          if (t) {
            this.setTo(t, e, n);
          }
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t.end : t.start;
          }
          return null;
        }
        get focus() {
          if (this._ranges.length > 0) {
            const t = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t.start : t.end;
          }
          return null;
        }
        get isCollapsed() {
          const t = this._ranges.length;
          if (t === 1) {
            return this._ranges[0].isCollapsed;
          } else {
            return false;
          }
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        isEqual(t) {
          if (this.rangeCount != t.rangeCount) {
            return false;
          } else if (this.rangeCount === 0) {
            return true;
          }
          if (!this.anchor.isEqual(t.anchor) || !this.focus.isEqual(t.focus)) {
            return false;
          }
          for (const e of this._ranges) {
            let n = false;
            for (const o of t._ranges) {
              if (e.isEqual(o)) {
                n = true;
                break;
              }
            }
            if (!n) {
              return false;
            }
          }
          return true;
        }
        *getRanges() {
          for (const t of this._ranges) {
            yield new tf(t.start, t.end);
          }
        }
        getFirstRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.start.isBefore(t.start)) {
              t = e;
            }
          }
          return t ? new tf(t.start, t.end) : null;
        }
        getLastRange() {
          let t = null;
          for (const e of this._ranges) {
            if (!t || e.end.isAfter(t.end)) {
              t = e;
            }
          }
          return t ? new tf(t.start, t.end) : null;
        }
        getFirstPosition() {
          const t = this.getFirstRange();
          return t ? t.start.clone() : null;
        }
        getLastPosition() {
          const t = this.getLastRange();
          return t ? t.end.clone() : null;
        }
        setTo(t, e, n) {
          if (t === null) {
            this._setRanges([]);
          } else if (t instanceof df) {
            this._setRanges(t.getRanges(), t.isBackward);
          } else if (t && typeof t.getRanges == "function") {
            this._setRanges(t.getRanges(), t.isBackward);
          } else if (t instanceof tf) {
            this._setRanges([t], !!e && !!e.backward);
          } else if (t instanceof Yh) {
            this._setRanges([new tf(t)]);
          } else if (t instanceof Kh) {
            const o = !!n && !!n.backward;
            let i;
            if (e == "in") {
              i = tf._createIn(t);
            } else if (e == "on") {
              i = tf._createOn(t);
            } else if (e !== undefined) {
              i = new tf(Yh._createAt(t, e));
            } else {
              throw new ss[
                "a"
              ]("model-selection-setto-required-second-parameter", [this, t]);
            }
            this._setRanges([i], o);
          } else if (As(t)) {
            this._setRanges(t, e && !!e.backward);
          } else {
            throw new ss["a"]("model-selection-setto-not-selectable", [
              this,
              t,
            ]);
          }
        }
        _setRanges(t, e = false) {
          t = Array.from(t);
          const n = t.some((e) => {
            if (!(e instanceof tf)) {
              throw new ss["a"]("model-selection-set-ranges-not-range", [
                this,
                t,
              ]);
            }
            return this._ranges.every((t) => !t.isEqual(e));
          });
          if (t.length === this._ranges.length && !n) {
            return;
          }
          this._removeAllRanges();
          for (const e of t) {
            this._pushRange(e);
          }
          this._lastRangeBackward = !!e;
          this.fire("change:range", { directChange: true });
        }
        setFocus(t, e) {
          if (this.anchor === null) {
            throw new ss["a"]("model-selection-setfocus-no-ranges", [this, t]);
          }
          const n = Yh._createAt(t, e);
          if (n.compareWith(this.focus) == "same") {
            return;
          }
          const o = this.anchor;
          if (this._ranges.length) {
            this._popRange();
          }
          if (n.compareWith(o) == "before") {
            this._pushRange(new tf(n, o));
            this._lastRangeBackward = true;
          } else {
            this._pushRange(new tf(o, n));
            this._lastRangeBackward = false;
          }
          this.fire("change:range", { directChange: true });
        }
        getAttribute(t) {
          return this._attrs.get(t);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        hasAttribute(t) {
          return this._attrs.has(t);
        }
        removeAttribute(t) {
          if (this.hasAttribute(t)) {
            this._attrs.delete(t);
            this.fire("change:attribute", {
              attributeKeys: [t],
              directChange: true,
            });
          }
        }
        setAttribute(t, e) {
          if (this.getAttribute(t) !== e) {
            this._attrs.set(t, e);
            this.fire("change:attribute", {
              attributeKeys: [t],
              directChange: true,
            });
          }
        }
        getSelectedElement() {
          if (this.rangeCount !== 1) {
            return null;
          }
          return this.getFirstRange().getContainedElement();
        }
        is(t) {
          return t === "selection" || t === "model:selection";
        }
        *getSelectedBlocks() {
          const t = new WeakSet();
          for (const e of this.getRanges()) {
            const n = ff(e.start, t);
            if (n && gf(n, e)) {
              yield n;
            }
            for (const n of e.getWalker()) {
              const o = n.item;
              if (n.type == "elementEnd" && hf(o, t, e)) {
                yield o;
              }
            }
            const o = ff(e.end, t);
            if (o && !e.end.isTouching(Yh._createAt(o, 0)) && gf(o, e)) {
              yield o;
            }
          }
        }
        containsEntireContent(t = this.anchor.root) {
          const e = Yh._createAt(t, 0);
          const n = Yh._createAt(t, "end");
          return (
            e.isTouching(this.getFirstPosition()) &&
            n.isTouching(this.getLastPosition())
          );
        }
        _pushRange(t) {
          this._checkRange(t);
          this._ranges.push(new tf(t.start, t.end));
        }
        _checkRange(t) {
          for (let e = 0; e < this._ranges.length; e++) {
            if (t.isIntersecting(this._ranges[e])) {
              throw new ss["a"]("model-selection-range-intersects", [this, t], {
                addedRange: t,
                intersectingRange: this._ranges[e],
              });
            }
          }
        }
        _removeAllRanges() {
          while (this._ranges.length > 0) {
            this._popRange();
          }
        }
        _popRange() {
          this._ranges.pop();
        }
      }
      Cs(df, ds);
      function uf(t, e) {
        if (e.has(t)) {
          return false;
        }
        e.add(t);
        return t.root.document.model.schema.isBlock(t) && t.parent;
      }
      function hf(t, e, n) {
        return uf(t, e) && gf(t, n);
      }
      function ff(t, e) {
        const n = t.parent;
        const o = n.root.document.model.schema;
        const i = t.parent.getAncestors({
          parentFirst: true,
          includeSelf: true,
        });
        let r = false;
        const s = i.find((t) => {
          if (r) {
            return false;
          }
          r = o.isLimit(t);
          return !r && uf(t, e);
        });
        i.forEach((t) => e.add(t));
        return s;
      }
      function gf(t, e) {
        const n = pf(t);
        if (!n) {
          return true;
        }
        const o = e.containsRange(tf._createOn(n), true);
        return !o;
      }
      function pf(t) {
        const e = t.root.document.model.schema;
        let n = t.parent;
        while (n) {
          if (e.isBlock(n)) {
            return n;
          }
          n = n.parent;
        }
      }
      class mf extends tf {
        constructor(t, e) {
          super(t, e);
          kf.call(this);
        }
        detach() {
          this.stopListening();
        }
        is(t) {
          return (
            t === "liveRange" ||
            t === "model:liveRange" ||
            t == "range" ||
            t === "model:range"
          );
        }
        toRange() {
          return new tf(this.start, this.end);
        }
        static fromRange(t) {
          return new mf(t.start, t.end);
        }
      }
      function kf() {
        this.listenTo(
          this.root.document.model,
          "applyOperation",
          (t, e) => {
            const n = e[0];
            if (!n.isDocumentOperation) {
              return;
            }
            bf.call(this, n);
          },
          { priority: "low" }
        );
      }
      function bf(t) {
        const e = this.getTransformedByOperation(t);
        const n = tf._createFromRanges(e);
        const o = !n.isEqual(this);
        const i = wf(this, t);
        let r = null;
        if (o) {
          if (n.root.rootName == "$graveyard") {
            if (t.type == "remove") {
              r = t.sourcePosition;
            } else {
              r = t.deletionPosition;
            }
          }
          const e = this.toRange();
          this.start = n.start;
          this.end = n.end;
          this.fire("change:range", e, { deletionPosition: r });
        } else if (i) {
          this.fire("change:content", this.toRange(), { deletionPosition: r });
        }
      }
      function wf(t, e) {
        switch (e.type) {
          case "insert":
            return t.containsPosition(e.position);
          case "move":
          case "remove":
          case "reinsert":
          case "merge":
            return (
              t.containsPosition(e.sourcePosition) ||
              t.start.isEqual(e.sourcePosition) ||
              t.containsPosition(e.targetPosition)
            );
          case "split":
            return (
              t.containsPosition(e.splitPosition) ||
              t.containsPosition(e.insertionPosition)
            );
        }
        return false;
      }
      Cs(mf, ds);
      const _f = "selection:";
      class Af {
        constructor(t) {
          this._selection = new Cf(t);
          this._selection.delegate("change:range").to(this);
          this._selection.delegate("change:attribute").to(this);
          this._selection.delegate("change:marker").to(this);
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden;
        }
        get markers() {
          return this._selection.markers;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        getRanges() {
          return this._selection.getRanges();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        containsEntireContent(t) {
          return this._selection.containsEntireContent(t);
        }
        destroy() {
          this._selection.destroy();
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys();
        }
        getAttributes() {
          return this._selection.getAttributes();
        }
        getAttribute(t) {
          return this._selection.getAttribute(t);
        }
        hasAttribute(t) {
          return this._selection.hasAttribute(t);
        }
        refresh() {
          this._selection._updateMarkers();
          this._selection._updateAttributes(false);
        }
        is(t) {
          return (
            t === "selection" ||
            t == "model:selection" ||
            t == "documentSelection" ||
            t == "model:documentSelection"
          );
        }
        _setFocus(t, e) {
          this._selection.setFocus(t, e);
        }
        _setTo(t, e, n) {
          this._selection.setTo(t, e, n);
        }
        _setAttribute(t, e) {
          this._selection.setAttribute(t, e);
        }
        _removeAttribute(t) {
          this._selection.removeAttribute(t);
        }
        _getStoredAttributes() {
          return this._selection._getStoredAttributes();
        }
        _overrideGravity() {
          return this._selection.overrideGravity();
        }
        _restoreGravity(t) {
          this._selection.restoreGravity(t);
        }
        static _getStoreAttributeKey(t) {
          return _f + t;
        }
        static _isStoreAttributeKey(t) {
          return t.startsWith(_f);
        }
      }
      Cs(Af, ds);
      class Cf extends df {
        constructor(t) {
          super();
          this.markers = new vs({ idProperty: "name" });
          this._model = t.model;
          this._document = t;
          this._attributePriority = new Map();
          this._selectionRestorePosition = null;
          this._hasChangedRange = false;
          this._overriddenGravityRegister = new Set();
          this.listenTo(
            this._model,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (
                !n.isDocumentOperation ||
                n.type == "marker" ||
                n.type == "rename" ||
                n.type == "noop"
              ) {
                return;
              }
              if (this._ranges.length == 0 && this._selectionRestorePosition) {
                this._fixGraveyardSelection(this._selectionRestorePosition);
              }
              this._selectionRestorePosition = null;
              if (this._hasChangedRange) {
                this._hasChangedRange = false;
                this.fire("change:range", { directChange: false });
              }
            },
            { priority: "lowest" }
          );
          this.on("change:range", () => {
            for (const t of this.getRanges()) {
              if (!this._document._validateSelectionRange(t)) {
                throw new ss["a"]("document-selection-wrong-position", this, {
                  range: t,
                });
              }
            }
          });
          this.listenTo(this._model.markers, "update", () =>
            this._updateMarkers()
          );
          this.listenTo(this._document, "change", (t, e) => {
            yf(this._model, e);
          });
        }
        get isCollapsed() {
          const t = this._ranges.length;
          return t === 0
            ? this._document._getDefaultRange().isCollapsed
            : super.isCollapsed;
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start;
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end;
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1;
        }
        get hasOwnRange() {
          return this._ranges.length > 0;
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size;
        }
        destroy() {
          for (let t = 0; t < this._ranges.length; t++) {
            this._ranges[t].detach();
          }
          this.stopListening();
        }
        *getRanges() {
          if (this._ranges.length) {
            yield* super.getRanges();
          } else {
            yield this._document._getDefaultRange();
          }
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange();
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange();
        }
        setTo(t, e, n) {
          super.setTo(t, e, n);
          this._updateAttributes(true);
          this._updateMarkers();
        }
        setFocus(t, e) {
          super.setFocus(t, e);
          this._updateAttributes(true);
          this._updateMarkers();
        }
        setAttribute(t, e) {
          if (this._setAttribute(t, e)) {
            const e = [t];
            this.fire("change:attribute", {
              attributeKeys: e,
              directChange: true,
            });
          }
        }
        removeAttribute(t) {
          if (this._removeAttribute(t)) {
            const e = [t];
            this.fire("change:attribute", {
              attributeKeys: e,
              directChange: true,
            });
          }
        }
        overrideGravity() {
          const t = ns();
          this._overriddenGravityRegister.add(t);
          if (this._overriddenGravityRegister.size === 1) {
            this._updateAttributes(true);
          }
          return t;
        }
        restoreGravity(t) {
          if (!this._overriddenGravityRegister.has(t)) {
            throw new ss["a"](
              "document-selection-gravity-wrong-restore",
              this,
              { uid: t }
            );
          }
          this._overriddenGravityRegister.delete(t);
          if (!this.isGravityOverridden) {
            this._updateAttributes(true);
          }
        }
        _popRange() {
          this._ranges.pop().detach();
        }
        _pushRange(t) {
          const e = this._prepareRange(t);
          if (e) {
            this._ranges.push(e);
          }
        }
        _prepareRange(t) {
          this._checkRange(t);
          if (t.root == this._document.graveyard) {
            return;
          }
          const e = mf.fromRange(t);
          e.on("change:range", (t, n, o) => {
            this._hasChangedRange = true;
            if (e.root == this._document.graveyard) {
              this._selectionRestorePosition = o.deletionPosition;
              const t = this._ranges.indexOf(e);
              this._ranges.splice(t, 1);
              e.detach();
            }
          });
          return e;
        }
        _updateMarkers() {
          const t = [];
          let e = false;
          for (const e of this._model.markers) {
            const n = e.getRange();
            for (const o of this.getRanges()) {
              if (n.containsRange(o, !o.isCollapsed)) {
                t.push(e);
              }
            }
          }
          const n = Array.from(this.markers);
          for (const n of t) {
            if (!this.markers.has(n)) {
              this.markers.add(n);
              e = true;
            }
          }
          for (const n of Array.from(this.markers)) {
            if (!t.includes(n)) {
              this.markers.remove(n);
              e = true;
            }
          }
          if (e) {
            this.fire("change:marker", { oldMarkers: n, directChange: false });
          }
        }
        _updateAttributes(t) {
          const e = qs(this._getSurroundingAttributes());
          const n = qs(this.getAttributes());
          if (t) {
            this._attributePriority = new Map();
            this._attrs = new Map();
          } else {
            for (const [t, e] of this._attributePriority) {
              if (e == "low") {
                this._attrs.delete(t);
                this._attributePriority.delete(t);
              }
            }
          }
          this._setAttributesTo(e);
          const o = [];
          for (const [t, e] of this.getAttributes()) {
            if (!n.has(t) || n.get(t) !== e) {
              o.push(t);
            }
          }
          for (const [t] of n) {
            if (!this.hasAttribute(t)) {
              o.push(t);
            }
          }
          if (o.length > 0) {
            this.fire("change:attribute", {
              attributeKeys: o,
              directChange: false,
            });
          }
        }
        _setAttribute(t, e, n = true) {
          const o = n ? "normal" : "low";
          if (o == "low" && this._attributePriority.get(t) == "normal") {
            return false;
          }
          const i = super.getAttribute(t);
          if (i === e) {
            return false;
          }
          this._attrs.set(t, e);
          this._attributePriority.set(t, o);
          return true;
        }
        _removeAttribute(t, e = true) {
          const n = e ? "normal" : "low";
          if (n == "low" && this._attributePriority.get(t) == "normal") {
            return false;
          }
          this._attributePriority.set(t, n);
          if (!super.hasAttribute(t)) {
            return false;
          }
          this._attrs.delete(t);
          return true;
        }
        _setAttributesTo(t) {
          const e = new Set();
          for (const [e, n] of this.getAttributes()) {
            if (t.get(e) === n) {
              continue;
            }
            this._removeAttribute(e, false);
          }
          for (const [n, o] of t) {
            const t = this._setAttribute(n, o, false);
            if (t) {
              e.add(n);
            }
          }
          return e;
        }
        *_getStoredAttributes() {
          const t = this.getFirstPosition().parent;
          if (this.isCollapsed && t.isEmpty) {
            for (const e of t.getAttributeKeys()) {
              if (e.startsWith(_f)) {
                const n = e.substr(_f.length);
                yield [n, t.getAttribute(e)];
              }
            }
          }
        }
        _getSurroundingAttributes() {
          const t = this.getFirstPosition();
          const e = this._model.schema;
          let n = null;
          if (!this.isCollapsed) {
            const t = this.getFirstRange();
            for (const o of t) {
              if (o.item.is("element") && e.isObject(o.item)) {
                break;
              }
              if (o.type == "text") {
                n = o.item.getAttributes();
                break;
              }
            }
          } else {
            const o = t.textNode ? t.textNode : t.nodeBefore;
            const i = t.textNode ? t.textNode : t.nodeAfter;
            if (!this.isGravityOverridden) {
              n = vf(o);
            }
            if (!n) {
              n = vf(i);
            }
            if (!this.isGravityOverridden && !n) {
              let t = o;
              while (t && !e.isInline(t) && !n) {
                t = t.previousSibling;
                n = vf(t);
              }
            }
            if (!n) {
              let t = i;
              while (t && !e.isInline(t) && !n) {
                t = t.nextSibling;
                n = vf(t);
              }
            }
            if (!n) {
              n = this._getStoredAttributes();
            }
          }
          return n;
        }
        _fixGraveyardSelection(t) {
          const e = this._model.schema.getNearestSelectionRange(t);
          if (e) {
            this._pushRange(e);
          }
        }
      }
      function vf(t) {
        if (t instanceof $h || t instanceof qh) {
          return t.getAttributes();
        }
        return null;
      }
      function yf(t, e) {
        const n = t.document.differ;
        for (const o of n.getChanges()) {
          if (o.type != "insert") {
            continue;
          }
          const n = o.position.parent;
          const i = o.length === n.maxOffset;
          if (i) {
            t.enqueueChange(e, (t) => {
              const e = Array.from(n.getAttributeKeys()).filter((t) =>
                t.startsWith(_f)
              );
              for (const o of e) {
                t.removeAttribute(o, n);
              }
            });
          }
        }
      }
      class xf {
        constructor(t) {
          this._dispatchers = t;
        }
        add(t) {
          for (const e of this._dispatchers) {
            t(e);
          }
          return this;
        }
      }
      var Ef = 1,
        Sf = 4;
      function Pf(t) {
        return Kr(t, Ef | Sf);
      }
      var Df = Pf;
      class Tf extends xf {
        elementToElement(t) {
          return this.add(Yf(t));
        }
        attributeToElement(t) {
          return this.add(Qf(t));
        }
        attributeToAttribute(t) {
          return this.add(Xf(t));
        }
        markerToElement(t) {
          return this.add(Zf(t));
        }
        markerToHighlight(t) {
          return this.add(eg(t));
        }
        markerToData(t) {
          return this.add(tg(t));
        }
      }
      function Bf() {
        return (t, e, n) => {
          if (!n.consumable.consume(e.item, "insert")) {
            return;
          }
          const o = n.writer;
          const i = n.mapper.toViewPosition(e.range.start);
          const r = o.createText(e.item.data);
          o.insert(i, r);
        };
      }
      function If() {
        return (t, e, n) => {
          const o = n.mapper.toViewPosition(e.position);
          const i = e.position.getShiftedBy(e.length);
          const r = n.mapper.toViewPosition(i, { isPhantom: true });
          const s = n.writer.createRange(o, r);
          const a = n.writer.remove(s.getTrimmed());
          for (const t of n.writer.createRangeIn(a).getItems()) {
            n.mapper.unbindViewElement(t);
          }
        };
      }
      function Of(t, e) {
        const n = t.createAttributeElement("span", e.attributes);
        if (e.classes) {
          n._addClass(e.classes);
        }
        if (e.priority) {
          n._priority = e.priority;
        }
        n._id = e.id;
        return n;
      }
      function Rf() {
        return (t, e, n) => {
          const o = e.selection;
          if (o.isCollapsed) {
            return;
          }
          if (!n.consumable.consume(o, "selection")) {
            return;
          }
          const i = [];
          for (const t of o.getRanges()) {
            const e = n.mapper.toViewRange(t);
            i.push(e);
          }
          n.writer.setSelection(i, { backward: o.isBackward });
        };
      }
      function Ff() {
        return (t, e, n) => {
          const o = e.selection;
          if (!o.isCollapsed) {
            return;
          }
          if (!n.consumable.consume(o, "selection")) {
            return;
          }
          const i = n.writer;
          const r = o.getFirstPosition();
          const s = n.mapper.toViewPosition(r);
          const a = i.breakAttributes(s);
          i.setSelection(a);
        };
      }
      function Nf() {
        return (t, e, n) => {
          const o = n.writer;
          const i = o.document.selection;
          for (const t of i.getRanges()) {
            if (t.isCollapsed) {
              if (t.end.parent.isAttached()) {
                n.writer.mergeAttributes(t.start);
              }
            }
          }
          o.setSelection(null);
        };
      }
      function Mf(t) {
        return (e, n, o) => {
          const i = t(n.attributeOldValue, o);
          const r = t(n.attributeNewValue, o);
          if (!i && !r) {
            return;
          }
          if (!o.consumable.consume(n.item, e.name)) {
            return;
          }
          const s = o.writer;
          const a = s.document.selection;
          if (n.item instanceof df || n.item instanceof Af) {
            s.wrap(a.getFirstRange(), r);
          } else {
            let t = o.mapper.toViewRange(n.range);
            if (n.attributeOldValue !== null && i) {
              t = s.unwrap(t, i);
            }
            if (n.attributeNewValue !== null && r) {
              s.wrap(t, r);
            }
          }
        };
      }
      function Vf(t) {
        return (e, n, o) => {
          const i = t(n.item, o);
          if (!i) {
            return;
          }
          if (!o.consumable.consume(n.item, "insert")) {
            return;
          }
          const r = o.mapper.toViewPosition(n.range.start);
          o.mapper.bindElements(n.item, i);
          o.writer.insert(r, i);
        };
      }
      function Lf(t) {
        return (e, n, o) => {
          n.isOpening = true;
          const i = t(n, o);
          n.isOpening = false;
          const r = t(n, o);
          if (!i || !r) {
            return;
          }
          const s = n.markerRange;
          if (s.isCollapsed && !o.consumable.consume(s, e.name)) {
            return;
          }
          for (const t of s) {
            if (!o.consumable.consume(t.item, e.name)) {
              return;
            }
          }
          const a = o.mapper;
          const c = o.writer;
          c.insert(a.toViewPosition(s.start), i);
          o.mapper.bindElementToMarker(i, n.markerName);
          if (!s.isCollapsed) {
            c.insert(a.toViewPosition(s.end), r);
            o.mapper.bindElementToMarker(r, n.markerName);
          }
          e.stop();
        };
      }
      function zf() {
        return (t, e, n) => {
          const o = n.mapper.markerNameToElements(e.markerName);
          if (!o) {
            return;
          }
          for (const t of o) {
            n.mapper.unbindElementFromMarkerName(t, e.markerName);
            n.writer.clear(n.writer.createRangeOn(t), t);
          }
          n.writer.clearClonedElementsGroup(e.markerName);
          t.stop();
        };
      }
      function jf(t) {
        return (e, n, o) => {
          const i = t(n.markerName, o);
          if (!i) {
            return;
          }
          const r = n.markerRange;
          if (!o.consumable.consume(r, e.name)) {
            return;
          }
          Kf(r, false, o, n, i);
          Kf(r, true, o, n, i);
          e.stop();
        };
      }
      function Kf(t, e, n, o, i) {
        const r = e ? t.start : t.end;
        const s = n.schema.checkChild(r, "$text");
        if (s) {
          const t = n.mapper.toViewPosition(r);
          $f(t, e, n, o, i);
        } else {
          let t;
          let s;
          if ((e && r.nodeAfter) || (!e && !r.nodeBefore)) {
            t = r.nodeAfter;
            s = true;
          } else {
            t = r.nodeBefore;
            s = false;
          }
          const a = n.mapper.toViewElement(t);
          qf(a, e, s, n, o, i);
        }
      }
      function qf(t, e, n, o, i, r) {
        const s = `data-${r.group}-${e ? "start" : "end"}-${
          n ? "before" : "after"
        }`;
        const a = t.hasAttribute(s) ? t.getAttribute(s).split(",") : [];
        a.unshift(r.name);
        o.writer.setAttribute(s, a.join(","), t);
        o.mapper.bindElementToMarker(t, i.markerName);
      }
      function $f(t, e, n, o, i) {
        const r = `${i.group}-${e ? "start" : "end"}`;
        const s = i.name ? { name: i.name } : null;
        const a = n.writer.createUIElement(r, s);
        n.writer.insert(t, a);
        n.mapper.bindElementToMarker(a, o.markerName);
      }
      function Wf(t) {
        return (e, n, o) => {
          const i = t(n.markerName, o);
          if (!i) {
            return;
          }
          const r = o.mapper.markerNameToElements(n.markerName);
          if (!r) {
            return;
          }
          for (const t of r) {
            o.mapper.unbindElementFromMarkerName(t, n.markerName);
            if (t.is("containerElement")) {
              s(`data-${i.group}-start-before`, t);
              s(`data-${i.group}-start-after`, t);
              s(`data-${i.group}-end-before`, t);
              s(`data-${i.group}-end-after`, t);
            } else {
              o.writer.clear(o.writer.createRangeOn(t), t);
            }
          }
          o.writer.clearClonedElementsGroup(n.markerName);
          e.stop();
          function s(t, e) {
            if (e.hasAttribute(t)) {
              const n = new Set(e.getAttribute(t).split(","));
              n.delete(i.name);
              if (n.size == 0) {
                o.writer.removeAttribute(t, e);
              } else {
                o.writer.setAttribute(t, Array.from(n).join(","), e);
              }
            }
          }
        };
      }
      function Gf(t) {
        return (e, n, o) => {
          const i = t(n.attributeOldValue, o);
          const r = t(n.attributeNewValue, o);
          if (!i && !r) {
            return;
          }
          if (!o.consumable.consume(n.item, e.name)) {
            return;
          }
          const s = o.mapper.toViewElement(n.item);
          const a = o.writer;
          if (!s) {
            throw new ss["a"]("conversion-attribute-to-attribute-on-text", [
              n,
              o,
            ]);
          }
          if (n.attributeOldValue !== null && i) {
            if (i.key == "class") {
              const t = Array.isArray(i.value) ? i.value : [i.value];
              for (const e of t) {
                a.removeClass(e, s);
              }
            } else if (i.key == "style") {
              const t = Object.keys(i.value);
              for (const e of t) {
                a.removeStyle(e, s);
              }
            } else {
              a.removeAttribute(i.key, s);
            }
          }
          if (n.attributeNewValue !== null && r) {
            if (r.key == "class") {
              const t = Array.isArray(r.value) ? r.value : [r.value];
              for (const e of t) {
                a.addClass(e, s);
              }
            } else if (r.key == "style") {
              const t = Object.keys(r.value);
              for (const e of t) {
                a.setStyle(e, r.value[e], s);
              }
            } else {
              a.setAttribute(r.key, r.value, s);
            }
          }
        };
      }
      function Uf(t) {
        return (e, n, o) => {
          if (!n.item) {
            return;
          }
          if (
            !(n.item instanceof df || n.item instanceof Af) &&
            !n.item.is("$textProxy")
          ) {
            return;
          }
          const i = sg(t, n, o);
          if (!i) {
            return;
          }
          if (!o.consumable.consume(n.item, e.name)) {
            return;
          }
          const r = o.writer;
          const s = Of(r, i);
          const a = r.document.selection;
          if (n.item instanceof df || n.item instanceof Af) {
            r.wrap(a.getFirstRange(), s, a);
          } else {
            const t = o.mapper.toViewRange(n.range);
            const e = r.wrap(t, s);
            for (const t of e.getItems()) {
              if (t.is("attributeElement") && t.isSimilar(s)) {
                o.mapper.bindElementToMarker(t, n.markerName);
                break;
              }
            }
          }
        };
      }
      function Hf(t) {
        return (e, n, o) => {
          if (!n.item) {
            return;
          }
          if (!(n.item instanceof Gh)) {
            return;
          }
          const i = sg(t, n, o);
          if (!i) {
            return;
          }
          if (!o.consumable.test(n.item, e.name)) {
            return;
          }
          const r = o.mapper.toViewElement(n.item);
          if (r && r.getCustomProperty("addHighlight")) {
            o.consumable.consume(n.item, e.name);
            for (const t of tf._createIn(n.item)) {
              o.consumable.consume(t.item, e.name);
            }
            r.getCustomProperty("addHighlight")(r, i, o.writer);
            o.mapper.bindElementToMarker(r, n.markerName);
          }
        };
      }
      function Jf(t) {
        return (e, n, o) => {
          if (n.markerRange.isCollapsed) {
            return;
          }
          const i = sg(t, n, o);
          if (!i) {
            return;
          }
          const r = Of(o.writer, i);
          const s = o.mapper.markerNameToElements(n.markerName);
          if (!s) {
            return;
          }
          for (const t of s) {
            o.mapper.unbindElementFromMarkerName(t, n.markerName);
            if (t.is("attributeElement")) {
              o.writer.unwrap(o.writer.createRangeOn(t), r);
            } else {
              t.getCustomProperty("removeHighlight")(t, i.id, o.writer);
            }
          }
          o.writer.clearClonedElementsGroup(n.markerName);
          e.stop();
        };
      }
      function Yf(t) {
        t = Df(t);
        t.view = ng(t.view, "container");
        return (e) => {
          e.on("insert:" + t.model, Vf(t.view), {
            priority: t.converterPriority || "normal",
          });
          if (t.triggerBy) {
            if (t.triggerBy.attributes) {
              for (const n of t.triggerBy.attributes) {
                e._mapReconversionTriggerEvent(
                  t.model,
                  `attribute:${n}:${t.model}`
                );
              }
            }
            if (t.triggerBy.children) {
              for (const n of t.triggerBy.children) {
                e._mapReconversionTriggerEvent(t.model, `insert:${n}`);
                e._mapReconversionTriggerEvent(t.model, `remove:${n}`);
              }
            }
          }
        };
      }
      function Qf(t) {
        t = Df(t);
        const e = t.model.key ? t.model.key : t.model;
        let n = "attribute:" + e;
        if (t.model.name) {
          n += ":" + t.model.name;
        }
        if (t.model.values) {
          for (const e of t.model.values) {
            t.view[e] = ng(t.view[e], "attribute");
          }
        } else {
          t.view = ng(t.view, "attribute");
        }
        const o = ig(t);
        return (e) => {
          e.on(n, Mf(o), { priority: t.converterPriority || "normal" });
        };
      }
      function Xf(t) {
        t = Df(t);
        const e = t.model.key ? t.model.key : t.model;
        let n = "attribute:" + e;
        if (t.model.name) {
          n += ":" + t.model.name;
        }
        if (t.model.values) {
          for (const e of t.model.values) {
            t.view[e] = rg(t.view[e]);
          }
        } else {
          t.view = rg(t.view);
        }
        const o = ig(t);
        return (e) => {
          e.on(n, Gf(o), { priority: t.converterPriority || "normal" });
        };
      }
      function Zf(t) {
        t = Df(t);
        t.view = ng(t.view, "ui");
        return (e) => {
          e.on("addMarker:" + t.model, Lf(t.view), {
            priority: t.converterPriority || "normal",
          });
          e.on("removeMarker:" + t.model, zf(t.view), {
            priority: t.converterPriority || "normal",
          });
        };
      }
      function tg(t) {
        t = Df(t);
        const e = t.model;
        if (!t.view) {
          t.view = (n) => ({ group: e, name: n.substr(t.model.length + 1) });
        }
        return (n) => {
          n.on("addMarker:" + e, jf(t.view), {
            priority: t.converterPriority || "normal",
          });
          n.on("removeMarker:" + e, Wf(t.view), {
            priority: t.converterPriority || "normal",
          });
        };
      }
      function eg(t) {
        return (e) => {
          e.on("addMarker:" + t.model, Uf(t.view), {
            priority: t.converterPriority || "normal",
          });
          e.on("addMarker:" + t.model, Hf(t.view), {
            priority: t.converterPriority || "normal",
          });
          e.on("removeMarker:" + t.model, Jf(t.view), {
            priority: t.converterPriority || "normal",
          });
        };
      }
      function ng(t, e) {
        if (typeof t == "function") {
          return t;
        }
        return (n, o) => og(t, o, e);
      }
      function og(t, e, n) {
        if (typeof t == "string") {
          t = { name: t };
        }
        let o;
        const i = e.writer;
        const r = Object.assign({}, t.attributes);
        if (n == "container") {
          o = i.createContainerElement(t.name, r);
        } else if (n == "attribute") {
          const e = { priority: t.priority || wl.DEFAULT_PRIORITY };
          o = i.createAttributeElement(t.name, r, e);
        } else {
          o = i.createUIElement(t.name, r);
        }
        if (t.styles) {
          const e = Object.keys(t.styles);
          for (const n of e) {
            i.setStyle(n, t.styles[n], o);
          }
        }
        if (t.classes) {
          const e = t.classes;
          if (typeof e == "string") {
            i.addClass(e, o);
          } else {
            for (const t of e) {
              i.addClass(t, o);
            }
          }
        }
        return o;
      }
      function ig(t) {
        if (t.model.values) {
          return (e, n) => {
            const o = t.view[e];
            if (o) {
              return o(e, n);
            }
            return null;
          };
        } else {
          return t.view;
        }
      }
      function rg(t) {
        if (typeof t == "string") {
          return (e) => ({ key: t, value: e });
        } else if (typeof t == "object") {
          if (t.value) {
            return () => t;
          } else {
            return (e) => ({ key: t.key, value: e });
          }
        } else {
          return t;
        }
      }
      function sg(t, e, n) {
        const o = typeof t == "function" ? t(e, n) : t;
        if (!o) {
          return null;
        }
        if (!o.priority) {
          o.priority = 10;
        }
        if (!o.id) {
          o.id = e.markerName;
        }
        return o;
      }
      function ag(t) {
        const { schema: e, document: n } = t.model;
        for (const o of n.getRootNames()) {
          const i = n.getRoot(o);
          if (i.isEmpty && !e.checkChild(i, "$text")) {
            if (e.checkChild(i, "paragraph")) {
              t.insertElement("paragraph", i);
              return true;
            }
          }
        }
        return false;
      }
      function cg(t, e, n) {
        const o = n.createContext(t);
        if (!n.checkChild(o, "paragraph")) {
          return false;
        }
        if (!n.checkChild(o.push("paragraph"), e)) {
          return false;
        }
        return true;
      }
      function lg(t, e) {
        const n = e.createElement("paragraph");
        e.insert(n, t);
        return e.createPositionAt(n, 0);
      }
      class dg extends xf {
        elementToElement(t) {
          return this.add(gg(t));
        }
        elementToAttribute(t) {
          return this.add(pg(t));
        }
        attributeToAttribute(t) {
          return this.add(mg(t));
        }
        elementToMarker(t) {
          Object(ss["c"])("upcast-helpers-element-to-marker-deprecated");
          return this.add(kg(t));
        }
        dataToMarker(t) {
          return this.add(bg(t));
        }
      }
      function ug() {
        return (t, e, n) => {
          if (
            !e.modelRange &&
            n.consumable.consume(e.viewItem, { name: true })
          ) {
            const { modelRange: t, modelCursor: o } = n.convertChildren(
              e.viewItem,
              e.modelCursor
            );
            e.modelRange = t;
            e.modelCursor = o;
          }
        };
      }
      function hg() {
        return (t, e, { schema: n, consumable: o, writer: i }) => {
          let r = e.modelCursor;
          if (!o.test(e.viewItem)) {
            return;
          }
          if (!n.checkChild(r, "$text")) {
            if (!cg(r, "$text", n)) {
              return;
            }
            r = lg(r, i);
          }
          o.consume(e.viewItem);
          const s = i.createText(e.viewItem.data);
          i.insert(s, r);
          e.modelRange = i.createRange(r, r.getShiftedBy(s.offsetSize));
          e.modelCursor = e.modelRange.end;
        };
      }
      function fg(t, e) {
        return (n, o) => {
          const i = o.newSelection;
          const r = [];
          for (const t of i.getRanges()) {
            r.push(e.toModelRange(t));
          }
          const s = t.createSelection(r, { backward: i.isBackward });
          if (!s.isEqual(t.document.selection)) {
            t.change((t) => {
              t.setSelection(s);
            });
          }
        };
      }
      function gg(t) {
        t = Df(t);
        const e = Ag(t);
        const n = _g(t.view);
        const o = n ? "element:" + n : "element";
        return (n) => {
          n.on(o, e, { priority: t.converterPriority || "normal" });
        };
      }
      function pg(t) {
        t = Df(t);
        yg(t);
        const e = xg(t, false);
        const n = _g(t.view);
        const o = n ? "element:" + n : "element";
        return (n) => {
          n.on(o, e, { priority: t.converterPriority || "low" });
        };
      }
      function mg(t) {
        t = Df(t);
        let e = null;
        if (typeof t.view == "string" || t.view.key) {
          e = vg(t);
        }
        yg(t, e);
        const n = xg(t, true);
        return (e) => {
          e.on("element", n, { priority: t.converterPriority || "low" });
        };
      }
      function kg(t) {
        t = Df(t);
        Pg(t);
        return gg(t);
      }
      function bg(t) {
        t = Df(t);
        if (!t.model) {
          t.model = (e) => (e ? t.view + ":" + e : t.view);
        }
        const e = Ag(Dg(t, "start"));
        const n = Ag(Dg(t, "end"));
        return (o) => {
          o.on("element:" + t.view + "-start", e, {
            priority: t.converterPriority || "normal",
          });
          o.on("element:" + t.view + "-end", n, {
            priority: t.converterPriority || "normal",
          });
          const i = is.get("low");
          const r = is.get("highest");
          const s = is.get(t.converterPriority) / r;
          o.on("element", wg(t), { priority: i + s });
        };
      }
      function wg(t) {
        return (e, n, o) => {
          const i = `data-${t.view}`;
          if (!n.modelRange) {
            n = Object.assign(n, o.convertChildren(n.viewItem, n.modelCursor));
          }
          if (
            o.consumable.consume(n.viewItem, { attributes: i + "-end-after" })
          ) {
            r(
              n.modelRange.end,
              n.viewItem.getAttribute(i + "-end-after").split(",")
            );
          }
          if (
            o.consumable.consume(n.viewItem, { attributes: i + "-start-after" })
          ) {
            r(
              n.modelRange.end,
              n.viewItem.getAttribute(i + "-start-after").split(",")
            );
          }
          if (
            o.consumable.consume(n.viewItem, { attributes: i + "-end-before" })
          ) {
            r(
              n.modelRange.start,
              n.viewItem.getAttribute(i + "-end-before").split(",")
            );
          }
          if (
            o.consumable.consume(n.viewItem, {
              attributes: i + "-start-before",
            })
          ) {
            r(
              n.modelRange.start,
              n.viewItem.getAttribute(i + "-start-before").split(",")
            );
          }
          function r(e, i) {
            for (const r of i) {
              const i = t.model(r, o);
              const s = o.writer.createElement("$marker", { "data-name": i });
              o.writer.insert(s, e);
              if (n.modelCursor.isEqual(e)) {
                n.modelCursor = n.modelCursor.getShiftedBy(1);
              } else {
                n.modelCursor = n.modelCursor._getTransformedByInsertion(e, 1);
              }
              n.modelRange = n.modelRange._getTransformedByInsertion(e, 1)[0];
            }
          }
        };
      }
      function _g(t) {
        if (typeof t == "string") {
          return t;
        }
        if (typeof t == "object" && typeof t.name == "string") {
          return t.name;
        }
        return null;
      }
      function Ag(t) {
        const e = new $s(t.view);
        return (n, o, i) => {
          const r = e.match(o.viewItem);
          if (!r) {
            return;
          }
          const s = r.match;
          s.name = true;
          if (!i.consumable.test(o.viewItem, s)) {
            return;
          }
          const a = Cg(t.model, o.viewItem, i);
          if (!a) {
            return;
          }
          if (!i.safeInsert(a, o.modelCursor)) {
            return;
          }
          i.consumable.consume(o.viewItem, s);
          i.convertChildren(o.viewItem, a);
          i.updateConversionResult(a, o);
        };
      }
      function Cg(t, e, n) {
        if (t instanceof Function) {
          return t(e, n);
        } else {
          return n.writer.createElement(t);
        }
      }
      function vg(t) {
        if (typeof t.view == "string") {
          t.view = { key: t.view };
        }
        const e = t.view.key;
        let n;
        if (e == "class" || e == "style") {
          const o = e == "class" ? "classes" : "styles";
          n = { [o]: t.view.value };
        } else {
          const o =
            typeof t.view.value == "undefined" ? /[\s\S]*/ : t.view.value;
          n = { attributes: { [e]: o } };
        }
        if (t.view.name) {
          n.name = t.view.name;
        }
        t.view = n;
        return e;
      }
      function yg(t, e = null) {
        const n = e === null ? true : (t) => t.getAttribute(e);
        const o = typeof t.model != "object" ? t.model : t.model.key;
        const i =
          typeof t.model != "object" || typeof t.model.value == "undefined"
            ? n
            : t.model.value;
        t.model = { key: o, value: i };
      }
      function xg(t, e) {
        const n = new $s(t.view);
        return (o, i, r) => {
          const s = n.match(i.viewItem);
          if (!s) {
            return;
          }
          const a = t.model.key;
          const c =
            typeof t.model.value == "function"
              ? t.model.value(i.viewItem, r)
              : t.model.value;
          if (c === null) {
            return;
          }
          if (Eg(t.view, i.viewItem)) {
            s.match.name = true;
          } else {
            delete s.match.name;
          }
          if (!r.consumable.test(i.viewItem, s.match)) {
            return;
          }
          if (!i.modelRange) {
            i = Object.assign(i, r.convertChildren(i.viewItem, i.modelCursor));
          }
          const l = Sg(i.modelRange, { key: a, value: c }, e, r);
          if (l) {
            r.consumable.consume(i.viewItem, s.match);
          }
        };
      }
      function Eg(t, e) {
        const n = typeof t == "function" ? t(e) : t;
        if (typeof n == "object" && !_g(n)) {
          return false;
        }
        return !n.classes && !n.attributes && !n.styles;
      }
      function Sg(t, e, n, o) {
        let i = false;
        for (const r of Array.from(t.getItems({ shallow: n }))) {
          if (o.schema.checkAttribute(r, e.key)) {
            o.writer.setAttribute(e.key, e.value, r);
            i = true;
          }
        }
        return i;
      }
      function Pg(t) {
        const e = t.model;
        t.model = (t, n) => {
          const o = typeof e == "string" ? e : e(t, n);
          return n.writer.createElement("$marker", { "data-name": o });
        };
      }
      function Dg(t, e) {
        const n = {};
        n.view = t.view + "-" + e;
        n.model = (e, n) => {
          const o = e.getAttribute("name");
          const i = t.model(o, n);
          return n.writer.createElement("$marker", { "data-name": i });
        };
        return n;
      }
      class Tg {
        constructor(t, e) {
          this.model = t;
          this.view = new jh(e);
          this.mapper = new ef();
          this.downcastDispatcher = new rf({
            mapper: this.mapper,
            schema: t.schema,
          });
          const n = this.model.document;
          const o = n.selection;
          const i = this.model.markers;
          this.listenTo(
            this.model,
            "_beforeChanges",
            () => {
              this.view._disableRendering(true);
            },
            { priority: "highest" }
          );
          this.listenTo(
            this.model,
            "_afterChanges",
            () => {
              this.view._disableRendering(false);
            },
            { priority: "lowest" }
          );
          this.listenTo(
            n,
            "change",
            () => {
              this.view.change((t) => {
                this.downcastDispatcher.convertChanges(n.differ, i, t);
                this.downcastDispatcher.convertSelection(o, i, t);
              });
            },
            { priority: "low" }
          );
          this.listenTo(
            this.view.document,
            "selectionChange",
            fg(this.model, this.mapper)
          );
          this.downcastDispatcher.on("insert:$text", Bf(), {
            priority: "lowest",
          });
          this.downcastDispatcher.on("remove", If(), { priority: "low" });
          this.downcastDispatcher.on("selection", Nf(), { priority: "low" });
          this.downcastDispatcher.on("selection", Rf(), { priority: "low" });
          this.downcastDispatcher.on("selection", Ff(), { priority: "low" });
          this.view.document.roots
            .bindTo(this.model.document.roots)
            .using((t) => {
              if (t.rootName == "$graveyard") {
                return null;
              }
              const e = new ll(this.view.document, t.name);
              e.rootName = t.rootName;
              this.mapper.bindElements(t, e);
              return e;
            });
        }
        destroy() {
          this.view.destroy();
          this.stopListening();
        }
      }
      Cs(Tg, Yc);
      class Bg {
        constructor() {
          this._commands = new Map();
        }
        add(t, e) {
          this._commands.set(t, e);
        }
        get(t) {
          return this._commands.get(t);
        }
        execute(t, ...e) {
          const n = this.get(t);
          if (!n) {
            throw new ss["a"]("commandcollection-command-not-found", this, {
              commandName: t,
            });
          }
          return n.execute(...e);
        }
        *names() {
          yield* this._commands.keys();
        }
        *commands() {
          yield* this._commands.values();
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]();
        }
        destroy() {
          for (const t of this.commands()) {
            t.destroy();
          }
        }
      }
      class Ig {
        constructor() {
          this._consumables = new Map();
        }
        add(t, e) {
          let n;
          if (t.is("$text") || t.is("documentFragment")) {
            this._consumables.set(t, true);
            return;
          }
          if (!this._consumables.has(t)) {
            n = new Og(t);
            this._consumables.set(t, n);
          } else {
            n = this._consumables.get(t);
          }
          n.add(e);
        }
        test(t, e) {
          const n = this._consumables.get(t);
          if (n === undefined) {
            return null;
          }
          if (t.is("$text") || t.is("documentFragment")) {
            return n;
          }
          return n.test(e);
        }
        consume(t, e) {
          if (this.test(t, e)) {
            if (t.is("$text") || t.is("documentFragment")) {
              this._consumables.set(t, false);
            } else {
              this._consumables.get(t).consume(e);
            }
            return true;
          }
          return false;
        }
        revert(t, e) {
          const n = this._consumables.get(t);
          if (n !== undefined) {
            if (t.is("$text") || t.is("documentFragment")) {
              this._consumables.set(t, true);
            } else {
              n.revert(e);
            }
          }
        }
        static consumablesFromElement(t) {
          const e = {
            element: t,
            name: true,
            attributes: [],
            classes: [],
            styles: [],
          };
          const n = t.getAttributeKeys();
          for (const t of n) {
            if (t == "style" || t == "class") {
              continue;
            }
            e.attributes.push(t);
          }
          const o = t.getClassNames();
          for (const t of o) {
            e.classes.push(t);
          }
          const i = t.getStyleNames();
          for (const t of i) {
            e.styles.push(t);
          }
          return e;
        }
        static createFrom(t, e) {
          if (!e) {
            e = new Ig(t);
          }
          if (t.is("$text")) {
            e.add(t);
            return e;
          }
          if (t.is("element")) {
            e.add(t, Ig.consumablesFromElement(t));
          }
          if (t.is("documentFragment")) {
            e.add(t);
          }
          for (const n of t.getChildren()) {
            e = Ig.createFrom(n, e);
          }
          return e;
        }
      }
      class Og {
        constructor(t) {
          this.element = t;
          this._canConsumeName = null;
          this._consumables = {
            attributes: new Map(),
            styles: new Map(),
            classes: new Map(),
          };
        }
        add(t) {
          if (t.name) {
            this._canConsumeName = true;
          }
          for (const e in this._consumables) {
            if (e in t) {
              this._add(e, t[e]);
            }
          }
        }
        test(t) {
          if (t.name && !this._canConsumeName) {
            return this._canConsumeName;
          }
          for (const e in this._consumables) {
            if (e in t) {
              const n = this._test(e, t[e]);
              if (n !== true) {
                return n;
              }
            }
          }
          return true;
        }
        consume(t) {
          if (t.name) {
            this._canConsumeName = false;
          }
          for (const e in this._consumables) {
            if (e in t) {
              this._consume(e, t[e]);
            }
          }
        }
        revert(t) {
          if (t.name) {
            this._canConsumeName = true;
          }
          for (const e in this._consumables) {
            if (e in t) {
              this._revert(e, t[e]);
            }
          }
        }
        _add(t, e) {
          const n = Je(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              throw new ss["a"]("viewconsumable-invalid-attribute", this);
            }
            o.set(e, true);
            if (t === "styles") {
              for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                e
              )) {
                o.set(t, true);
              }
            }
          }
        }
        _test(t, e) {
          const n = Je(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles";
              const n = this._test(t, [...this._consumables[t].keys()]);
              if (n !== true) {
                return n;
              }
            } else {
              const t = o.get(e);
              if (t === undefined) {
                return null;
              }
              if (!t) {
                return false;
              }
            }
          }
          return true;
        }
        _consume(t, e) {
          const n = Je(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles";
              this._consume(t, [...this._consumables[t].keys()]);
            } else {
              o.set(e, false);
              if (t == "styles") {
                for (const t of this.element.document.stylesProcessor.getRelatedStyles(
                  e
                )) {
                  o.set(t, false);
                }
              }
            }
          }
        }
        _revert(t, e) {
          const n = Je(e) ? e : [e];
          const o = this._consumables[t];
          for (const e of n) {
            if (t === "attributes" && (e === "class" || e === "style")) {
              const t = e == "class" ? "classes" : "styles";
              this._revert(t, [...this._consumables[t].keys()]);
            } else {
              const t = o.get(e);
              if (t === false) {
                o.set(e, true);
              }
            }
          }
        }
      }
      class Rg {
        constructor() {
          this._sourceDefinitions = {};
          this._attributeProperties = {};
          this.decorate("checkChild");
          this.decorate("checkAttribute");
          this.on(
            "checkAttribute",
            (t, e) => {
              e[0] = new Fg(e[0]);
            },
            { priority: "highest" }
          );
          this.on(
            "checkChild",
            (t, e) => {
              e[0] = new Fg(e[0]);
              e[1] = this.getDefinition(e[1]);
            },
            { priority: "highest" }
          );
        }
        register(t, e) {
          if (this._sourceDefinitions[t]) {
            throw new ss["a"]("schema-cannot-register-item-twice", this, {
              itemName: t,
            });
          }
          this._sourceDefinitions[t] = [Object.assign({}, e)];
          this._clearCache();
        }
        extend(t, e) {
          if (!this._sourceDefinitions[t]) {
            throw new ss["a"]("schema-cannot-extend-missing-item", this, {
              itemName: t,
            });
          }
          this._sourceDefinitions[t].push(Object.assign({}, e));
          this._clearCache();
        }
        getDefinitions() {
          if (!this._compiledDefinitions) {
            this._compile();
          }
          return this._compiledDefinitions;
        }
        getDefinition(t) {
          let e;
          if (typeof t == "string") {
            e = t;
          } else if (t.is && (t.is("$text") || t.is("$textProxy"))) {
            e = "$text";
          } else {
            e = t.name;
          }
          return this.getDefinitions()[e];
        }
        isRegistered(t) {
          return !!this.getDefinition(t);
        }
        isBlock(t) {
          const e = this.getDefinition(t);
          return !!(e && e.isBlock);
        }
        isLimit(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isLimit || e.isObject);
        }
        isObject(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isObject || (e.isLimit && e.isSelectable && e.isContent));
        }
        isInline(t) {
          const e = this.getDefinition(t);
          return !!(e && e.isInline);
        }
        isSelectable(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isSelectable || e.isObject);
        }
        isContent(t) {
          const e = this.getDefinition(t);
          if (!e) {
            return false;
          }
          return !!(e.isContent || e.isObject);
        }
        checkChild(t, e) {
          if (!e) {
            return false;
          }
          return this._checkContextMatch(e, t);
        }
        checkAttribute(t, e) {
          const n = this.getDefinition(t.last);
          if (!n) {
            return false;
          }
          return n.allowAttributes.includes(e);
        }
        checkMerge(t, e = null) {
          if (t instanceof Yh) {
            const e = t.nodeBefore;
            const n = t.nodeAfter;
            if (!(e instanceof Gh)) {
              throw new ss["a"]("schema-check-merge-no-element-before", this);
            }
            if (!(n instanceof Gh)) {
              throw new ss["a"]("schema-check-merge-no-element-after", this);
            }
            return this.checkMerge(e, n);
          }
          for (const n of e.getChildren()) {
            if (!this.checkChild(t, n)) {
              return false;
            }
          }
          return true;
        }
        addChildCheck(t) {
          this.on(
            "checkChild",
            (e, [n, o]) => {
              if (!o) {
                return;
              }
              const i = t(n, o);
              if (typeof i == "boolean") {
                e.stop();
                e.return = i;
              }
            },
            { priority: "high" }
          );
        }
        addAttributeCheck(t) {
          this.on(
            "checkAttribute",
            (e, [n, o]) => {
              const i = t(n, o);
              if (typeof i == "boolean") {
                e.stop();
                e.return = i;
              }
            },
            { priority: "high" }
          );
        }
        setAttributeProperties(t, e) {
          this._attributeProperties[t] = Object.assign(
            this.getAttributeProperties(t),
            e
          );
        }
        getAttributeProperties(t) {
          return this._attributeProperties[t] || {};
        }
        getLimitElement(t) {
          let e;
          if (t instanceof Yh) {
            e = t.parent;
          } else {
            const n = t instanceof tf ? [t] : Array.from(t.getRanges());
            e = n.reduce((t, e) => {
              const n = e.getCommonAncestor();
              if (!t) {
                return n;
              }
              return t.getCommonAncestor(n, { includeSelf: true });
            }, null);
          }
          while (!this.isLimit(e)) {
            if (e.parent) {
              e = e.parent;
            } else {
              break;
            }
          }
          return e;
        }
        checkAttributeInSelection(t, e) {
          if (t.isCollapsed) {
            const n = t.getFirstPosition();
            const o = [...n.getAncestors(), new qh("", t.getAttributes())];
            return this.checkAttribute(o, e);
          } else {
            const n = t.getRanges();
            for (const t of n) {
              for (const n of t) {
                if (this.checkAttribute(n.item, e)) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        *getValidRanges(t, e) {
          t = Yg(t);
          for (const n of t) {
            yield* this._getValidRangesForRange(n, e);
          }
        }
        getNearestSelectionRange(t, e = "both") {
          if (this.checkChild(t, "$text")) {
            return new tf(t);
          }
          let n, o;
          const i =
            t
              .getAncestors()
              .reverse()
              .find((t) => this.isLimit(t)) || t.root;
          if (e == "both" || e == "backward") {
            n = new Hh({
              boundaries: tf._createIn(i),
              startPosition: t,
              direction: "backward",
            });
          }
          if (e == "both" || e == "forward") {
            o = new Hh({ boundaries: tf._createIn(i), startPosition: t });
          }
          for (const t of Jg(n, o)) {
            const e = t.walker == n ? "elementEnd" : "elementStart";
            const o = t.value;
            if (o.type == e && this.isObject(o.item)) {
              return tf._createOn(o.item);
            }
            if (this.checkChild(o.nextPosition, "$text")) {
              return new tf(o.nextPosition);
            }
          }
          return null;
        }
        findAllowedParent(t, e) {
          let n = t.parent;
          while (n) {
            if (this.checkChild(n, e)) {
              return n;
            }
            if (this.isLimit(n)) {
              return null;
            }
            n = n.parent;
          }
          return null;
        }
        removeDisallowedAttributes(t, e) {
          for (const n of t) {
            if (n.is("$text")) {
              Qg(this, n, e);
            } else {
              const t = tf._createIn(n);
              const o = t.getPositions();
              for (const t of o) {
                const n = t.nodeBefore || t.parent;
                Qg(this, n, e);
              }
            }
          }
        }
        createContext(t) {
          return new Fg(t);
        }
        _clearCache() {
          this._compiledDefinitions = null;
        }
        _compile() {
          const t = {};
          const e = this._sourceDefinitions;
          const n = Object.keys(e);
          for (const o of n) {
            t[o] = Ng(e[o], o);
          }
          for (const e of n) {
            Mg(t, e);
          }
          for (const e of n) {
            Vg(t, e);
          }
          for (const e of n) {
            Lg(t, e);
            zg(t, e);
          }
          for (const e of n) {
            jg(t, e);
            Kg(t, e);
          }
          this._compiledDefinitions = t;
        }
        _checkContextMatch(t, e, n = e.length - 1) {
          const o = e.getItem(n);
          if (t.allowIn.includes(o.name)) {
            if (n == 0) {
              return true;
            } else {
              const t = this.getDefinition(o);
              return this._checkContextMatch(t, e, n - 1);
            }
          } else {
            return false;
          }
        }
        *_getValidRangesForRange(t, e) {
          let n = t.start;
          let o = t.start;
          for (const i of t.getItems({ shallow: true })) {
            if (i.is("element")) {
              yield* this._getValidRangesForRange(tf._createIn(i), e);
            }
            if (!this.checkAttribute(i, e)) {
              if (!n.isEqual(o)) {
                yield new tf(n, o);
              }
              n = Yh._createAfter(i);
            }
            o = Yh._createAfter(i);
          }
          if (!n.isEqual(o)) {
            yield new tf(n, o);
          }
        }
      }
      Cs(Rg, Yc);
      class Fg {
        constructor(t) {
          if (t instanceof Fg) {
            return t;
          }
          if (typeof t == "string") {
            t = [t];
          } else if (!Array.isArray(t)) {
            t = t.getAncestors({ includeSelf: true });
          }
          if (t[0] && typeof t[0] != "string" && t[0].is("documentFragment")) {
            t.shift();
          }
          this._items = t.map(Hg);
        }
        get length() {
          return this._items.length;
        }
        get last() {
          return this._items[this._items.length - 1];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
        push(t) {
          const e = new Fg([t]);
          e._items = [...this._items, ...e._items];
          return e;
        }
        getItem(t) {
          return this._items[t];
        }
        *getNames() {
          yield* this._items.map((t) => t.name);
        }
        endsWith(t) {
          return Array.from(this.getNames()).join(" ").endsWith(t);
        }
        startsWith(t) {
          return Array.from(this.getNames()).join(" ").startsWith(t);
        }
      }
      function Ng(t, e) {
        const n = {
          name: e,
          allowIn: [],
          allowContentOf: [],
          allowWhere: [],
          allowAttributes: [],
          allowAttributesOf: [],
          inheritTypesFrom: [],
        };
        qg(t, n);
        $g(t, n, "allowIn");
        $g(t, n, "allowContentOf");
        $g(t, n, "allowWhere");
        $g(t, n, "allowAttributes");
        $g(t, n, "allowAttributesOf");
        $g(t, n, "inheritTypesFrom");
        Wg(t, n);
        return n;
      }
      function Mg(t, e) {
        for (const n of t[e].allowContentOf) {
          if (t[n]) {
            const o = Gg(t, n);
            o.forEach((t) => {
              t.allowIn.push(e);
            });
          }
        }
        delete t[e].allowContentOf;
      }
      function Vg(t, e) {
        for (const n of t[e].allowWhere) {
          const o = t[n];
          if (o) {
            const n = o.allowIn;
            t[e].allowIn.push(...n);
          }
        }
        delete t[e].allowWhere;
      }
      function Lg(t, e) {
        for (const n of t[e].allowAttributesOf) {
          const o = t[n];
          if (o) {
            const n = o.allowAttributes;
            t[e].allowAttributes.push(...n);
          }
        }
        delete t[e].allowAttributesOf;
      }
      function zg(t, e) {
        const n = t[e];
        for (const e of n.inheritTypesFrom) {
          const o = t[e];
          if (o) {
            const t = Object.keys(o).filter((t) => t.startsWith("is"));
            for (const e of t) {
              if (!(e in n)) {
                n[e] = o[e];
              }
            }
          }
        }
        delete n.inheritTypesFrom;
      }
      function jg(t, e) {
        const n = t[e];
        const o = n.allowIn.filter((e) => t[e]);
        n.allowIn = Array.from(new Set(o));
      }
      function Kg(t, e) {
        const n = t[e];
        n.allowAttributes = Array.from(new Set(n.allowAttributes));
      }
      function qg(t, e) {
        for (const n of t) {
          const t = Object.keys(n).filter((t) => t.startsWith("is"));
          for (const o of t) {
            e[o] = n[o];
          }
        }
      }
      function $g(t, e, n) {
        for (const o of t) {
          if (typeof o[n] == "string") {
            e[n].push(o[n]);
          } else if (Array.isArray(o[n])) {
            e[n].push(...o[n]);
          }
        }
      }
      function Wg(t, e) {
        for (const n of t) {
          const t = n.inheritAllFrom;
          if (t) {
            e.allowContentOf.push(t);
            e.allowWhere.push(t);
            e.allowAttributesOf.push(t);
            e.inheritTypesFrom.push(t);
          }
        }
      }
      function Gg(t, e) {
        const n = t[e];
        return Ug(t).filter((t) => t.allowIn.includes(n.name));
      }
      function Ug(t) {
        return Object.keys(t).map((e) => t[e]);
      }
      function Hg(t) {
        if (typeof t == "string") {
          return { name: t, *getAttributeKeys() {}, getAttribute() {} };
        } else {
          return {
            name: t.is("element") ? t.name : "$text",
            *getAttributeKeys() {
              yield* t.getAttributeKeys();
            },
            getAttribute(e) {
              return t.getAttribute(e);
            },
          };
        }
      }
      function* Jg(t, e) {
        let n = false;
        while (!n) {
          n = true;
          if (t) {
            const e = t.next();
            if (!e.done) {
              n = false;
              yield { walker: t, value: e.value };
            }
          }
          if (e) {
            const t = e.next();
            if (!t.done) {
              n = false;
              yield { walker: e, value: t.value };
            }
          }
        }
      }
      function* Yg(t) {
        for (const e of t) {
          yield* e.getMinimalFlatRanges();
        }
      }
      function Qg(t, e, n) {
        for (const o of e.getAttributeKeys()) {
          if (!t.checkAttribute(e, o)) {
            n.removeAttribute(o, e);
          }
        }
      }
      class Xg {
        constructor(t = {}) {
          this._splitParts = new Map();
          this._cursorParents = new Map();
          this._modelCursor = null;
          this.conversionApi = Object.assign({}, t);
          this.conversionApi.convertItem = this._convertItem.bind(this);
          this.conversionApi.convertChildren = this._convertChildren.bind(this);
          this.conversionApi.safeInsert = this._safeInsert.bind(this);
          this.conversionApi.updateConversionResult = this._updateConversionResult.bind(
            this
          );
          this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(
            this
          );
          this.conversionApi.getSplitParts = this._getSplitParts.bind(this);
        }
        convert(t, e, n = ["$root"]) {
          this.fire("viewCleanup", t);
          this._modelCursor = tp(n, e);
          this.conversionApi.writer = e;
          this.conversionApi.consumable = Ig.createFrom(t);
          this.conversionApi.store = {};
          const { modelRange: o } = this._convertItem(t, this._modelCursor);
          const i = e.createDocumentFragment();
          if (o) {
            this._removeEmptyElements();
            for (const t of Array.from(
              this._modelCursor.parent.getChildren()
            )) {
              e.append(t, i);
            }
            i.markers = Zg(i, e);
          }
          this._modelCursor = null;
          this._splitParts.clear();
          this._cursorParents.clear();
          this.conversionApi.writer = null;
          this.conversionApi.store = null;
          return i;
        }
        _convertItem(t, e) {
          const n = Object.assign({
            viewItem: t,
            modelCursor: e,
            modelRange: null,
          });
          if (t.is("element")) {
            this.fire("element:" + t.name, n, this.conversionApi);
          } else if (t.is("$text")) {
            this.fire("text", n, this.conversionApi);
          } else {
            this.fire("documentFragment", n, this.conversionApi);
          }
          if (n.modelRange && !(n.modelRange instanceof tf)) {
            throw new ss["a"](
              "view-conversion-dispatcher-incorrect-result",
              this
            );
          }
          return { modelRange: n.modelRange, modelCursor: n.modelCursor };
        }
        _convertChildren(t, e) {
          let n = e.is("position") ? e : Yh._createAt(e, 0);
          const o = new tf(n);
          for (const e of Array.from(t.getChildren())) {
            const t = this._convertItem(e, n);
            if (t.modelRange instanceof tf) {
              o.end = t.modelRange.end;
              n = t.modelCursor;
            }
          }
          return { modelRange: o, modelCursor: n };
        }
        _safeInsert(t, e) {
          const n = this._splitToAllowedParent(t, e);
          if (!n) {
            return false;
          }
          this.conversionApi.writer.insert(t, n.position);
          return true;
        }
        _updateConversionResult(t, e) {
          const n = this._getSplitParts(t);
          const o = this.conversionApi.writer;
          if (!e.modelRange) {
            e.modelRange = o.createRange(
              o.createPositionBefore(t),
              o.createPositionAfter(n[n.length - 1])
            );
          }
          const i = this._cursorParents.get(t);
          if (i) {
            e.modelCursor = o.createPositionAt(i, 0);
          } else {
            e.modelCursor = e.modelRange.end;
          }
        }
        _splitToAllowedParent(t, e) {
          const { schema: n, writer: o } = this.conversionApi;
          let i = n.findAllowedParent(e, t);
          if (i) {
            if (i === e.parent) {
              return { position: e };
            }
            if (this._modelCursor.parent.getAncestors().includes(i)) {
              i = null;
            }
          }
          if (!i) {
            if (!cg(e, t, n)) {
              return null;
            }
            return { position: lg(e, o) };
          }
          const r = this.conversionApi.writer.split(e, i);
          const s = [];
          for (const t of r.range.getWalker()) {
            if (t.type == "elementEnd") {
              s.push(t.item);
            } else {
              const e = s.pop();
              const n = t.item;
              this._registerSplitPair(e, n);
            }
          }
          const a = r.range.end.parent;
          this._cursorParents.set(t, a);
          return { position: r.position, cursorParent: a };
        }
        _registerSplitPair(t, e) {
          if (!this._splitParts.has(t)) {
            this._splitParts.set(t, [t]);
          }
          const n = this._splitParts.get(t);
          this._splitParts.set(e, n);
          n.push(e);
        }
        _getSplitParts(t) {
          let e;
          if (!this._splitParts.has(t)) {
            e = [t];
          } else {
            e = this._splitParts.get(t);
          }
          return e;
        }
        _removeEmptyElements() {
          let t = false;
          for (const e of this._splitParts.keys()) {
            if (e.isEmpty) {
              this.conversionApi.writer.remove(e);
              this._splitParts.delete(e);
              t = true;
            }
          }
          if (t) {
            this._removeEmptyElements();
          }
        }
      }
      Cs(Xg, ds);
      function Zg(t, e) {
        const n = new Set();
        const o = new Map();
        const i = tf._createIn(t).getItems();
        for (const t of i) {
          if (t.name == "$marker") {
            n.add(t);
          }
        }
        for (const t of n) {
          const n = t.getAttribute("data-name");
          const i = e.createPositionBefore(t);
          if (!o.has(n)) {
            o.set(n, new tf(i.clone()));
          } else {
            o.get(n).end = i.clone();
          }
          e.remove(t);
        }
        return o;
      }
      function tp(t, e) {
        let n;
        for (const o of new Fg(t)) {
          const t = {};
          for (const e of o.getAttributeKeys()) {
            t[e] = o.getAttribute(e);
          }
          const i = e.createElement(o.name, t);
          if (n) {
            e.append(i, n);
          }
          n = Yh._createAt(i, 0);
        }
        return n;
      }
      class ep {
        constructor(t, e) {
          this.model = t;
          this.stylesProcessor = e;
          this.processor = undefined;
          this.mapper = new ef();
          this.downcastDispatcher = new rf({
            mapper: this.mapper,
            schema: t.schema,
          });
          this.downcastDispatcher.on("insert:$text", Bf(), {
            priority: "lowest",
          });
          this.upcastDispatcher = new Xg({ schema: t.schema });
          this.viewDocument = new kl(e);
          this._viewWriter = new Xl(this.viewDocument);
          this.upcastDispatcher.on("text", hg(), { priority: "lowest" });
          this.upcastDispatcher.on("element", ug(), { priority: "lowest" });
          this.upcastDispatcher.on("documentFragment", ug(), {
            priority: "lowest",
          });
          this.decorate("init");
          this.decorate("set");
          this.on(
            "init",
            () => {
              this.fire("ready");
            },
            { priority: "lowest" }
          );
          this.on(
            "ready",
            () => {
              this.model.enqueueChange("transparent", ag);
            },
            { priority: "lowest" }
          );
        }
        get(t = {}) {
          const { rootName: e = "main", trim: n = "empty" } = t;
          if (!this._checkIfRootsExists([e])) {
            throw new ss["a"]("datacontroller-get-non-existent-root", this);
          }
          const o = this.model.document.getRoot(e);
          if (
            n === "empty" &&
            !this.model.hasContent(o, { ignoreWhitespaces: true })
          ) {
            return "";
          }
          return this.stringify(o, t);
        }
        stringify(t, e) {
          const n = this.toView(t, e);
          return this.processor.toData(n);
        }
        toView(t, e) {
          const n = this.viewDocument;
          const o = this._viewWriter;
          this.mapper.clearBindings();
          const i = tf._createIn(t);
          const r = new Yl(n);
          this.mapper.bindElements(t, r);
          this.downcastDispatcher.conversionApi.options = e;
          this.downcastDispatcher.convertInsert(i, o);
          if (!t.is("documentFragment")) {
            const e = np(t);
            for (const [t, n] of e) {
              this.downcastDispatcher.convertMarkerAdd(t, n, o);
            }
          }
          delete this.downcastDispatcher.conversionApi.options;
          return r;
        }
        init(t) {
          if (this.model.document.version) {
            throw new ss["a"]("datacontroller-init-document-not-empty", this);
          }
          let e = {};
          if (typeof t === "string") {
            e.main = t;
          } else {
            e = t;
          }
          if (!this._checkIfRootsExists(Object.keys(e))) {
            throw new ss["a"]("datacontroller-init-non-existent-root", this);
          }
          this.model.enqueueChange("transparent", (t) => {
            for (const n of Object.keys(e)) {
              const o = this.model.document.getRoot(n);
              t.insert(this.parse(e[n], o), o, 0);
            }
          });
          return Promise.resolve();
        }
        set(t) {
          let e = {};
          if (typeof t === "string") {
            e.main = t;
          } else {
            e = t;
          }
          if (!this._checkIfRootsExists(Object.keys(e))) {
            throw new ss["a"]("datacontroller-set-non-existent-root", this);
          }
          this.model.enqueueChange("transparent", (t) => {
            t.setSelection(null);
            t.removeSelectionAttribute(
              this.model.document.selection.getAttributeKeys()
            );
            for (const n of Object.keys(e)) {
              const o = this.model.document.getRoot(n);
              t.remove(t.createRangeIn(o));
              t.insert(this.parse(e[n], o), o, 0);
            }
          });
        }
        parse(t, e = "$root") {
          const n = this.processor.toView(t);
          return this.toModel(n, e);
        }
        toModel(t, e = "$root") {
          return this.model.change((n) =>
            this.upcastDispatcher.convert(t, n, e)
          );
        }
        addStyleProcessorRules(t) {
          t(this.stylesProcessor);
        }
        destroy() {
          this.stopListening();
        }
        _checkIfRootsExists(t) {
          for (const e of t) {
            if (!this.model.document.getRootNames().includes(e)) {
              return false;
            }
          }
          return true;
        }
      }
      Cs(ep, Yc);
      function np(t) {
        const e = [];
        const n = t.root.document;
        if (!n) {
          return [];
        }
        const o = tf._createIn(t);
        for (const t of n.model.markers) {
          const n = o.getIntersection(t.getRange());
          if (n) {
            e.push([t.name, n]);
          }
        }
        return e;
      }
      class op {
        constructor(t, e) {
          this._helpers = new Map();
          this._downcast = Array.isArray(t) ? t : [t];
          this._createConversionHelpers({
            name: "downcast",
            dispatchers: this._downcast,
            isDowncast: true,
          });
          this._upcast = Array.isArray(e) ? e : [e];
          this._createConversionHelpers({
            name: "upcast",
            dispatchers: this._upcast,
            isDowncast: false,
          });
        }
        addAlias(t, e) {
          const n = this._downcast.includes(e);
          const o = this._upcast.includes(e);
          if (!o && !n) {
            throw new ss["a"](
              "conversion-add-alias-dispatcher-not-registered",
              this
            );
          }
          this._createConversionHelpers({
            name: t,
            dispatchers: [e],
            isDowncast: n,
          });
        }
        for(t) {
          if (!this._helpers.has(t)) {
            throw new ss["a"]("conversion-for-unknown-group", this);
          }
          return this._helpers.get(t);
        }
        elementToElement(t) {
          this.for("downcast").elementToElement(t);
          for (const { model: e, view: n } of ip(t)) {
            this.for("upcast").elementToElement({
              model: e,
              view: n,
              converterPriority: t.converterPriority,
            });
          }
        }
        attributeToElement(t) {
          this.for("downcast").attributeToElement(t);
          for (const { model: e, view: n } of ip(t)) {
            this.for("upcast").elementToAttribute({
              view: n,
              model: e,
              converterPriority: t.converterPriority,
            });
          }
        }
        attributeToAttribute(t) {
          this.for("downcast").attributeToAttribute(t);
          for (const { model: e, view: n } of ip(t)) {
            this.for("upcast").attributeToAttribute({ view: n, model: e });
          }
        }
        _createConversionHelpers({ name: t, dispatchers: e, isDowncast: n }) {
          if (this._helpers.has(t)) {
            throw new ss["a"]("conversion-group-exists", this);
          }
          const o = n ? new Tf(e) : new dg(e);
          this._helpers.set(t, o);
        }
      }
      function* ip(t) {
        if (t.model.values) {
          for (const e of t.model.values) {
            const n = { key: t.model.key, value: e };
            const o = t.view[e];
            const i = t.upcastAlso ? t.upcastAlso[e] : undefined;
            yield* rp(n, o, i);
          }
        } else {
          yield* rp(t.model, t.view, t.upcastAlso);
        }
      }
      function* rp(t, e, n) {
        yield { model: t, view: e };
        if (n) {
          n = Array.isArray(n) ? n : [n];
          for (const e of n) {
            yield { model: t, view: e };
          }
        }
      }
      class sp {
        constructor(t = "default") {
          this.operations = [];
          this.type = t;
        }
        get baseVersion() {
          for (const t of this.operations) {
            if (t.baseVersion !== null) {
              return t.baseVersion;
            }
          }
          return null;
        }
        addOperation(t) {
          t.batch = this;
          this.operations.push(t);
          return t;
        }
      }
      class ap {
        constructor(t) {
          this.baseVersion = t;
          this.isDocumentOperation = this.baseVersion !== null;
          this.batch = null;
        }
        _validate() {}
        toJSON() {
          const t = Object.assign({}, this);
          t.__className = this.constructor.className;
          delete t.batch;
          delete t.isDocumentOperation;
          return t;
        }
        static get className() {
          return "Operation";
        }
        static fromJSON(t) {
          return new this(t.baseVersion);
        }
      }
      class cp {
        constructor(t) {
          this.markers = new Map();
          this._children = new Wh();
          if (t) {
            this._insertChild(0, t);
          }
        }
        [Symbol.iterator]() {
          return this.getChildren();
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return this.childCount === 0;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        is(t) {
          return t === "documentFragment" || t === "model:documentFragment";
        }
        getChild(t) {
          return this._children.getNode(t);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t) {
          return this._children.getNodeIndex(t);
        }
        getChildStartOffset(t) {
          return this._children.getNodeStartOffset(t);
        }
        getPath() {
          return [];
        }
        getNodeByPath(t) {
          let e = this;
          for (const n of t) {
            e = e.getChild(e.offsetToIndex(n));
          }
          return e;
        }
        offsetToIndex(t) {
          return this._children.offsetToIndex(t);
        }
        toJSON() {
          const t = [];
          for (const e of this._children) {
            t.push(e.toJSON());
          }
          return t;
        }
        static fromJSON(t) {
          const e = [];
          for (const n of t) {
            if (n.name) {
              e.push(Gh.fromJSON(n));
            } else {
              e.push(qh.fromJSON(n));
            }
          }
          return new cp(e);
        }
        _appendChild(t) {
          this._insertChild(this.childCount, t);
        }
        _insertChild(t, e) {
          const n = lp(e);
          for (const t of n) {
            if (t.parent !== null) {
              t._remove();
            }
            t.parent = this;
          }
          this._children._insertNodes(t, n);
        }
        _removeChildren(t, e = 1) {
          const n = this._children._removeNodes(t, e);
          for (const t of n) {
            t.parent = null;
          }
          return n;
        }
      }
      function lp(t) {
        if (typeof t == "string") {
          return [new qh(t)];
        }
        if (!As(t)) {
          t = [t];
        }
        return Array.from(t).map((t) => {
          if (typeof t == "string") {
            return new qh(t);
          }
          if (t instanceof $h) {
            return new qh(t.data, t.getAttributes());
          }
          return t;
        });
      }
      function dp(t, e) {
        e = gp(e);
        const n = e.reduce((t, e) => t + e.offsetSize, 0);
        const o = t.parent;
        mp(t);
        const i = t.index;
        o._insertChild(i, e);
        pp(o, i + e.length);
        pp(o, i);
        return new tf(t, t.getShiftedBy(n));
      }
      function up(t) {
        if (!t.isFlat) {
          throw new ss["a"]("operation-utils-remove-range-not-flat", this);
        }
        const e = t.start.parent;
        mp(t.start);
        mp(t.end);
        const n = e._removeChildren(t.start.index, t.end.index - t.start.index);
        pp(e, t.start.index);
        return n;
      }
      function hp(t, e) {
        if (!t.isFlat) {
          throw new ss["a"]("operation-utils-move-range-not-flat", this);
        }
        const n = up(t);
        e = e._getTransformedByDeletion(t.start, t.end.offset - t.start.offset);
        return dp(e, n);
      }
      function fp(t, e, n) {
        mp(t.start);
        mp(t.end);
        for (const o of t.getItems({ shallow: true })) {
          const t = o.is("$textProxy") ? o.textNode : o;
          if (n !== null) {
            t._setAttribute(e, n);
          } else {
            t._removeAttribute(e);
          }
          pp(t.parent, t.index);
        }
        pp(t.end.parent, t.end.index);
      }
      function gp(t) {
        const e = [];
        if (!(t instanceof Array)) {
          t = [t];
        }
        for (let n = 0; n < t.length; n++) {
          if (typeof t[n] == "string") {
            e.push(new qh(t[n]));
          } else if (t[n] instanceof $h) {
            e.push(new qh(t[n].data, t[n].getAttributes()));
          } else if (t[n] instanceof cp || t[n] instanceof Wh) {
            for (const o of t[n]) {
              e.push(o);
            }
          } else if (t[n] instanceof Kh) {
            e.push(t[n]);
          }
        }
        for (let t = 1; t < e.length; t++) {
          const n = e[t];
          const o = e[t - 1];
          if (n instanceof qh && o instanceof qh && kp(n, o)) {
            e.splice(t - 1, 2, new qh(o.data + n.data, o.getAttributes()));
            t--;
          }
        }
        return e;
      }
      function pp(t, e) {
        const n = t.getChild(e - 1);
        const o = t.getChild(e);
        if (n && o && n.is("$text") && o.is("$text") && kp(n, o)) {
          const i = new qh(n.data + o.data, n.getAttributes());
          t._removeChildren(e - 1, 2);
          t._insertChild(e - 1, i);
        }
      }
      function mp(t) {
        const e = t.textNode;
        const n = t.parent;
        if (e) {
          const o = t.offset - e.startOffset;
          const i = e.index;
          n._removeChildren(i, 1);
          const r = new qh(e.data.substr(0, o), e.getAttributes());
          const s = new qh(e.data.substr(o), e.getAttributes());
          n._insertChild(i, [r, s]);
        }
      }
      function kp(t, e) {
        const n = t.getAttributes();
        const o = e.getAttributes();
        for (const t of n) {
          if (t[1] !== e.getAttribute(t[0])) {
            return false;
          }
          o.next();
        }
        return o.next().done;
      }
      function bp(t, e) {
        return Yu(t, e);
      }
      var wp = bp;
      class _p extends ap {
        constructor(t, e, n, o, i) {
          super(i);
          this.range = t.clone();
          this.key = e;
          this.oldValue = n === undefined ? null : n;
          this.newValue = o === undefined ? null : o;
        }
        get type() {
          if (this.oldValue === null) {
            return "addAttribute";
          } else if (this.newValue === null) {
            return "removeAttribute";
          } else {
            return "changeAttribute";
          }
        }
        clone() {
          return new _p(
            this.range,
            this.key,
            this.oldValue,
            this.newValue,
            this.baseVersion
          );
        }
        getReversed() {
          return new _p(
            this.range,
            this.key,
            this.newValue,
            this.oldValue,
            this.baseVersion + 1
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.range = this.range.toJSON();
          return t;
        }
        _validate() {
          if (!this.range.isFlat) {
            throw new ss["a"]("attribute-operation-range-not-flat", this);
          }
          for (const t of this.range.getItems({ shallow: true })) {
            if (
              this.oldValue !== null &&
              !wp(t.getAttribute(this.key), this.oldValue)
            ) {
              throw new ss["a"]("attribute-operation-wrong-old-value", this, {
                item: t,
                key: this.key,
                value: this.oldValue,
              });
            }
            if (
              this.oldValue === null &&
              this.newValue !== null &&
              t.hasAttribute(this.key)
            ) {
              throw new ss["a"]("attribute-operation-attribute-exists", this, {
                node: t,
                key: this.key,
              });
            }
          }
        }
        _execute() {
          if (!wp(this.oldValue, this.newValue)) {
            fp(this.range, this.key, this.newValue);
          }
        }
        static get className() {
          return "AttributeOperation";
        }
        static fromJSON(t, e) {
          return new _p(
            tf.fromJSON(t.range, e),
            t.key,
            t.oldValue,
            t.newValue,
            t.baseVersion
          );
        }
      }
      class Ap extends ap {
        constructor(t, e) {
          super(null);
          this.sourcePosition = t.clone();
          this.howMany = e;
        }
        get type() {
          return "detach";
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = this.sourcePosition.toJSON();
          return t;
        }
        _validate() {
          if (this.sourcePosition.root.document) {
            throw new ss["a"]("detach-operation-on-document-node", this);
          }
        }
        _execute() {
          up(tf._createFromPositionAndShift(this.sourcePosition, this.howMany));
        }
        static get className() {
          return "DetachOperation";
        }
      }
      class Cp extends ap {
        constructor(t, e, n, o) {
          super(o);
          this.sourcePosition = t.clone();
          this.sourcePosition.stickiness = "toNext";
          this.howMany = e;
          this.targetPosition = n.clone();
          this.targetPosition.stickiness = "toNone";
        }
        get type() {
          if (this.targetPosition.root.rootName == "$graveyard") {
            return "remove";
          } else if (this.sourcePosition.root.rootName == "$graveyard") {
            return "reinsert";
          }
          return "move";
        }
        clone() {
          return new this.constructor(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.baseVersion
          );
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(
            this.sourcePosition,
            this.howMany
          );
        }
        getReversed() {
          const t = this.sourcePosition._getTransformedByInsertion(
            this.targetPosition,
            this.howMany
          );
          return new this.constructor(
            this.getMovedRangeStart(),
            this.howMany,
            t,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.sourcePosition.parent;
          const e = this.targetPosition.parent;
          const n = this.sourcePosition.offset;
          const o = this.targetPosition.offset;
          if (n + this.howMany > t.maxOffset) {
            throw new ss["a"]("move-operation-nodes-do-not-exist", this);
          } else if (t === e && n < o && o < n + this.howMany) {
            throw new ss["a"]("move-operation-range-into-itself", this);
          } else if (this.sourcePosition.root == this.targetPosition.root) {
            if (
              Fs(
                this.sourcePosition.getParentPath(),
                this.targetPosition.getParentPath()
              ) == "prefix"
            ) {
              const t = this.sourcePosition.path.length - 1;
              if (
                this.targetPosition.path[t] >= n &&
                this.targetPosition.path[t] < n + this.howMany
              ) {
                throw new ss["a"]("move-operation-node-into-itself", this);
              }
            }
          }
        }
        _execute() {
          hp(
            tf._createFromPositionAndShift(this.sourcePosition, this.howMany),
            this.targetPosition
          );
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = this.sourcePosition.toJSON();
          t.targetPosition = this.targetPosition.toJSON();
          return t;
        }
        static get className() {
          return "MoveOperation";
        }
        static fromJSON(t, e) {
          const n = Yh.fromJSON(t.sourcePosition, e);
          const o = Yh.fromJSON(t.targetPosition, e);
          return new this(n, t.howMany, o, t.baseVersion);
        }
      }
      class vp extends ap {
        constructor(t, e, n) {
          super(n);
          this.position = t.clone();
          this.position.stickiness = "toNone";
          this.nodes = new Wh(gp(e));
          this.shouldReceiveAttributes = false;
        }
        get type() {
          return "insert";
        }
        get howMany() {
          return this.nodes.maxOffset;
        }
        clone() {
          const t = new Wh([...this.nodes].map((t) => t._clone(true)));
          const e = new vp(this.position, t, this.baseVersion);
          e.shouldReceiveAttributes = this.shouldReceiveAttributes;
          return e;
        }
        getReversed() {
          const t = this.position.root.document.graveyard;
          const e = new Yh(t, [0]);
          return new Cp(
            this.position,
            this.nodes.maxOffset,
            e,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.position.parent;
          if (!t || t.maxOffset < this.position.offset) {
            throw new ss["a"]("insert-operation-position-invalid", this);
          }
        }
        _execute() {
          const t = this.nodes;
          this.nodes = new Wh([...t].map((t) => t._clone(true)));
          dp(this.position, t);
        }
        toJSON() {
          const t = super.toJSON();
          t.position = this.position.toJSON();
          t.nodes = this.nodes.toJSON();
          return t;
        }
        static get className() {
          return "InsertOperation";
        }
        static fromJSON(t, e) {
          const n = [];
          for (const e of t.nodes) {
            if (e.name) {
              n.push(Gh.fromJSON(e));
            } else {
              n.push(qh.fromJSON(e));
            }
          }
          const o = new vp(Yh.fromJSON(t.position, e), n, t.baseVersion);
          o.shouldReceiveAttributes = t.shouldReceiveAttributes;
          return o;
        }
      }
      class yp extends ap {
        constructor(t, e, n, o, i, r) {
          super(r);
          this.name = t;
          this.oldRange = e ? e.clone() : null;
          this.newRange = n ? n.clone() : null;
          this.affectsData = i;
          this._markers = o;
        }
        get type() {
          return "marker";
        }
        clone() {
          return new yp(
            this.name,
            this.oldRange,
            this.newRange,
            this._markers,
            this.affectsData,
            this.baseVersion
          );
        }
        getReversed() {
          return new yp(
            this.name,
            this.newRange,
            this.oldRange,
            this._markers,
            this.affectsData,
            this.baseVersion + 1
          );
        }
        _execute() {
          const t = this.newRange ? "_set" : "_remove";
          this._markers[t](this.name, this.newRange, true, this.affectsData);
        }
        toJSON() {
          const t = super.toJSON();
          if (this.oldRange) {
            t.oldRange = this.oldRange.toJSON();
          }
          if (this.newRange) {
            t.newRange = this.newRange.toJSON();
          }
          delete t._markers;
          return t;
        }
        static get className() {
          return "MarkerOperation";
        }
        static fromJSON(t, e) {
          return new yp(
            t.name,
            t.oldRange ? tf.fromJSON(t.oldRange, e) : null,
            t.newRange ? tf.fromJSON(t.newRange, e) : null,
            e.model.markers,
            t.affectsData,
            t.baseVersion
          );
        }
      }
      class xp extends ap {
        constructor(t, e, n, o) {
          super(o);
          this.position = t;
          this.position.stickiness = "toNext";
          this.oldName = e;
          this.newName = n;
        }
        get type() {
          return "rename";
        }
        clone() {
          return new xp(
            this.position.clone(),
            this.oldName,
            this.newName,
            this.baseVersion
          );
        }
        getReversed() {
          return new xp(
            this.position.clone(),
            this.newName,
            this.oldName,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.position.nodeAfter;
          if (!(t instanceof Gh)) {
            throw new ss["a"]("rename-operation-wrong-position", this);
          } else if (t.name !== this.oldName) {
            throw new ss["a"]("rename-operation-wrong-name", this);
          }
        }
        _execute() {
          const t = this.position.nodeAfter;
          t.name = this.newName;
        }
        toJSON() {
          const t = super.toJSON();
          t.position = this.position.toJSON();
          return t;
        }
        static get className() {
          return "RenameOperation";
        }
        static fromJSON(t, e) {
          return new xp(
            Yh.fromJSON(t.position, e),
            t.oldName,
            t.newName,
            t.baseVersion
          );
        }
      }
      class Ep extends ap {
        constructor(t, e, n, o, i) {
          super(i);
          this.root = t;
          this.key = e;
          this.oldValue = n;
          this.newValue = o;
        }
        get type() {
          if (this.oldValue === null) {
            return "addRootAttribute";
          } else if (this.newValue === null) {
            return "removeRootAttribute";
          } else {
            return "changeRootAttribute";
          }
        }
        clone() {
          return new Ep(
            this.root,
            this.key,
            this.oldValue,
            this.newValue,
            this.baseVersion
          );
        }
        getReversed() {
          return new Ep(
            this.root,
            this.key,
            this.newValue,
            this.oldValue,
            this.baseVersion + 1
          );
        }
        _validate() {
          if (this.root != this.root.root || this.root.is("documentFragment")) {
            throw new ss["a"]("rootattribute-operation-not-a-root", this, {
              root: this.root,
              key: this.key,
            });
          }
          if (
            this.oldValue !== null &&
            this.root.getAttribute(this.key) !== this.oldValue
          ) {
            throw new ss["a"]("rootattribute-operation-wrong-old-value", this, {
              root: this.root,
              key: this.key,
            });
          }
          if (
            this.oldValue === null &&
            this.newValue !== null &&
            this.root.hasAttribute(this.key)
          ) {
            throw new ss["a"](
              "rootattribute-operation-attribute-exists",
              this,
              { root: this.root, key: this.key }
            );
          }
        }
        _execute() {
          if (this.newValue !== null) {
            this.root._setAttribute(this.key, this.newValue);
          } else {
            this.root._removeAttribute(this.key);
          }
        }
        toJSON() {
          const t = super.toJSON();
          t.root = this.root.toJSON();
          return t;
        }
        static get className() {
          return "RootAttributeOperation";
        }
        static fromJSON(t, e) {
          if (!e.getRoot(t.root)) {
            throw new ss["a"](
              "rootattribute-operation-fromjson-no-root",
              this,
              { rootName: t.root }
            );
          }
          return new Ep(
            e.getRoot(t.root),
            t.key,
            t.oldValue,
            t.newValue,
            t.baseVersion
          );
        }
      }
      class Sp extends ap {
        constructor(t, e, n, o, i) {
          super(i);
          this.sourcePosition = t.clone();
          this.sourcePosition.stickiness = "toPrevious";
          this.howMany = e;
          this.targetPosition = n.clone();
          this.targetPosition.stickiness = "toNext";
          this.graveyardPosition = o.clone();
        }
        get type() {
          return "merge";
        }
        get deletionPosition() {
          return new Yh(
            this.sourcePosition.root,
            this.sourcePosition.path.slice(0, -1)
          );
        }
        get movedRange() {
          const t = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new tf(this.sourcePosition, t);
        }
        clone() {
          return new this.constructor(
            this.sourcePosition,
            this.howMany,
            this.targetPosition,
            this.graveyardPosition,
            this.baseVersion
          );
        }
        getReversed() {
          const t = this.targetPosition._getTransformedByMergeOperation(this);
          const e = this.sourcePosition.path.slice(0, -1);
          const n = new Yh(
            this.sourcePosition.root,
            e
          )._getTransformedByMergeOperation(this);
          const o = new Pp(
            t,
            this.howMany,
            this.graveyardPosition,
            this.baseVersion + 1
          );
          o.insertionPosition = n;
          return o;
        }
        _validate() {
          const t = this.sourcePosition.parent;
          const e = this.targetPosition.parent;
          if (!t.parent) {
            throw new ss["a"]("merge-operation-source-position-invalid", this);
          } else if (!e.parent) {
            throw new ss["a"]("merge-operation-target-position-invalid", this);
          } else if (this.howMany != t.maxOffset) {
            throw new ss["a"]("merge-operation-how-many-invalid", this);
          }
        }
        _execute() {
          const t = this.sourcePosition.parent;
          const e = tf._createIn(t);
          hp(e, this.targetPosition);
          hp(tf._createOn(t), this.graveyardPosition);
        }
        toJSON() {
          const t = super.toJSON();
          t.sourcePosition = t.sourcePosition.toJSON();
          t.targetPosition = t.targetPosition.toJSON();
          t.graveyardPosition = t.graveyardPosition.toJSON();
          return t;
        }
        static get className() {
          return "MergeOperation";
        }
        static fromJSON(t, e) {
          const n = Yh.fromJSON(t.sourcePosition, e);
          const o = Yh.fromJSON(t.targetPosition, e);
          const i = Yh.fromJSON(t.graveyardPosition, e);
          return new this(n, t.howMany, o, i, t.baseVersion);
        }
      }
      class Pp extends ap {
        constructor(t, e, n, o) {
          super(o);
          this.splitPosition = t.clone();
          this.splitPosition.stickiness = "toNext";
          this.howMany = e;
          this.insertionPosition = Pp.getInsertionPosition(t);
          this.insertionPosition.stickiness = "toNone";
          this.graveyardPosition = n ? n.clone() : null;
          if (this.graveyardPosition) {
            this.graveyardPosition.stickiness = "toNext";
          }
        }
        get type() {
          return "split";
        }
        get moveTargetPosition() {
          const t = this.insertionPosition.path.slice();
          t.push(0);
          return new Yh(this.insertionPosition.root, t);
        }
        get movedRange() {
          const t = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new tf(this.splitPosition, t);
        }
        clone() {
          const t = new this.constructor(
            this.splitPosition,
            this.howMany,
            this.graveyardPosition,
            this.baseVersion
          );
          t.insertionPosition = this.insertionPosition;
          return t;
        }
        getReversed() {
          const t = this.splitPosition.root.document.graveyard;
          const e = new Yh(t, [0]);
          return new Sp(
            this.moveTargetPosition,
            this.howMany,
            this.splitPosition,
            e,
            this.baseVersion + 1
          );
        }
        _validate() {
          const t = this.splitPosition.parent;
          const e = this.splitPosition.offset;
          if (!t || t.maxOffset < e) {
            throw new ss["a"]("split-operation-position-invalid", this);
          } else if (!t.parent) {
            throw new ss["a"]("split-operation-split-in-root", this);
          } else if (this.howMany != t.maxOffset - this.splitPosition.offset) {
            throw new ss["a"]("split-operation-how-many-invalid", this);
          } else if (
            this.graveyardPosition &&
            !this.graveyardPosition.nodeAfter
          ) {
            throw new ss["a"](
              "split-operation-graveyard-position-invalid",
              this
            );
          }
        }
        _execute() {
          const t = this.splitPosition.parent;
          if (this.graveyardPosition) {
            hp(
              tf._createFromPositionAndShift(this.graveyardPosition, 1),
              this.insertionPosition
            );
          } else {
            const e = t._clone();
            dp(this.insertionPosition, e);
          }
          const e = new tf(
            Yh._createAt(t, this.splitPosition.offset),
            Yh._createAt(t, t.maxOffset)
          );
          hp(e, this.moveTargetPosition);
        }
        toJSON() {
          const t = super.toJSON();
          t.splitPosition = this.splitPosition.toJSON();
          t.insertionPosition = this.insertionPosition.toJSON();
          if (this.graveyardPosition) {
            t.graveyardPosition = this.graveyardPosition.toJSON();
          }
          return t;
        }
        static get className() {
          return "SplitOperation";
        }
        static getInsertionPosition(t) {
          const e = t.path.slice(0, -1);
          e[e.length - 1]++;
          return new Yh(t.root, e);
        }
        static fromJSON(t, e) {
          const n = Yh.fromJSON(t.splitPosition, e);
          const o = Yh.fromJSON(t.insertionPosition, e);
          const i = t.graveyardPosition
            ? Yh.fromJSON(t.graveyardPosition, e)
            : null;
          const r = new this(n, t.howMany, i, t.baseVersion);
          r.insertionPosition = o;
          return r;
        }
      }
      class Dp extends Gh {
        constructor(t, e, n = "main") {
          super(e);
          this._document = t;
          this.rootName = n;
        }
        get document() {
          return this._document;
        }
        is(t, e) {
          if (!e) {
            return (
              t === "rootElement" ||
              t === "model:rootElement" ||
              t === "element" ||
              t === "model:element" ||
              t === "node" ||
              t === "model:node"
            );
          }
          return (
            e === this.name &&
            (t === "rootElement" ||
              t === "model:rootElement" ||
              t === "element" ||
              t === "model:element")
          );
        }
        toJSON() {
          return this.rootName;
        }
      }
      class Tp {
        constructor(t, e) {
          this.model = t;
          this.batch = e;
        }
        createText(t, e) {
          return new qh(t, e);
        }
        createElement(t, e) {
          return new Gh(t, e);
        }
        createDocumentFragment() {
          return new cp();
        }
        cloneElement(t, e = true) {
          return t._clone(e);
        }
        insert(t, e, n = 0) {
          this._assertWriterUsedCorrectly();
          if (t instanceof qh && t.data == "") {
            return;
          }
          const o = Yh._createAt(e, n);
          if (t.parent) {
            if (Fp(t.root, o.root)) {
              this.move(tf._createOn(t), o);
              return;
            } else {
              if (t.root.document) {
                throw new ss["a"]("model-writer-insert-forbidden-move", this);
              } else {
                this.remove(t);
              }
            }
          }
          const i = o.root.document ? o.root.document.version : null;
          const r = new vp(o, t, i);
          if (t instanceof qh) {
            r.shouldReceiveAttributes = true;
          }
          this.batch.addOperation(r);
          this.model.applyOperation(r);
          if (t instanceof cp) {
            for (const [e, n] of t.markers) {
              const t = Yh._createAt(n.root, 0);
              const i = new tf(
                n.start._getCombined(t, o),
                n.end._getCombined(t, o)
              );
              const r = { range: i, usingOperation: true, affectsData: true };
              if (this.model.markers.has(e)) {
                this.updateMarker(e, r);
              } else {
                this.addMarker(e, r);
              }
            }
          }
        }
        insertText(t, e, n, o) {
          if (e instanceof cp || e instanceof Gh || e instanceof Yh) {
            this.insert(this.createText(t), e, n);
          } else {
            this.insert(this.createText(t, e), n, o);
          }
        }
        insertElement(t, e, n, o) {
          if (e instanceof cp || e instanceof Gh || e instanceof Yh) {
            this.insert(this.createElement(t), e, n);
          } else {
            this.insert(this.createElement(t, e), n, o);
          }
        }
        append(t, e) {
          this.insert(t, e, "end");
        }
        appendText(t, e, n) {
          if (e instanceof cp || e instanceof Gh) {
            this.insert(this.createText(t), e, "end");
          } else {
            this.insert(this.createText(t, e), n, "end");
          }
        }
        appendElement(t, e, n) {
          if (e instanceof cp || e instanceof Gh) {
            this.insert(this.createElement(t), e, "end");
          } else {
            this.insert(this.createElement(t, e), n, "end");
          }
        }
        setAttribute(t, e, n) {
          this._assertWriterUsedCorrectly();
          if (n instanceof tf) {
            const o = n.getMinimalFlatRanges();
            for (const n of o) {
              Bp(this, t, e, n);
            }
          } else {
            Ip(this, t, e, n);
          }
        }
        setAttributes(t, e) {
          for (const [n, o] of qs(t)) {
            this.setAttribute(n, o, e);
          }
        }
        removeAttribute(t, e) {
          this._assertWriterUsedCorrectly();
          if (e instanceof tf) {
            const n = e.getMinimalFlatRanges();
            for (const e of n) {
              Bp(this, t, null, e);
            }
          } else {
            Ip(this, t, null, e);
          }
        }
        clearAttributes(t) {
          this._assertWriterUsedCorrectly();
          const e = (t) => {
            for (const e of t.getAttributeKeys()) {
              this.removeAttribute(e, t);
            }
          };
          if (!(t instanceof tf)) {
            e(t);
          } else {
            for (const n of t.getItems()) {
              e(n);
            }
          }
        }
        move(t, e, n) {
          this._assertWriterUsedCorrectly();
          if (!(t instanceof tf)) {
            throw new ss["a"]("writer-move-invalid-range", this);
          }
          if (!t.isFlat) {
            throw new ss["a"]("writer-move-range-not-flat", this);
          }
          const o = Yh._createAt(e, n);
          if (o.isEqual(t.start)) {
            return;
          }
          this._addOperationForAffectedMarkers("move", t);
          if (!Fp(t.root, o.root)) {
            throw new ss["a"]("writer-move-different-document", this);
          }
          const i = t.root.document ? t.root.document.version : null;
          const r = new Cp(t.start, t.end.offset - t.start.offset, o, i);
          this.batch.addOperation(r);
          this.model.applyOperation(r);
        }
        remove(t) {
          this._assertWriterUsedCorrectly();
          const e = t instanceof tf ? t : tf._createOn(t);
          const n = e.getMinimalFlatRanges().reverse();
          for (const t of n) {
            this._addOperationForAffectedMarkers("move", t);
            Rp(t.start, t.end.offset - t.start.offset, this.batch, this.model);
          }
        }
        merge(t) {
          this._assertWriterUsedCorrectly();
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          this._addOperationForAffectedMarkers("merge", t);
          if (!(e instanceof Gh)) {
            throw new ss["a"]("writer-merge-no-element-before", this);
          }
          if (!(n instanceof Gh)) {
            throw new ss["a"]("writer-merge-no-element-after", this);
          }
          if (!t.root.document) {
            this._mergeDetached(t);
          } else {
            this._merge(t);
          }
        }
        createPositionFromPath(t, e, n) {
          return this.model.createPositionFromPath(t, e, n);
        }
        createPositionAt(t, e) {
          return this.model.createPositionAt(t, e);
        }
        createPositionAfter(t) {
          return this.model.createPositionAfter(t);
        }
        createPositionBefore(t) {
          return this.model.createPositionBefore(t);
        }
        createRange(t, e) {
          return this.model.createRange(t, e);
        }
        createRangeIn(t) {
          return this.model.createRangeIn(t);
        }
        createRangeOn(t) {
          return this.model.createRangeOn(t);
        }
        createSelection(t, e, n) {
          return this.model.createSelection(t, e, n);
        }
        _mergeDetached(t) {
          const e = t.nodeBefore;
          const n = t.nodeAfter;
          this.move(tf._createIn(n), Yh._createAt(e, "end"));
          this.remove(n);
        }
        _merge(t) {
          const e = Yh._createAt(t.nodeBefore, "end");
          const n = Yh._createAt(t.nodeAfter, 0);
          const o = t.root.document.graveyard;
          const i = new Yh(o, [0]);
          const r = t.root.document.version;
          const s = new Sp(n, t.nodeAfter.maxOffset, e, i, r);
          this.batch.addOperation(s);
          this.model.applyOperation(s);
        }
        rename(t, e) {
          this._assertWriterUsedCorrectly();
          if (!(t instanceof Gh)) {
            throw new ss["a"]("writer-rename-not-element-instance", this);
          }
          const n = t.root.document ? t.root.document.version : null;
          const o = new xp(Yh._createBefore(t), t.name, e, n);
          this.batch.addOperation(o);
          this.model.applyOperation(o);
        }
        split(t, e) {
          this._assertWriterUsedCorrectly();
          let n = t.parent;
          if (!n.parent) {
            throw new ss["a"]("writer-split-element-no-parent", this);
          }
          if (!e) {
            e = n.parent;
          }
          if (!t.parent.getAncestors({ includeSelf: true }).includes(e)) {
            throw new ss["a"]("writer-split-invalid-limit-element", this);
          }
          let o, i;
          do {
            const e = n.root.document ? n.root.document.version : null;
            const r = n.maxOffset - t.offset;
            const s = new Pp(t, r, null, e);
            this.batch.addOperation(s);
            this.model.applyOperation(s);
            if (!o && !i) {
              o = n;
              i = t.parent.nextSibling;
            }
            t = this.createPositionAfter(t.parent);
            n = t.parent;
          } while (n !== e);
          return {
            position: t,
            range: new tf(Yh._createAt(o, "end"), Yh._createAt(i, 0)),
          };
        }
        wrap(t, e) {
          this._assertWriterUsedCorrectly();
          if (!t.isFlat) {
            throw new ss["a"]("writer-wrap-range-not-flat", this);
          }
          const n = e instanceof Gh ? e : new Gh(e);
          if (n.childCount > 0) {
            throw new ss["a"]("writer-wrap-element-not-empty", this);
          }
          if (n.parent !== null) {
            throw new ss["a"]("writer-wrap-element-attached", this);
          }
          this.insert(n, t.start);
          const o = new tf(t.start.getShiftedBy(1), t.end.getShiftedBy(1));
          this.move(o, Yh._createAt(n, 0));
        }
        unwrap(t) {
          this._assertWriterUsedCorrectly();
          if (t.parent === null) {
            throw new ss["a"]("writer-unwrap-element-no-parent", this);
          }
          this.move(tf._createIn(t), this.createPositionAfter(t));
          this.remove(t);
        }
        addMarker(t, e) {
          this._assertWriterUsedCorrectly();
          if (!e || typeof e.usingOperation != "boolean") {
            throw new ss["a"]("writer-addmarker-no-usingoperation", this);
          }
          const n = e.usingOperation;
          const o = e.range;
          const i = e.affectsData === undefined ? false : e.affectsData;
          if (this.model.markers.has(t)) {
            throw new ss["a"]("writer-addmarker-marker-exists", this);
          }
          if (!o) {
            throw new ss["a"]("writer-addmarker-no-range", this);
          }
          if (!n) {
            return this.model.markers._set(t, o, n, i);
          }
          Op(this, t, null, o, i);
          return this.model.markers.get(t);
        }
        updateMarker(t, e) {
          this._assertWriterUsedCorrectly();
          const n = typeof t == "string" ? t : t.name;
          const o = this.model.markers.get(n);
          if (!o) {
            throw new ss["a"]("writer-updatemarker-marker-not-exists", this);
          }
          if (!e) {
            this.model.markers._refresh(o);
            return;
          }
          const i = typeof e.usingOperation == "boolean";
          const r = typeof e.affectsData == "boolean";
          const s = r ? e.affectsData : o.affectsData;
          if (!i && !e.range && !r) {
            throw new ss["a"]("writer-updatemarker-wrong-options", this);
          }
          const a = o.getRange();
          const c = e.range ? e.range : a;
          if (i && e.usingOperation !== o.managedUsingOperations) {
            if (e.usingOperation) {
              Op(this, n, null, c, s);
            } else {
              Op(this, n, a, null, s);
              this.model.markers._set(n, c, undefined, s);
            }
            return;
          }
          if (o.managedUsingOperations) {
            Op(this, n, a, c, s);
          } else {
            this.model.markers._set(n, c, undefined, s);
          }
        }
        removeMarker(t) {
          this._assertWriterUsedCorrectly();
          const e = typeof t == "string" ? t : t.name;
          if (!this.model.markers.has(e)) {
            throw new ss["a"]("writer-removemarker-no-marker", this);
          }
          const n = this.model.markers.get(e);
          if (!n.managedUsingOperations) {
            this.model.markers._remove(e);
            return;
          }
          const o = n.getRange();
          Op(this, e, o, null, n.affectsData);
        }
        setSelection(t, e, n) {
          this._assertWriterUsedCorrectly();
          this.model.document.selection._setTo(t, e, n);
        }
        setSelectionFocus(t, e) {
          this._assertWriterUsedCorrectly();
          this.model.document.selection._setFocus(t, e);
        }
        setSelectionAttribute(t, e) {
          this._assertWriterUsedCorrectly();
          if (typeof t === "string") {
            this._setSelectionAttribute(t, e);
          } else {
            for (const [e, n] of qs(t)) {
              this._setSelectionAttribute(e, n);
            }
          }
        }
        removeSelectionAttribute(t) {
          this._assertWriterUsedCorrectly();
          if (typeof t === "string") {
            this._removeSelectionAttribute(t);
          } else {
            for (const e of t) {
              this._removeSelectionAttribute(e);
            }
          }
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity();
        }
        restoreSelectionGravity(t) {
          this.model.document.selection._restoreGravity(t);
        }
        _setSelectionAttribute(t, e) {
          const n = this.model.document.selection;
          if (n.isCollapsed && n.anchor.parent.isEmpty) {
            const o = Af._getStoreAttributeKey(t);
            this.setAttribute(o, e, n.anchor.parent);
          }
          n._setAttribute(t, e);
        }
        _removeSelectionAttribute(t) {
          const e = this.model.document.selection;
          if (e.isCollapsed && e.anchor.parent.isEmpty) {
            const n = Af._getStoreAttributeKey(t);
            this.removeAttribute(n, e.anchor.parent);
          }
          e._removeAttribute(t);
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this) {
            throw new ss["a"]("writer-incorrect-use", this);
          }
        }
        _addOperationForAffectedMarkers(t, e) {
          for (const n of this.model.markers) {
            if (!n.managedUsingOperations) {
              continue;
            }
            const o = n.getRange();
            let i = false;
            if (t === "move") {
              i =
                e.containsPosition(o.start) ||
                e.start.isEqual(o.start) ||
                e.containsPosition(o.end) ||
                e.end.isEqual(o.end);
            } else {
              const t = e.nodeBefore;
              const n = e.nodeAfter;
              const r = o.start.parent == t && o.start.isAtEnd;
              const s = o.end.parent == n && o.end.offset == 0;
              const a = o.end.nodeAfter == n;
              const c = o.start.nodeAfter == n;
              i = r || s || a || c;
            }
            if (i) {
              this.updateMarker(n.name, { range: o });
            }
          }
        }
      }
      function Bp(t, e, n, o) {
        const i = t.model;
        const r = i.document;
        let s = o.start;
        let a;
        let c;
        let l;
        for (const t of o.getWalker({ shallow: true })) {
          l = t.item.getAttribute(e);
          if (a && c != l) {
            if (c != n) {
              d();
            }
            s = a;
          }
          a = t.nextPosition;
          c = l;
        }
        if (a instanceof Yh && a != s && c != n) {
          d();
        }
        function d() {
          const o = new tf(s, a);
          const l = o.root.document ? r.version : null;
          const d = new _p(o, e, c, n, l);
          t.batch.addOperation(d);
          i.applyOperation(d);
        }
      }
      function Ip(t, e, n, o) {
        const i = t.model;
        const r = i.document;
        const s = o.getAttribute(e);
        let a, c;
        if (s != n) {
          const l = o.root === o;
          if (l) {
            const t = o.document ? r.version : null;
            c = new Ep(o, e, s, n, t);
          } else {
            a = new tf(Yh._createBefore(o), t.createPositionAfter(o));
            const i = a.root.document ? r.version : null;
            c = new _p(a, e, s, n, i);
          }
          t.batch.addOperation(c);
          i.applyOperation(c);
        }
      }
      function Op(t, e, n, o, i) {
        const r = t.model;
        const s = r.document;
        const a = new yp(e, n, o, r.markers, i, s.version);
        t.batch.addOperation(a);
        r.applyOperation(a);
      }
      function Rp(t, e, n, o) {
        let i;
        if (t.root.document) {
          const n = o.document;
          const r = new Yh(n.graveyard, [0]);
          i = new Cp(t, e, r, n.version);
        } else {
          i = new Ap(t, e);
        }
        n.addOperation(i);
        o.applyOperation(i);
      }
      function Fp(t, e) {
        if (t === e) {
          return true;
        }
        if (t instanceof Dp && e instanceof Dp) {
          return true;
        }
        return false;
      }
      class Np {
        constructor(t) {
          this._markerCollection = t;
          this._changesInElement = new Map();
          this._elementSnapshots = new Map();
          this._changedMarkers = new Map();
          this._changeCount = 0;
          this._cachedChanges = null;
          this._cachedChangesWithGraveyard = null;
        }
        get isEmpty() {
          return (
            this._changesInElement.size == 0 && this._changedMarkers.size == 0
          );
        }
        refreshItem(t) {
          if (this._isInInsertedElement(t.parent)) {
            return;
          }
          this._markRemove(t.parent, t.startOffset, t.offsetSize);
          this._markInsert(t.parent, t.startOffset, t.offsetSize);
          const e = tf._createOn(t);
          for (const t of this._markerCollection.getMarkersIntersectingRange(
            e
          )) {
            const e = t.getRange();
            this.bufferMarkerChange(t.name, e, e, t.affectsData);
          }
          this._cachedChanges = null;
        }
        bufferOperation(t) {
          switch (t.type) {
            case "insert": {
              if (this._isInInsertedElement(t.position.parent)) {
                return;
              }
              this._markInsert(
                t.position.parent,
                t.position.offset,
                t.nodes.maxOffset
              );
              break;
            }
            case "addAttribute":
            case "removeAttribute":
            case "changeAttribute": {
              for (const e of t.range.getItems({ shallow: true })) {
                if (this._isInInsertedElement(e.parent)) {
                  continue;
                }
                this._markAttribute(e);
              }
              break;
            }
            case "remove":
            case "move":
            case "reinsert": {
              if (
                t.sourcePosition.isEqual(t.targetPosition) ||
                t.sourcePosition
                  .getShiftedBy(t.howMany)
                  .isEqual(t.targetPosition)
              ) {
                return;
              }
              const e = this._isInInsertedElement(t.sourcePosition.parent);
              const n = this._isInInsertedElement(t.targetPosition.parent);
              if (!e) {
                this._markRemove(
                  t.sourcePosition.parent,
                  t.sourcePosition.offset,
                  t.howMany
                );
              }
              if (!n) {
                this._markInsert(
                  t.targetPosition.parent,
                  t.getMovedRangeStart().offset,
                  t.howMany
                );
              }
              break;
            }
            case "rename": {
              if (this._isInInsertedElement(t.position.parent)) {
                return;
              }
              this._markRemove(t.position.parent, t.position.offset, 1);
              this._markInsert(t.position.parent, t.position.offset, 1);
              const e = tf._createFromPositionAndShift(t.position, 1);
              for (const t of this._markerCollection.getMarkersIntersectingRange(
                e
              )) {
                const e = t.getRange();
                this.bufferMarkerChange(t.name, e, e, t.affectsData);
              }
              break;
            }
            case "split": {
              const e = t.splitPosition.parent;
              if (!this._isInInsertedElement(e)) {
                this._markRemove(e, t.splitPosition.offset, t.howMany);
              }
              if (!this._isInInsertedElement(t.insertionPosition.parent)) {
                this._markInsert(
                  t.insertionPosition.parent,
                  t.insertionPosition.offset,
                  1
                );
              }
              if (t.graveyardPosition) {
                this._markRemove(
                  t.graveyardPosition.parent,
                  t.graveyardPosition.offset,
                  1
                );
              }
              break;
            }
            case "merge": {
              const e = t.sourcePosition.parent;
              if (!this._isInInsertedElement(e.parent)) {
                this._markRemove(e.parent, e.startOffset, 1);
              }
              const n = t.graveyardPosition.parent;
              this._markInsert(n, t.graveyardPosition.offset, 1);
              const o = t.targetPosition.parent;
              if (!this._isInInsertedElement(o)) {
                this._markInsert(o, t.targetPosition.offset, e.maxOffset);
              }
              break;
            }
          }
          this._cachedChanges = null;
        }
        bufferMarkerChange(t, e, n, o) {
          const i = this._changedMarkers.get(t);
          if (!i) {
            this._changedMarkers.set(t, {
              oldRange: e,
              newRange: n,
              affectsData: o,
            });
          } else {
            i.newRange = n;
            i.affectsData = o;
            if (i.oldRange == null && i.newRange == null) {
              this._changedMarkers.delete(t);
            }
          }
        }
        getMarkersToRemove() {
          const t = [];
          for (const [e, n] of this._changedMarkers) {
            if (n.oldRange != null) {
              t.push({ name: e, range: n.oldRange });
            }
          }
          return t;
        }
        getMarkersToAdd() {
          const t = [];
          for (const [e, n] of this._changedMarkers) {
            if (n.newRange != null) {
              t.push({ name: e, range: n.newRange });
            }
          }
          return t;
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map((t) => ({
            name: t[0],
            data: { oldRange: t[1].oldRange, newRange: t[1].newRange },
          }));
        }
        hasDataChanges() {
          for (const [, t] of this._changedMarkers) {
            if (t.affectsData) {
              return true;
            }
          }
          return this._changesInElement.size > 0;
        }
        getChanges(t = { includeChangesInGraveyard: false }) {
          if (this._cachedChanges) {
            if (t.includeChangesInGraveyard) {
              return this._cachedChangesWithGraveyard.slice();
            } else {
              return this._cachedChanges.slice();
            }
          }
          const e = [];
          for (const t of this._changesInElement.keys()) {
            const n = this._changesInElement.get(t).sort((t, e) => {
              if (t.offset === e.offset) {
                if (t.type != e.type) {
                  return t.type == "remove" ? -1 : 1;
                }
                return 0;
              }
              return t.offset < e.offset ? -1 : 1;
            });
            const o = this._elementSnapshots.get(t);
            const i = Mp(t.getChildren());
            const r = Vp(o.length, n);
            let s = 0;
            let a = 0;
            for (const n of r) {
              if (n === "i") {
                e.push(this._getInsertDiff(t, s, i[s].name));
                s++;
              } else if (n === "r") {
                e.push(this._getRemoveDiff(t, s, o[a].name));
                a++;
              } else if (n === "a") {
                const n = i[s].attributes;
                const r = o[a].attributes;
                let c;
                if (i[s].name == "$text") {
                  c = new tf(Yh._createAt(t, s), Yh._createAt(t, s + 1));
                } else {
                  const e = t.offsetToIndex(s);
                  c = new tf(
                    Yh._createAt(t, s),
                    Yh._createAt(t.getChild(e), 0)
                  );
                }
                e.push(...this._getAttributesDiff(c, r, n));
                s++;
                a++;
              } else {
                s++;
                a++;
              }
            }
          }
          e.sort((t, e) => {
            if (t.position.root != e.position.root) {
              return t.position.root.rootName < e.position.root.rootName
                ? -1
                : 1;
            }
            if (t.position.isEqual(e.position)) {
              return t.changeCount - e.changeCount;
            }
            return t.position.isBefore(e.position) ? -1 : 1;
          });
          for (let t = 1; t < e.length; t++) {
            const n = e[t - 1];
            const o = e[t];
            const i =
              n.type == "remove" &&
              o.type == "remove" &&
              n.name == "$text" &&
              o.name == "$text" &&
              n.position.isEqual(o.position);
            const r =
              n.type == "insert" &&
              o.type == "insert" &&
              n.name == "$text" &&
              o.name == "$text" &&
              n.position.parent == o.position.parent &&
              n.position.offset + n.length == o.position.offset;
            const s =
              n.type == "attribute" &&
              o.type == "attribute" &&
              n.position.parent == o.position.parent &&
              n.range.isFlat &&
              o.range.isFlat &&
              n.position.offset + n.length == o.position.offset &&
              n.attributeKey == o.attributeKey &&
              n.attributeOldValue == o.attributeOldValue &&
              n.attributeNewValue == o.attributeNewValue;
            if (i || r || s) {
              e[t - 1].length++;
              if (s) {
                e[t - 1].range.end = e[t - 1].range.end.getShiftedBy(1);
              }
              e.splice(t, 1);
              t--;
            }
          }
          for (const t of e) {
            delete t.changeCount;
            if (t.type == "attribute") {
              delete t.position;
              delete t.length;
            }
          }
          this._changeCount = 0;
          this._cachedChangesWithGraveyard = e.slice();
          this._cachedChanges = e.slice().filter(Lp);
          if (t.includeChangesInGraveyard) {
            return this._cachedChangesWithGraveyard;
          } else {
            return this._cachedChanges;
          }
        }
        reset() {
          this._changesInElement.clear();
          this._elementSnapshots.clear();
          this._changedMarkers.clear();
          this._cachedChanges = null;
        }
        _markInsert(t, e, n) {
          const o = {
            type: "insert",
            offset: e,
            howMany: n,
            count: this._changeCount++,
          };
          this._markChange(t, o);
        }
        _markRemove(t, e, n) {
          const o = {
            type: "remove",
            offset: e,
            howMany: n,
            count: this._changeCount++,
          };
          this._markChange(t, o);
          this._removeAllNestedChanges(t, e, n);
        }
        _markAttribute(t) {
          const e = {
            type: "attribute",
            offset: t.startOffset,
            howMany: t.offsetSize,
            count: this._changeCount++,
          };
          this._markChange(t.parent, e);
        }
        _markChange(t, e) {
          this._makeSnapshot(t);
          const n = this._getChangesForElement(t);
          this._handleChange(e, n);
          n.push(e);
          for (let t = 0; t < n.length; t++) {
            if (n[t].howMany < 1) {
              n.splice(t, 1);
              t--;
            }
          }
        }
        _getChangesForElement(t) {
          let e;
          if (this._changesInElement.has(t)) {
            e = this._changesInElement.get(t);
          } else {
            e = [];
            this._changesInElement.set(t, e);
          }
          return e;
        }
        _makeSnapshot(t) {
          if (!this._elementSnapshots.has(t)) {
            this._elementSnapshots.set(t, Mp(t.getChildren()));
          }
        }
        _handleChange(t, e) {
          t.nodesToHandle = t.howMany;
          for (const n of e) {
            const o = t.offset + t.howMany;
            const i = n.offset + n.howMany;
            if (t.type == "insert") {
              if (n.type == "insert") {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany;
                } else if (t.offset < i) {
                  n.howMany += t.nodesToHandle;
                  t.nodesToHandle = 0;
                }
              }
              if (n.type == "remove") {
                if (t.offset < n.offset) {
                  n.offset += t.howMany;
                }
              }
              if (n.type == "attribute") {
                if (t.offset <= n.offset) {
                  n.offset += t.howMany;
                } else if (t.offset < i) {
                  const i = n.howMany;
                  n.howMany = t.offset - n.offset;
                  e.unshift({
                    type: "attribute",
                    offset: o,
                    howMany: i - n.howMany,
                    count: this._changeCount++,
                  });
                }
              }
            }
            if (t.type == "remove") {
              if (n.type == "insert") {
                if (o <= n.offset) {
                  n.offset -= t.howMany;
                } else if (o <= i) {
                  if (t.offset < n.offset) {
                    const e = o - n.offset;
                    n.offset = t.offset;
                    n.howMany -= e;
                    t.nodesToHandle -= e;
                  } else {
                    n.howMany -= t.nodesToHandle;
                    t.nodesToHandle = 0;
                  }
                } else {
                  if (t.offset <= n.offset) {
                    t.nodesToHandle -= n.howMany;
                    n.howMany = 0;
                  } else if (t.offset < i) {
                    const e = i - t.offset;
                    n.howMany -= e;
                    t.nodesToHandle -= e;
                  }
                }
              }
              if (n.type == "remove") {
                if (o <= n.offset) {
                  n.offset -= t.howMany;
                } else if (t.offset < n.offset) {
                  t.nodesToHandle += n.howMany;
                  n.howMany = 0;
                }
              }
              if (n.type == "attribute") {
                if (o <= n.offset) {
                  n.offset -= t.howMany;
                } else if (t.offset < n.offset) {
                  const e = o - n.offset;
                  n.offset = t.offset;
                  n.howMany -= e;
                } else if (t.offset < i) {
                  if (o <= i) {
                    const o = n.howMany;
                    n.howMany = t.offset - n.offset;
                    const i = o - n.howMany - t.nodesToHandle;
                    e.unshift({
                      type: "attribute",
                      offset: t.offset,
                      howMany: i,
                      count: this._changeCount++,
                    });
                  } else {
                    n.howMany -= i - t.offset;
                  }
                }
              }
            }
            if (t.type == "attribute") {
              if (n.type == "insert") {
                if (t.offset < n.offset && o > n.offset) {
                  if (o > i) {
                    const t = {
                      type: "attribute",
                      offset: i,
                      howMany: o - i,
                      count: this._changeCount++,
                    };
                    this._handleChange(t, e);
                    e.push(t);
                  }
                  t.nodesToHandle = n.offset - t.offset;
                  t.howMany = t.nodesToHandle;
                } else if (t.offset >= n.offset && t.offset < i) {
                  if (o > i) {
                    t.nodesToHandle = o - i;
                    t.offset = i;
                  } else {
                    t.nodesToHandle = 0;
                  }
                }
              }
              if (n.type == "remove") {
                if (t.offset < n.offset && o > n.offset) {
                  const i = {
                    type: "attribute",
                    offset: n.offset,
                    howMany: o - n.offset,
                    count: this._changeCount++,
                  };
                  this._handleChange(i, e);
                  e.push(i);
                  t.nodesToHandle = n.offset - t.offset;
                  t.howMany = t.nodesToHandle;
                }
              }
              if (n.type == "attribute") {
                if (t.offset >= n.offset && o <= i) {
                  t.nodesToHandle = 0;
                  t.howMany = 0;
                  t.offset = 0;
                } else if (t.offset <= n.offset && o >= i) {
                  n.howMany = 0;
                }
              }
            }
          }
          t.howMany = t.nodesToHandle;
          delete t.nodesToHandle;
        }
        _getInsertDiff(t, e, n) {
          return {
            type: "insert",
            position: Yh._createAt(t, e),
            name: n,
            length: 1,
            changeCount: this._changeCount++,
          };
        }
        _getRemoveDiff(t, e, n) {
          return {
            type: "remove",
            position: Yh._createAt(t, e),
            name: n,
            length: 1,
            changeCount: this._changeCount++,
          };
        }
        _getAttributesDiff(t, e, n) {
          const o = [];
          n = new Map(n);
          for (const [i, r] of e) {
            const e = n.has(i) ? n.get(i) : null;
            if (e !== r) {
              o.push({
                type: "attribute",
                position: t.start,
                range: t.clone(),
                length: 1,
                attributeKey: i,
                attributeOldValue: r,
                attributeNewValue: e,
                changeCount: this._changeCount++,
              });
            }
            n.delete(i);
          }
          for (const [e, i] of n) {
            o.push({
              type: "attribute",
              position: t.start,
              range: t.clone(),
              length: 1,
              attributeKey: e,
              attributeOldValue: null,
              attributeNewValue: i,
              changeCount: this._changeCount++,
            });
          }
          return o;
        }
        _isInInsertedElement(t) {
          const e = t.parent;
          if (!e) {
            return false;
          }
          const n = this._changesInElement.get(e);
          const o = t.startOffset;
          if (n) {
            for (const t of n) {
              if (
                t.type == "insert" &&
                o >= t.offset &&
                o < t.offset + t.howMany
              ) {
                return true;
              }
            }
          }
          return this._isInInsertedElement(e);
        }
        _removeAllNestedChanges(t, e, n) {
          const o = new tf(Yh._createAt(t, e), Yh._createAt(t, e + n));
          for (const t of o.getItems({ shallow: true })) {
            if (t.is("element")) {
              this._elementSnapshots.delete(t);
              this._changesInElement.delete(t);
              this._removeAllNestedChanges(t, 0, t.maxOffset);
            }
          }
        }
      }
      function Mp(t) {
        const e = [];
        for (const n of t) {
          if (n.is("$text")) {
            for (let t = 0; t < n.data.length; t++) {
              e.push({ name: "$text", attributes: new Map(n.getAttributes()) });
            }
          } else {
            e.push({ name: n.name, attributes: new Map(n.getAttributes()) });
          }
        }
        return e;
      }
      function Vp(t, e) {
        const n = [];
        let o = 0;
        let i = 0;
        for (const t of e) {
          if (t.offset > o) {
            for (let e = 0; e < t.offset - o; e++) {
              n.push("e");
            }
            i += t.offset - o;
          }
          if (t.type == "insert") {
            for (let e = 0; e < t.howMany; e++) {
              n.push("i");
            }
            o = t.offset + t.howMany;
          } else if (t.type == "remove") {
            for (let e = 0; e < t.howMany; e++) {
              n.push("r");
            }
            o = t.offset;
            i += t.howMany;
          } else {
            n.push(..."a".repeat(t.howMany).split(""));
            o = t.offset + t.howMany;
            i += t.howMany;
          }
        }
        if (i < t) {
          for (let e = 0; e < t - i - o; e++) {
            n.push("e");
          }
        }
        return n;
      }
      function Lp(t) {
        const e = t.position && t.position.root.rootName == "$graveyard";
        const n = t.range && t.range.root.rootName == "$graveyard";
        return !e && !n;
      }
      class zp {
        constructor() {
          this._operations = [];
          this._undoPairs = new Map();
          this._undoneOperations = new Set();
        }
        addOperation(t) {
          if (this._operations.includes(t)) {
            return;
          }
          this._operations.push(t);
        }
        getOperations(
          t = Number.NEGATIVE_INFINITY,
          e = Number.POSITIVE_INFINITY
        ) {
          const n = [];
          for (const o of this._operations) {
            if (o.baseVersion >= t && o.baseVersion < e) {
              n.push(o);
            }
          }
          return n;
        }
        getOperation(t) {
          for (const e of this._operations) {
            if (e.baseVersion == t) {
              return e;
            }
          }
        }
        setOperationAsUndone(t, e) {
          this._undoPairs.set(e, t);
          this._undoneOperations.add(t);
        }
        isUndoingOperation(t) {
          return this._undoPairs.has(t);
        }
        isUndoneOperation(t) {
          return this._undoneOperations.has(t);
        }
        getUndoneOperation(t) {
          return this._undoPairs.get(t);
        }
      }
      function jp(t) {
        return (
          !!t &&
          t.length == 1 &&
          /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(
            t
          )
        );
      }
      function Kp(t) {
        return !!t && t.length == 1 && /[\ud800-\udbff]/.test(t);
      }
      function qp(t) {
        return !!t && t.length == 1 && /[\udc00-\udfff]/.test(t);
      }
      function $p(t, e) {
        return Kp(t.charAt(e - 1)) && qp(t.charAt(e));
      }
      function Wp(t, e) {
        return jp(t.charAt(e));
      }
      const Gp = "$graveyard";
      class Up {
        constructor(t) {
          this.model = t;
          this.version = 0;
          this.history = new zp(this);
          this.selection = new Af(this);
          this.roots = new vs({ idProperty: "rootName" });
          this.differ = new Np(t.markers);
          this._postFixers = new Set();
          this._hasSelectionChangedFromTheLastChangeBlock = false;
          this.createRoot("$root", Gp);
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation && n.baseVersion !== this.version) {
                throw new ss["a"](
                  "model-document-applyoperation-wrong-version",
                  this,
                  { operation: n }
                );
              }
            },
            { priority: "highest" }
          );
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation) {
                this.differ.bufferOperation(n);
              }
            },
            { priority: "high" }
          );
          this.listenTo(
            t,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (n.isDocumentOperation) {
                this.version++;
                this.history.addOperation(n);
              }
            },
            { priority: "low" }
          );
          this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = true;
          });
          this.listenTo(t.markers, "update", (t, e, n, o) => {
            this.differ.bufferMarkerChange(e.name, n, o, e.affectsData);
            if (n === null) {
              e.on("change", (t, n) => {
                this.differ.bufferMarkerChange(
                  e.name,
                  n,
                  e.getRange(),
                  e.affectsData
                );
              });
            }
          });
        }
        get graveyard() {
          return this.getRoot(Gp);
        }
        createRoot(t = "$root", e = "main") {
          if (this.roots.get(e)) {
            throw new ss["a"]("model-document-createroot-name-exists", this, {
              name: e,
            });
          }
          const n = new Dp(this, t, e);
          this.roots.add(n);
          return n;
        }
        destroy() {
          this.selection.destroy();
          this.stopListening();
        }
        getRoot(t = "main") {
          return this.roots.get(t);
        }
        getRootNames() {
          return Array.from(this.roots, (t) => t.rootName).filter(
            (t) => t != Gp
          );
        }
        registerPostFixer(t) {
          this._postFixers.add(t);
        }
        toJSON() {
          const t = Vs(this);
          t.selection = "[engine.model.DocumentSelection]";
          t.model = "[engine.model.Model]";
          return t;
        }
        _handleChangeBlock(t) {
          if (this._hasDocumentChangedFromTheLastChangeBlock()) {
            this._callPostFixers(t);
            this.selection.refresh();
            if (this.differ.hasDataChanges()) {
              this.fire("change:data", t.batch);
            } else {
              this.fire("change", t.batch);
            }
            this.selection.refresh();
            this.differ.reset();
          }
          this._hasSelectionChangedFromTheLastChangeBlock = false;
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return (
            !this.differ.isEmpty ||
            this._hasSelectionChangedFromTheLastChangeBlock
          );
        }
        _getDefaultRoot() {
          for (const t of this.roots) {
            if (t !== this.graveyard) {
              return t;
            }
          }
          return this.graveyard;
        }
        _getDefaultRange() {
          const t = this._getDefaultRoot();
          const e = this.model;
          const n = e.schema;
          const o = e.createPositionFromPath(t, [0]);
          const i = n.getNearestSelectionRange(o);
          return i || e.createRange(o);
        }
        _validateSelectionRange(t) {
          return Hp(t.start) && Hp(t.end);
        }
        _callPostFixers(t) {
          let e = false;
          do {
            for (const n of this._postFixers) {
              this.selection.refresh();
              e = n(t);
              if (e) {
                break;
              }
            }
          } while (e);
        }
      }
      Cs(Up, ds);
      function Hp(t) {
        const e = t.textNode;
        if (e) {
          const n = e.data;
          const o = t.offset - e.startOffset;
          return !$p(n, o) && !Wp(n, o);
        }
        return true;
      }
      class Jp {
        constructor() {
          this._markers = new Map();
        }
        [Symbol.iterator]() {
          return this._markers.values();
        }
        has(t) {
          return this._markers.has(t);
        }
        get(t) {
          return this._markers.get(t) || null;
        }
        _set(t, e, n = false, o = false) {
          const i = t instanceof Yp ? t.name : t;
          if (i.includes(",")) {
            throw new ss["a"]("markercollection-incorrect-marker-name", this);
          }
          const r = this._markers.get(i);
          if (r) {
            const t = r.getRange();
            let s = false;
            if (!t.isEqual(e)) {
              r._attachLiveRange(mf.fromRange(e));
              s = true;
            }
            if (n != r.managedUsingOperations) {
              r._managedUsingOperations = n;
              s = true;
            }
            if (typeof o === "boolean" && o != r.affectsData) {
              r._affectsData = o;
              s = true;
            }
            if (s) {
              this.fire("update:" + i, r, t, e);
            }
            return r;
          }
          const s = mf.fromRange(e);
          const a = new Yp(i, s, n, o);
          this._markers.set(i, a);
          this.fire("update:" + i, a, null, e);
          return a;
        }
        _remove(t) {
          const e = t instanceof Yp ? t.name : t;
          const n = this._markers.get(e);
          if (n) {
            this._markers.delete(e);
            this.fire("update:" + e, n, n.getRange(), null);
            this._destroyMarker(n);
            return true;
          }
          return false;
        }
        _refresh(t) {
          const e = t instanceof Yp ? t.name : t;
          const n = this._markers.get(e);
          if (!n) {
            throw new ss["a"](
              "markercollection-refresh-marker-not-exists",
              this
            );
          }
          const o = n.getRange();
          this.fire(
            "update:" + e,
            n,
            o,
            o,
            n.managedUsingOperations,
            n.affectsData
          );
        }
        *getMarkersAtPosition(t) {
          for (const e of this) {
            if (e.getRange().containsPosition(t)) {
              yield e;
            }
          }
        }
        *getMarkersIntersectingRange(t) {
          for (const e of this) {
            if (e.getRange().getIntersection(t) !== null) {
              yield e;
            }
          }
        }
        destroy() {
          for (const t of this._markers.values()) {
            this._destroyMarker(t);
          }
          this._markers = null;
          this.stopListening();
        }
        *getMarkersGroup(t) {
          for (const e of this._markers.values()) {
            if (e.name.startsWith(t + ":")) {
              yield e;
            }
          }
        }
        _destroyMarker(t) {
          t.stopListening();
          t._detachLiveRange();
        }
      }
      Cs(Jp, ds);
      class Yp {
        constructor(t, e, n, o) {
          this.name = t;
          this._liveRange = this._attachLiveRange(e);
          this._managedUsingOperations = n;
          this._affectsData = o;
        }
        get managedUsingOperations() {
          if (!this._liveRange) {
            throw new ss["a"]("marker-destroyed", this);
          }
          return this._managedUsingOperations;
        }
        get affectsData() {
          if (!this._liveRange) {
            throw new ss["a"]("marker-destroyed", this);
          }
          return this._affectsData;
        }
        getStart() {
          if (!this._liveRange) {
            throw new ss["a"]("marker-destroyed", this);
          }
          return this._liveRange.start.clone();
        }
        getEnd() {
          if (!this._liveRange) {
            throw new ss["a"]("marker-destroyed", this);
          }
          return this._liveRange.end.clone();
        }
        getRange() {
          if (!this._liveRange) {
            throw new ss["a"]("marker-destroyed", this);
          }
          return this._liveRange.toRange();
        }
        is(t) {
          return t === "marker" || t === "model:marker";
        }
        _attachLiveRange(t) {
          if (this._liveRange) {
            this._detachLiveRange();
          }
          t.delegate("change:range").to(this);
          t.delegate("change:content").to(this);
          this._liveRange = t;
          return t;
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating("change:range", this);
          this._liveRange.stopDelegating("change:content", this);
          this._liveRange.detach();
          this._liveRange = null;
        }
      }
      Cs(Yp, ds);
      class Qp extends ap {
        get type() {
          return "noop";
        }
        clone() {
          return new Qp(this.baseVersion);
        }
        getReversed() {
          return new Qp(this.baseVersion + 1);
        }
        _execute() {}
        static get className() {
          return "NoOperation";
        }
      }
      const Xp = {};
      Xp[_p.className] = _p;
      Xp[vp.className] = vp;
      Xp[yp.className] = yp;
      Xp[Cp.className] = Cp;
      Xp[Qp.className] = Qp;
      Xp[ap.className] = ap;
      Xp[xp.className] = xp;
      Xp[Ep.className] = Ep;
      Xp[Pp.className] = Pp;
      Xp[Sp.className] = Sp;
      class Zp {
        static fromJSON(t, e) {
          return Xp[t.__className].fromJSON(t, e);
        }
      }
      class tm extends Yh {
        constructor(t, e, n = "toNone") {
          super(t, e, n);
          if (!this.root.is("rootElement")) {
            throw new ss["a"]("model-liveposition-root-not-rootelement", t);
          }
          em.call(this);
        }
        detach() {
          this.stopListening();
        }
        is(t) {
          return (
            t === "livePosition" ||
            t === "model:livePosition" ||
            t == "position" ||
            t === "model:position"
          );
        }
        toPosition() {
          return new Yh(this.root, this.path.slice(), this.stickiness);
        }
        static fromPosition(t, e) {
          return new this(t.root, t.path.slice(), e ? e : t.stickiness);
        }
      }
      function em() {
        this.listenTo(
          this.root.document.model,
          "applyOperation",
          (t, e) => {
            const n = e[0];
            if (!n.isDocumentOperation) {
              return;
            }
            nm.call(this, n);
          },
          { priority: "low" }
        );
      }
      function nm(t) {
        const e = this.getTransformedByOperation(t);
        if (!this.isEqual(e)) {
          const t = this.toPosition();
          this.path = e.path;
          this.root = e.root;
          this.fire("change", t);
        }
      }
      Cs(tm, ds);
      function om(t, e, n, o) {
        return t.change((i) => {
          let r;
          if (!n) {
            r = t.document.selection;
          } else if (n instanceof df || n instanceof Af) {
            r = n;
          } else {
            r = i.createSelection(n, o);
          }
          if (!r.isCollapsed) {
            t.deleteContent(r, { doNotAutoparagraph: true });
          }
          const s = new im(t, i, r.anchor);
          let a;
          if (e.is("documentFragment")) {
            a = e.getChildren();
          } else {
            a = [e];
          }
          s.handleNodes(a, { isFirst: true, isLast: true });
          const c = s.getSelectionRange();
          if (c) {
            if (r instanceof Af) {
              i.setSelection(c);
            } else {
              r.setTo(c);
            }
          } else {
          }
          const l = s.getAffectedRange() || t.createRange(r.anchor);
          s.destroy();
          return l;
        });
      }
      class im {
        constructor(t, e, n) {
          this.model = t;
          this.writer = e;
          this.position = n;
          this.canMergeWith = new Set([this.position.parent]);
          this.schema = t.schema;
          this._filterAttributesOf = [];
          this._affectedStart = null;
          this._affectedEnd = null;
        }
        handleNodes(t, e) {
          t = Array.from(t);
          for (let n = 0; n < t.length; n++) {
            const o = t[n];
            this._handleNode(o, {
              isFirst: n === 0 && e.isFirst,
              isLast: n === t.length - 1 && e.isLast,
            });
          }
          this.schema.removeDisallowedAttributes(
            this._filterAttributesOf,
            this.writer
          );
          this._filterAttributesOf = [];
        }
        getSelectionRange() {
          if (this.nodeToSelect) {
            return tf._createOn(this.nodeToSelect);
          }
          return this.model.schema.getNearestSelectionRange(this.position);
        }
        getAffectedRange() {
          if (!this._affectedStart) {
            return null;
          }
          return new tf(this._affectedStart, this._affectedEnd);
        }
        destroy() {
          if (this._affectedStart) {
            this._affectedStart.detach();
          }
          if (this._affectedEnd) {
            this._affectedEnd.detach();
          }
        }
        _handleNode(t, e) {
          if (this.schema.isObject(t)) {
            this._handleObject(t, e);
            return;
          }
          const n = this._checkAndSplitToAllowedPosition(t, e);
          if (!n) {
            this._handleDisallowedNode(t, e);
            return;
          }
          this._insert(t);
          this._mergeSiblingsOf(t, e);
        }
        _handleObject(t, e) {
          if (this._checkAndSplitToAllowedPosition(t)) {
            this._insert(t);
          } else {
            this._tryAutoparagraphing(t, e);
          }
        }
        _handleDisallowedNode(t, e) {
          if (t.is("element")) {
            this.handleNodes(t.getChildren(), e);
          } else {
            this._tryAutoparagraphing(t, e);
          }
        }
        _insert(t) {
          if (!this.schema.checkChild(this.position, t)) {
            throw new ss["a"]("insertcontent-wrong-position", this, {
              node: t,
              position: this.position,
            });
          }
          const e = tm.fromPosition(this.position, "toNext");
          this._setAffectedBoundaries(this.position);
          this.writer.insert(t, this.position);
          this.position = e.toPosition();
          e.detach();
          if (
            this.schema.isObject(t) &&
            !this.schema.checkChild(this.position, "$text")
          ) {
            this.nodeToSelect = t;
          } else {
            this.nodeToSelect = null;
          }
          this._filterAttributesOf.push(t);
        }
        _setAffectedBoundaries(t) {
          if (!this._affectedStart) {
            this._affectedStart = tm.fromPosition(t, "toPrevious");
          }
          if (!this._affectedEnd || this._affectedEnd.isBefore(t)) {
            if (this._affectedEnd) {
              this._affectedEnd.detach();
            }
            this._affectedEnd = tm.fromPosition(t, "toNext");
          }
        }
        _mergeSiblingsOf(t, e) {
          if (!(t instanceof Gh)) {
            return;
          }
          const n = this._canMergeLeft(t, e);
          const o = this._canMergeRight(t, e);
          const i = tm._createBefore(t);
          i.stickiness = "toNext";
          const r = tm._createAfter(t);
          r.stickiness = "toNext";
          if (n) {
            const t = tm.fromPosition(this.position);
            t.stickiness = "toNext";
            if (this._affectedStart.isEqual(i)) {
              this._affectedStart.detach();
              this._affectedStart = tm._createAt(
                i.nodeBefore,
                "end",
                "toPrevious"
              );
            }
            this.writer.merge(i);
            if (i.isEqual(this._affectedEnd) && e.isLast) {
              this._affectedEnd.detach();
              this._affectedEnd = tm._createAt(i.nodeBefore, "end", "toNext");
            }
            this.position = t.toPosition();
            t.detach();
          }
          if (o) {
            if (!this.position.isEqual(r)) {
              throw new ss["a"](
                "insertcontent-invalid-insertion-position",
                this
              );
            }
            this.position = Yh._createAt(r.nodeBefore, "end");
            const t = tm.fromPosition(this.position, "toPrevious");
            if (this._affectedEnd.isEqual(r)) {
              this._affectedEnd.detach();
              this._affectedEnd = tm._createAt(r.nodeBefore, "end", "toNext");
            }
            this.writer.merge(r);
            if (r.getShiftedBy(-1).isEqual(this._affectedStart) && e.isFirst) {
              this._affectedStart.detach();
              this._affectedStart = tm._createAt(r.nodeBefore, 0, "toPrevious");
            }
            this.position = t.toPosition();
            t.detach();
          }
          if (n || o) {
            this._filterAttributesOf.push(this.position.parent);
          }
          i.detach();
          r.detach();
        }
        _canMergeLeft(t, e) {
          const n = t.previousSibling;
          return (
            e.isFirst &&
            n instanceof Gh &&
            this.canMergeWith.has(n) &&
            this.model.schema.checkMerge(n, t)
          );
        }
        _canMergeRight(t, e) {
          const n = t.nextSibling;
          return (
            e.isLast &&
            n instanceof Gh &&
            this.canMergeWith.has(n) &&
            this.model.schema.checkMerge(t, n)
          );
        }
        _tryAutoparagraphing(t, e) {
          const n = this.writer.createElement("paragraph");
          if (
            this._getAllowedIn(n, this.position.parent) &&
            this.schema.checkChild(n, t)
          ) {
            n._appendChild(t);
            this._handleNode(n, e);
          }
        }
        _checkAndSplitToAllowedPosition(t) {
          const e = this._getAllowedIn(t, this.position.parent);
          if (!e) {
            return false;
          }
          while (e != this.position.parent) {
            if (this.schema.isLimit(this.position.parent)) {
              return false;
            }
            if (this.position.isAtStart) {
              const t = this.position.parent;
              this.position = this.writer.createPositionBefore(t);
              if (t.isEmpty && t.parent === e) {
                this.writer.remove(t);
              }
            } else if (this.position.isAtEnd) {
              this.position = this.writer.createPositionAfter(
                this.position.parent
              );
            } else {
              const t = this.writer.createPositionAfter(this.position.parent);
              this._setAffectedBoundaries(this.position);
              this.writer.split(this.position);
              this.position = t;
              this.canMergeWith.add(this.position.nodeAfter);
            }
          }
          return true;
        }
        _getAllowedIn(t, e) {
          if (this.schema.checkChild(e, t)) {
            return e;
          }
          if (e.parent) {
            return this._getAllowedIn(t, e.parent);
          }
          return null;
        }
      }
      function rm(t, e, n = {}) {
        if (e.isCollapsed) {
          return;
        }
        const o = e.getFirstRange();
        if (o.root.rootName == "$graveyard") {
          return;
        }
        const i = t.schema;
        t.change((t) => {
          if (!n.doNotResetEntireContent && bm(i, e)) {
            km(t, e, i);
            return;
          }
          const [r, s] = sm(o);
          if (!r.isTouching(s)) {
            t.remove(t.createRange(r, s));
          }
          if (!n.leaveUnmerged) {
            cm(t, r, s);
            i.removeDisallowedAttributes(r.parent.getChildren(), t);
          }
          wm(t, e, r);
          if (!n.doNotAutoparagraph && gm(i, r)) {
            mm(t, r, e);
          }
          r.detach();
          s.detach();
        });
      }
      function sm(t) {
        const e = t.root.document.model;
        const n = t.start;
        let o = t.end;
        if (e.hasContent(t, { ignoreMarkers: true })) {
          const n = am(o);
          if (n && o.isTouching(e.createPositionAt(n, 0))) {
            const n = e.createSelection(t);
            e.modifySelection(n, { direction: "backward" });
            o = n.getLastPosition();
          }
        }
        return [tm.fromPosition(n, "toPrevious"), tm.fromPosition(o, "toNext")];
      }
      function am(t) {
        const e = t.parent;
        const n = e.root.document.model.schema;
        const o = e.getAncestors({ parentFirst: true, includeSelf: true });
        for (const t of o) {
          if (n.isLimit(t)) {
            return null;
          }
          if (n.isBlock(t)) {
            return t;
          }
        }
      }
      function cm(t, e, n) {
        const o = t.model;
        if (!hm(t.model.schema, e, n)) {
          return;
        }
        const [i, r] = fm(e, n);
        if (
          !o.hasContent(i, { ignoreMarkers: true }) &&
          o.hasContent(r, { ignoreMarkers: true })
        ) {
          dm(t, e, n, i.parent);
        } else {
          lm(t, e, n, i.parent);
        }
      }
      function lm(t, e, n, o) {
        const i = e.parent;
        const r = n.parent;
        if (i == o || r == o) {
          return;
        }
        e = t.createPositionAfter(i);
        n = t.createPositionBefore(r);
        if (!n.isEqual(e)) {
          t.insert(r, e);
        }
        t.merge(e);
        while (n.parent.isEmpty) {
          const e = n.parent;
          n = t.createPositionBefore(e);
          t.remove(e);
        }
        if (!hm(t.model.schema, e, n)) {
          return;
        }
        lm(t, e, n, o);
      }
      function dm(t, e, n, o) {
        const i = e.parent;
        const r = n.parent;
        if (i == o || r == o) {
          return;
        }
        e = t.createPositionAfter(i);
        n = t.createPositionBefore(r);
        if (!n.isEqual(e)) {
          t.insert(i, n);
        }
        while (e.parent.isEmpty) {
          const n = e.parent;
          e = t.createPositionBefore(n);
          t.remove(n);
        }
        n = t.createPositionBefore(r);
        um(t, n);
        if (!hm(t.model.schema, e, n)) {
          return;
        }
        dm(t, e, n, o);
      }
      function um(t, e) {
        const n = e.nodeBefore;
        const o = e.nodeAfter;
        if (n.name != o.name) {
          t.rename(n, o.name);
        }
        t.clearAttributes(n);
        t.setAttributes(Object.fromEntries(o.getAttributes()), n);
        t.merge(e);
      }
      function hm(t, e, n) {
        const o = e.parent;
        const i = n.parent;
        if (o == i) {
          return false;
        }
        if (t.isLimit(o) || t.isLimit(i)) {
          return false;
        }
        return pm(e, n, t);
      }
      function fm(t, e) {
        const n = t.getAncestors();
        const o = e.getAncestors();
        let i = 0;
        while (n[i] && n[i] == o[i]) {
          i++;
        }
        return [n[i], o[i]];
      }
      function gm(t, e) {
        const n = t.checkChild(e, "$text");
        const o = t.checkChild(e, "paragraph");
        return !n && o;
      }
      function pm(t, e, n) {
        const o = new tf(t, e);
        for (const t of o.getWalker()) {
          if (n.isLimit(t.item)) {
            return false;
          }
        }
        return true;
      }
      function mm(t, e, n) {
        const o = t.createElement("paragraph");
        t.insert(o, e);
        wm(t, n, t.createPositionAt(o, 0));
      }
      function km(t, e) {
        const n = t.model.schema.getLimitElement(e);
        t.remove(t.createRangeIn(n));
        mm(t, t.createPositionAt(n, 0), e);
      }
      function bm(t, e) {
        const n = t.getLimitElement(e);
        if (!e.containsEntireContent(n)) {
          return false;
        }
        const o = e.getFirstRange();
        if (o.start.parent == o.end.parent) {
          return false;
        }
        return t.checkChild(n, "paragraph");
      }
      function wm(t, e, n) {
        if (e instanceof Af) {
          t.setSelection(n);
        } else {
          e.setTo(n);
        }
      }
      const _m = ' ,.?!:;"-()';
      function Am(t, e, n = {}) {
        const o = t.schema;
        const i = n.direction != "backward";
        const r = n.unit ? n.unit : "character";
        const s = e.focus;
        const a = new Hh({
          boundaries: xm(s, i),
          singleCharacters: true,
          direction: i ? "forward" : "backward",
        });
        const c = { walker: a, schema: o, isForward: i, unit: r };
        let l;
        while ((l = a.next())) {
          if (l.done) {
            return;
          }
          const n = Cm(c, l.value);
          if (n) {
            if (e instanceof Af) {
              t.change((t) => {
                t.setSelectionFocus(n);
              });
            } else {
              e.setFocus(n);
            }
            return;
          }
        }
      }
      function Cm(t, e) {
        const { isForward: n, walker: o, unit: i, schema: r } = t;
        const { type: s, item: a, nextPosition: c } = e;
        if (s == "text") {
          if (t.unit === "word") {
            return ym(o, n);
          }
          return vm(o, i, n);
        }
        if (s == (n ? "elementStart" : "elementEnd")) {
          if (r.isSelectable(a)) {
            return Yh._createAt(a, n ? "after" : "before");
          }
          if (r.checkChild(c, "$text")) {
            return c;
          }
        } else {
          if (r.isLimit(a)) {
            o.skip(() => true);
            return;
          }
          if (r.checkChild(c, "$text")) {
            return c;
          }
        }
      }
      function vm(t, e) {
        const n = t.position.textNode;
        if (n) {
          const o = n.data;
          let i = t.position.offset - n.startOffset;
          while ($p(o, i) || (e == "character" && Wp(o, i))) {
            t.next();
            i = t.position.offset - n.startOffset;
          }
        }
        return t.position;
      }
      function ym(t, e) {
        let n = t.position.textNode;
        if (n) {
          let o = t.position.offset - n.startOffset;
          while (!Em(n.data, o, e) && !Sm(n, o, e)) {
            t.next();
            const i = e ? t.position.nodeAfter : t.position.nodeBefore;
            if (i && i.is("$text")) {
              const o = i.data.charAt(e ? 0 : i.data.length - 1);
              if (!_m.includes(o)) {
                t.next();
                n = t.position.textNode;
              }
            }
            o = t.position.offset - n.startOffset;
          }
        }
        return t.position;
      }
      function xm(t, e) {
        const n = t.root;
        const o = Yh._createAt(n, e ? "end" : 0);
        if (e) {
          return new tf(t, o);
        } else {
          return new tf(o, t);
        }
      }
      function Em(t, e, n) {
        const o = e + (n ? 0 : -1);
        return _m.includes(t.charAt(o));
      }
      function Sm(t, e, n) {
        return e === (n ? t.endOffset : 0);
      }
      function Pm(t, e) {
        return t.change((t) => {
          const n = t.createDocumentFragment();
          const o = e.getFirstRange();
          if (!o || o.isCollapsed) {
            return n;
          }
          const i = o.start.root;
          const r = o.start.getCommonPath(o.end);
          const s = i.getNodeByPath(r);
          let a;
          if (o.start.parent == o.end.parent) {
            a = o;
          } else {
            a = t.createRange(
              t.createPositionAt(s, o.start.path[r.length]),
              t.createPositionAt(s, o.end.path[r.length] + 1)
            );
          }
          const c = a.end.offset - a.start.offset;
          for (const e of a.getItems({ shallow: true })) {
            if (e.is("$textProxy")) {
              t.appendText(e.data, e.getAttributes(), n);
            } else {
              t.append(t.cloneElement(e, true), n);
            }
          }
          if (a != o) {
            const e = o._getTransformedByMove(
              a.start,
              t.createPositionAt(n, 0),
              c
            )[0];
            const i = t.createRange(t.createPositionAt(n, 0), e.start);
            const r = t.createRange(e.end, t.createPositionAt(n, "end"));
            Dm(r, t);
            Dm(i, t);
          }
          return n;
        });
      }
      function Dm(t, e) {
        const n = [];
        Array.from(t.getItems({ direction: "backward" }))
          .map((t) => e.createRangeOn(t))
          .filter((e) => {
            const n =
              (e.start.isAfter(t.start) || e.start.isEqual(t.start)) &&
              (e.end.isBefore(t.end) || e.end.isEqual(t.end));
            return n;
          })
          .forEach((t) => {
            n.push(t.start.parent);
            e.remove(t);
          });
        n.forEach((t) => {
          let n = t;
          while (n.parent && n.isEmpty) {
            const t = e.createRangeOn(n);
            n = n.parent;
            e.remove(t);
          }
        });
      }
      function Tm(t) {
        t.document.registerPostFixer((e) => Bm(e, t));
      }
      function Bm(t, e) {
        const n = e.document.selection;
        const o = e.schema;
        const i = [];
        let r = false;
        for (const t of n.getRanges()) {
          const e = Im(t, o);
          if (e && !e.isEqual(t)) {
            i.push(e);
            r = true;
          } else {
            i.push(t);
          }
        }
        if (r) {
          t.setSelection(Mm(i), { backward: n.isBackward });
        }
      }
      function Im(t, e) {
        if (t.isCollapsed) {
          return Om(t, e);
        }
        return Rm(t, e);
      }
      function Om(t, e) {
        const n = t.start;
        const o = e.getNearestSelectionRange(n);
        if (!o) {
          return null;
        }
        if (!o.isCollapsed) {
          return o;
        }
        const i = o.start;
        if (n.isEqual(i)) {
          return null;
        }
        return new tf(i);
      }
      function Rm(t, e) {
        const { start: n, end: o } = t;
        const i = e.checkChild(n, "$text");
        const r = e.checkChild(o, "$text");
        const s = e.getLimitElement(n);
        const a = e.getLimitElement(o);
        if (s === a) {
          if (i && r) {
            return null;
          }
          if (Nm(n, o, e)) {
            const t = n.nodeAfter && e.isSelectable(n.nodeAfter);
            const i = t ? null : e.getNearestSelectionRange(n, "forward");
            const r = o.nodeBefore && e.isSelectable(o.nodeBefore);
            const s = r ? null : e.getNearestSelectionRange(o, "backward");
            const a = i ? i.start : n;
            const c = s ? s.start : o;
            return new tf(a, c);
          }
        }
        const c = s && !s.is("rootElement");
        const l = a && !a.is("rootElement");
        if (c || l) {
          const t =
            n.nodeAfter &&
            o.nodeBefore &&
            n.nodeAfter.parent === o.nodeBefore.parent;
          const i = c && (!t || !Vm(n.nodeAfter, e));
          const r = l && (!t || !Vm(o.nodeBefore, e));
          let d = n;
          let u = o;
          if (i) {
            d = Yh._createBefore(Fm(s, e));
          }
          if (r) {
            u = Yh._createAfter(Fm(a, e));
          }
          return new tf(d, u);
        }
        return null;
      }
      function Fm(t, e) {
        let n = t;
        let o = n;
        while (e.isLimit(o) && o.parent) {
          n = o;
          o = o.parent;
        }
        return n;
      }
      function Nm(t, e, n) {
        const o =
          (t.nodeAfter && !n.isLimit(t.nodeAfter)) || n.checkChild(t, "$text");
        const i =
          (e.nodeBefore && !n.isLimit(e.nodeBefore)) ||
          n.checkChild(e, "$text");
        return o || i;
      }
      function Mm(t) {
        const e = [];
        e.push(t.shift());
        for (const n of t) {
          const t = e.pop();
          if (n.isIntersecting(t)) {
            const o = t.start.isAfter(n.start) ? n.start : t.start;
            const i = t.end.isAfter(n.end) ? t.end : n.end;
            const r = new tf(o, i);
            e.push(r);
          } else {
            e.push(t);
            e.push(n);
          }
        }
        return e;
      }
      function Vm(t, e) {
        return t && e.isSelectable(t);
      }
      class Lm {
        constructor() {
          this.markers = new Jp();
          this.document = new Up(this);
          this.schema = new Rg();
          this._pendingChanges = [];
          this._currentWriter = null;
          [
            "insertContent",
            "deleteContent",
            "modifySelection",
            "getSelectedContent",
            "applyOperation",
          ].forEach((t) => this.decorate(t));
          this.on(
            "applyOperation",
            (t, e) => {
              const n = e[0];
              n._validate();
            },
            { priority: "highest" }
          );
          this.schema.register("$root", { isLimit: true });
          this.schema.register("$block", { allowIn: "$root", isBlock: true });
          this.schema.register("$text", {
            allowIn: "$block",
            isInline: true,
            isContent: true,
          });
          this.schema.register("$clipboardHolder", {
            allowContentOf: "$root",
            isLimit: true,
          });
          this.schema.extend("$text", { allowIn: "$clipboardHolder" });
          this.schema.register("$marker");
          this.schema.addChildCheck((t, e) => {
            if (e.name === "$marker") {
              return true;
            }
          });
          Tm(this);
          this.document.registerPostFixer(ag);
        }
        change(t) {
          try {
            if (this._pendingChanges.length === 0) {
              this._pendingChanges.push({ batch: new sp(), callback: t });
              return this._runPendingChanges()[0];
            } else {
              return t(this._currentWriter);
            }
          } catch (t) {
            ss["a"].rethrowUnexpectedError(t, this);
          }
        }
        enqueueChange(t, e) {
          try {
            if (typeof t === "string") {
              t = new sp(t);
            } else if (typeof t == "function") {
              e = t;
              t = new sp();
            }
            this._pendingChanges.push({ batch: t, callback: e });
            if (this._pendingChanges.length == 1) {
              this._runPendingChanges();
            }
          } catch (t) {
            ss["a"].rethrowUnexpectedError(t, this);
          }
        }
        applyOperation(t) {
          t._execute();
        }
        insertContent(t, e, n) {
          return om(this, t, e, n);
        }
        deleteContent(t, e) {
          rm(this, t, e);
        }
        modifySelection(t, e) {
          Am(this, t, e);
        }
        getSelectedContent(t) {
          return Pm(this, t);
        }
        hasContent(t, e = {}) {
          const n = t instanceof Gh ? tf._createIn(t) : t;
          if (n.isCollapsed) {
            return false;
          }
          const { ignoreWhitespaces: o = false, ignoreMarkers: i = false } = e;
          if (!i) {
            for (const t of this.markers.getMarkersIntersectingRange(n)) {
              if (t.affectsData) {
                return true;
              }
            }
          }
          for (const t of n.getItems()) {
            if (this.schema.isContent(t)) {
              if (t.is("$textProxy")) {
                if (!o) {
                  return true;
                } else if (t.data.search(/\S/) !== -1) {
                  return true;
                }
              } else {
                return true;
              }
            }
          }
          return false;
        }
        createPositionFromPath(t, e, n) {
          return new Yh(t, e, n);
        }
        createPositionAt(t, e) {
          return Yh._createAt(t, e);
        }
        createPositionAfter(t) {
          return Yh._createAfter(t);
        }
        createPositionBefore(t) {
          return Yh._createBefore(t);
        }
        createRange(t, e) {
          return new tf(t, e);
        }
        createRangeIn(t) {
          return tf._createIn(t);
        }
        createRangeOn(t) {
          return tf._createOn(t);
        }
        createSelection(t, e, n) {
          return new df(t, e, n);
        }
        createBatch(t) {
          return new sp(t);
        }
        createOperationFromJSON(t) {
          return Zp.fromJSON(t, this.document);
        }
        destroy() {
          this.document.destroy();
          this.stopListening();
        }
        _runPendingChanges() {
          const t = [];
          this.fire("_beforeChanges");
          while (this._pendingChanges.length) {
            const e = this._pendingChanges[0].batch;
            this._currentWriter = new Tp(this, e);
            const n = this._pendingChanges[0].callback(this._currentWriter);
            t.push(n);
            this.document._handleChangeBlock(this._currentWriter);
            this._pendingChanges.shift();
            this._currentWriter = null;
          }
          this.fire("_afterChanges");
          return t;
        }
      }
      Cs(Lm, Yc);
      class zm {
        constructor() {
          this._listener = Object.create(Yd);
        }
        listenTo(t) {
          this._listener.listenTo(t, "keydown", (t, e) => {
            this._listener.fire("_keydown:" + Nl(e), e);
          });
        }
        set(t, e, n = {}) {
          const o = Ml(t);
          const i = n.priority;
          this._listener.listenTo(
            this._listener,
            "_keydown:" + o,
            (t, n) => {
              e(n, () => {
                n.preventDefault();
                n.stopPropagation();
                t.stop();
              });
              t.return = true;
            },
            { priority: i }
          );
        }
        press(t) {
          return !!this._listener.fire("_keydown:" + Nl(t), t);
        }
        destroy() {
          this._listener.stopListening();
        }
      }
      class jm extends zm {
        constructor(t) {
          super();
          this.editor = t;
        }
        set(t, e, n = {}) {
          if (typeof e == "string") {
            const t = e;
            e = (e, n) => {
              this.editor.execute(t);
              n();
            };
          }
          super.set(t, e, n);
        }
      }
      class Km {
        constructor(t = {}) {
          this._context = t.context || new Rs({ language: t.language });
          this._context._addEditor(this, !t.context);
          const e = Array.from(this.constructor.builtinPlugins || []);
          this.config = new Jr(t, this.constructor.defaultConfig);
          this.config.define("plugins", e);
          this.config.define(this._context._getEditorConfig());
          this.plugins = new ys(this, e, this._context.plugins);
          this.locale = this._context.locale;
          this.t = this.locale.t;
          this.commands = new Bg();
          this.set("state", "initializing");
          this.once("ready", () => (this.state = "ready"), {
            priority: "high",
          });
          this.once("destroy", () => (this.state = "destroyed"), {
            priority: "high",
          });
          this.set("isReadOnly", false);
          this.model = new Lm();
          const n = new Rc();
          this.data = new ep(this.model, n);
          this.editing = new Tg(this.model, n);
          this.editing.view.document.bind("isReadOnly").to(this);
          this.conversion = new op(
            [this.editing.downcastDispatcher, this.data.downcastDispatcher],
            this.data.upcastDispatcher
          );
          this.conversion.addAlias(
            "dataDowncast",
            this.data.downcastDispatcher
          );
          this.conversion.addAlias(
            "editingDowncast",
            this.editing.downcastDispatcher
          );
          this.keystrokes = new jm(this);
          this.keystrokes.listenTo(this.editing.view.document);
        }
        initPlugins() {
          const t = this.config;
          const e = t.get("plugins");
          const n = t.get("removePlugins") || [];
          const o = t.get("extraPlugins") || [];
          return this.plugins.init(e.concat(o), n);
        }
        destroy() {
          let t = Promise.resolve();
          if (this.state == "initializing") {
            t = new Promise((t) => this.once("ready", t));
          }
          return t
            .then(() => {
              this.fire("destroy");
              this.stopListening();
              this.commands.destroy();
            })
            .then(() => this.plugins.destroy())
            .then(() => {
              this.model.destroy();
              this.data.destroy();
              this.editing.destroy();
              this.keystrokes.destroy();
            })
            .then(() => this._context._removeEditor(this));
        }
        execute(...t) {
          try {
            return this.commands.execute(...t);
          } catch (t) {
            ss["a"].rethrowUnexpectedError(t, this);
          }
        }
      }
      Cs(Km, Yc);
      const qm = {
        setData(t) {
          this.data.set(t);
        },
        getData(t) {
          return this.data.get(t);
        },
      };
      var $m = qm;
      function Wm(t, e) {
        if (t instanceof HTMLTextAreaElement) {
          t.value = e;
        }
        t.innerHTML = e;
      }
      const Gm = {
        updateSourceElement() {
          if (!this.sourceElement) {
            throw new ss["a"]("editor-missing-sourceelement", this);
          }
          Wm(this.sourceElement, this.data.get());
        },
      };
      var Um = Gm;
      function Hm(t) {
        if (!gt(t.updateSourceElement)) {
          throw new ss["a"]("attachtoform-missing-elementapi-interface", t);
        }
        const e = t.sourceElement;
        if (e && e.tagName.toLowerCase() === "textarea" && e.form) {
          let n;
          const o = e.form;
          const i = () => t.updateSourceElement();
          if (gt(o.submit)) {
            n = o.submit;
            o.submit = () => {
              i();
              n.apply(o);
            };
          }
          o.addEventListener("submit", i);
          t.on("destroy", () => {
            o.removeEventListener("submit", i);
            if (n) {
              o.submit = n;
            }
          });
        }
      }
      class Jm {
        getHtml(t) {
          const e = document.implementation.createHTMLDocument("");
          const n = e.createElement("div");
          n.appendChild(t);
          return n.innerHTML;
        }
      }
      class Ym {
        constructor(t) {
          this._domParser = new DOMParser();
          this._domConverter = new qd(t, { blockFillerMode: "nbsp" });
          this._htmlWriter = new Jm();
        }
        toData(t) {
          const e = this._domConverter.viewToDom(t, document);
          return this._htmlWriter.getHtml(e);
        }
        toView(t) {
          const e = this._toDom(t);
          return this._domConverter.domToView(e);
        }
        _toDom(t) {
          const e = this._domParser.parseFromString(t, "text/html");
          const n = e.createDocumentFragment();
          const o = e.body.childNodes;
          while (o.length > 0) {
            n.appendChild(o[0]);
          }
          return n;
        }
      }
      class Qm {
        constructor(t) {
          this.editor = t;
          this._components = new Map();
        }
        *names() {
          for (const t of this._components.values()) {
            yield t.originalName;
          }
        }
        add(t, e) {
          this._components.set(Xm(t), { callback: e, originalName: t });
        }
        create(t) {
          if (!this.has(t)) {
            throw new ss["a"]("componentfactory-item-missing", this, {
              name: t,
            });
          }
          return this._components.get(Xm(t)).callback(this.editor.locale);
        }
        has(t) {
          return this._components.has(Xm(t));
        }
      }
      function Xm(t) {
        return String(t).toLowerCase();
      }
      class Zm {
        constructor() {
          this.set("isFocused", false);
          this.set("focusedElement", null);
          this._elements = new Set();
          this._nextEventLoopTimeout = null;
        }
        add(t) {
          if (this._elements.has(t)) {
            throw new ss["a"]("focustracker-add-element-already-exist", this);
          }
          this.listenTo(t, "focus", () => this._focus(t), { useCapture: true });
          this.listenTo(t, "blur", () => this._blur(), { useCapture: true });
          this._elements.add(t);
        }
        remove(t) {
          if (t === this.focusedElement) {
            this._blur(t);
          }
          if (this._elements.has(t)) {
            this.stopListening(t);
            this._elements.delete(t);
          }
        }
        destroy() {
          this.stopListening();
        }
        _focus(t) {
          clearTimeout(this._nextEventLoopTimeout);
          this.focusedElement = t;
          this.isFocused = true;
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout);
          this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null;
            this.isFocused = false;
          }, 0);
        }
      }
      Cs(Zm, Yd);
      Cs(Zm, Yc);
      class tk {
        constructor(t) {
          this.editor = t;
          this.componentFactory = new Qm(t);
          this.focusTracker = new Zm();
          this._editableElementsMap = new Map();
          this.listenTo(t.editing.view.document, "layoutChanged", () =>
            this.update()
          );
        }
        get element() {
          return null;
        }
        update() {
          this.fire("update");
        }
        destroy() {
          this.stopListening();
          this.focusTracker.destroy();
          for (const t of this._editableElementsMap.values()) {
            t.ckeditorInstance = null;
          }
          this._editableElementsMap = new Map();
        }
        setEditableElement(t, e) {
          this._editableElementsMap.set(t, e);
          if (!e.ckeditorInstance) {
            e.ckeditorInstance = this.editor;
          }
        }
        getEditableElement(t = "main") {
          return this._editableElementsMap.get(t);
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys();
        }
        get _editableElements() {
          console.warn(
            "editor-ui-deprecated-editable-elements: " +
              "The EditorUI#_editableElements property has been deprecated and will be removed in the near future.",
            { editorUI: this }
          );
          return this._editableElementsMap;
        }
      }
      Cs(tk, ds);
      function ek({
        origin: t,
        originKeystrokeHandler: e,
        originFocusTracker: n,
        toolbar: o,
        beforeFocus: i,
        afterBlur: r,
      }) {
        n.add(o.element);
        e.set("Alt+F10", (t, e) => {
          if (n.isFocused && !o.focusTracker.isFocused) {
            if (i) {
              i();
            }
            o.focus();
            e();
          }
        });
        o.keystrokes.set("Esc", (e, n) => {
          if (o.focusTracker.isFocused) {
            t.focus();
            if (r) {
              r();
            }
            n();
          }
        });
      }
      function nk(t) {
        if (Array.isArray(t)) {
          return { items: t };
        }
        if (!t) {
          return { items: [] };
        }
        return Object.assign({ items: [] }, t);
      }
      var ok = n(1);
      var ik = n.n(ok);
      var rk = n(12);
      var sk = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      sk.insert = "head";
      sk.singleton = true;
      var ak = ik()(rk["a"], sk);
      var ck = rk["a"].locals || {};
      const lk = new WeakMap();
      function dk(t) {
        const { view: e, element: n, text: o, isDirectHost: i = true } = t;
        const r = e.document;
        if (!lk.has(r)) {
          lk.set(r, new Map());
          r.registerPostFixer((t) => pk(r, t));
        }
        lk.get(r).set(n, { text: o, isDirectHost: i });
        e.change((t) => pk(r, t));
      }
      function uk(t, e) {
        const n = e.document;
        t.change((t) => {
          if (!lk.has(n)) {
            return;
          }
          const o = lk.get(n);
          const i = o.get(e);
          t.removeAttribute("data-placeholder", i.hostElement);
          fk(t, i.hostElement);
          o.delete(e);
        });
      }
      function hk(t, e) {
        if (!e.hasClass("ck-placeholder")) {
          t.addClass("ck-placeholder", e);
          return true;
        }
        return false;
      }
      function fk(t, e) {
        if (e.hasClass("ck-placeholder")) {
          t.removeClass("ck-placeholder", e);
          return true;
        }
        return false;
      }
      function gk(t) {
        if (!t.isAttached()) {
          return false;
        }
        const e = !Array.from(t.getChildren()).some((t) => !t.is("uiElement"));
        const n = t.document;
        if (!n.isFocused && e) {
          return true;
        }
        const o = n.selection;
        const i = o.anchor;
        if (e && i && i.parent !== t) {
          return true;
        }
        return false;
      }
      function pk(t, e) {
        const n = lk.get(t);
        let o = false;
        for (const [t, i] of n) {
          if (mk(e, t, i)) {
            o = true;
          }
        }
        return o;
      }
      function mk(t, e, n) {
        const { text: o, isDirectHost: i } = n;
        const r = i ? e : kk(e);
        let s = false;
        if (!r) {
          return false;
        }
        n.hostElement = r;
        if (r.getAttribute("data-placeholder") !== o) {
          t.setAttribute("data-placeholder", o, r);
          s = true;
        }
        if (gk(r)) {
          if (hk(t, r)) {
            s = true;
          }
        } else if (fk(t, r)) {
          s = true;
        }
        return s;
      }
      function kk(t) {
        if (t.childCount === 1) {
          const e = t.getChild(0);
          if (e.is("element") && !e.is("uiElement")) {
            return e;
          }
        }
        return null;
      }
      class bk extends tk {
        constructor(t, e) {
          super(t);
          this.view = e;
          this._toolbarConfig = nk(t.config.get("toolbar"));
        }
        get element() {
          return this.view.editable.element;
        }
        init() {
          const t = this.editor;
          const e = this.view;
          const n = t.editing.view;
          const o = e.editable;
          const i = n.document.getRoot();
          o.name = i.rootName;
          e.render();
          const r = o.element;
          this.setEditableElement(o.name, r);
          this.focusTracker.add(r);
          o.bind("isFocused").to(this.focusTracker);
          n.attachDomRoot(r);
          this._initPlaceholder();
          this._initToolbar();
          this.fire("ready");
        }
        destroy() {
          const t = this.view;
          const e = this.editor.editing.view;
          e.detachDomRoot(t.editable.name);
          t.destroy();
          super.destroy();
        }
        _initToolbar() {
          const t = this.editor;
          const e = this.view;
          const n = e.editable.element;
          const o = t.editing.view;
          const i = e.toolbar;
          e.panel.bind("isVisible").to(this.focusTracker, "isFocused");
          if (this._toolbarConfig.viewportTopOffset) {
            e.viewportTopOffset = this._toolbarConfig.viewportTopOffset;
          }
          e.listenTo(t.ui, "update", () => {
            if (e.panel.isVisible) {
              e.panel.pin({ target: n, positions: e.panelPositions });
            }
          });
          i.fillFromConfig(this._toolbarConfig.items, this.componentFactory);
          ek({
            origin: o,
            originFocusTracker: this.focusTracker,
            originKeystrokeHandler: t.keystrokes,
            toolbar: i,
          });
        }
        _initPlaceholder() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document.getRoot();
          const o = t.sourceElement;
          const i =
            t.config.get("placeholder") ||
            (o &&
              o.tagName.toLowerCase() === "textarea" &&
              o.getAttribute("placeholder"));
          if (i) {
            dk({ view: e, element: n, text: i, isDirectHost: false });
          }
        }
      }
      class wk extends vs {
        constructor(t = []) {
          super(t, { idProperty: "viewUid" });
          this.on("add", (t, e, n) => {
            this._renderViewIntoCollectionParent(e, n);
          });
          this.on("remove", (t, e) => {
            if (e.element && this._parentElement) {
              e.element.remove();
            }
          });
          this._parentElement = null;
        }
        destroy() {
          this.map((t) => t.destroy());
        }
        setParent(t) {
          this._parentElement = t;
          for (const t of this) {
            this._renderViewIntoCollectionParent(t);
          }
        }
        delegate(...t) {
          if (!t.length || !_k(t)) {
            throw new ss["a"]("ui-viewcollection-delegate-wrong-events", this);
          }
          return {
            to: (e) => {
              for (const n of this) {
                for (const o of t) {
                  n.delegate(o).to(e);
                }
              }
              this.on("add", (n, o) => {
                for (const n of t) {
                  o.delegate(n).to(e);
                }
              });
              this.on("remove", (n, o) => {
                for (const n of t) {
                  o.stopDelegating(n, e);
                }
              });
            },
          };
        }
        _renderViewIntoCollectionParent(t, e) {
          if (!t.isRendered) {
            t.render();
          }
          if (t.element && this._parentElement) {
            this._parentElement.insertBefore(
              t.element,
              this._parentElement.children[e]
            );
          }
        }
      }
      function _k(t) {
        return t.every((t) => typeof t == "string");
      }
      const Ak = "http://www.w3.org/1999/xhtml";
      class Ck {
        constructor(t) {
          Object.assign(this, Ok(Ik(t)));
          this._isRendered = false;
          this._revertData = null;
        }
        render() {
          const t = this._renderNode({ intoFragment: true });
          this._isRendered = true;
          return t;
        }
        apply(t) {
          this._revertData = Gk();
          this._renderNode({
            node: t,
            isApplying: true,
            revertData: this._revertData,
          });
          return t;
        }
        revert(t) {
          if (!this._revertData) {
            throw new ss["a"]("ui-template-revert-not-applied", [this, t]);
          }
          this._revertTemplateFromNode(t, this._revertData);
        }
        *getViews() {
          function* t(e) {
            if (e.children) {
              for (const n of e.children) {
                if (qk(n)) {
                  yield n;
                } else if ($k(n)) {
                  yield* t(n);
                }
              }
            }
          }
          yield* t(this);
        }
        static bind(t, e) {
          return {
            to(n, o) {
              return new yk({
                eventNameOrFunction: n,
                attribute: n,
                observable: t,
                emitter: e,
                callback: o,
              });
            },
            if(n, o, i) {
              return new xk({
                observable: t,
                emitter: e,
                attribute: n,
                valueIfTrue: o,
                callback: i,
              });
            },
          };
        }
        static extend(t, e) {
          if (t._isRendered) {
            throw new ss["a"]("template-extend-render", [this, t]);
          }
          jk(t, Ok(Ik(e)));
        }
        _renderNode(t) {
          let e;
          if (t.node) {
            e = this.tag && this.text;
          } else {
            e = this.tag ? this.text : !this.text;
          }
          if (e) {
            throw new ss["a"]("ui-template-wrong-syntax", this);
          }
          if (this.text) {
            return this._renderText(t);
          } else {
            return this._renderElement(t);
          }
        }
        _renderElement(t) {
          let e = t.node;
          if (!e) {
            e = t.node = document.createElementNS(this.ns || Ak, this.tag);
          }
          this._renderAttributes(t);
          this._renderElementChildren(t);
          this._setUpListeners(t);
          return e;
        }
        _renderText(t) {
          let e = t.node;
          if (e) {
            t.revertData.text = e.textContent;
          } else {
            e = t.node = document.createTextNode("");
          }
          if (Ek(this.text)) {
            this._bindToObservable({
              schema: this.text,
              updater: Dk(e),
              data: t,
            });
          } else {
            e.textContent = this.text.join("");
          }
          return e;
        }
        _renderAttributes(t) {
          let e, n, o, i;
          if (!this.attributes) {
            return;
          }
          const r = t.node;
          const s = t.revertData;
          for (e in this.attributes) {
            o = r.getAttribute(e);
            n = this.attributes[e];
            if (s) {
              s.attributes[e] = o;
            }
            i = ct(n[0]) && n[0].ns ? n[0].ns : null;
            if (Ek(n)) {
              const a = i ? n[0].value : n;
              if (s && Uk(e)) {
                a.unshift(o);
              }
              this._bindToObservable({
                schema: a,
                updater: Tk(r, e, i),
                data: t,
              });
            } else if (e == "style" && typeof n[0] !== "string") {
              this._renderStyleAttribute(n[0], t);
            } else {
              if (s && o && Uk(e)) {
                n.unshift(o);
              }
              n = n
                .map((t) => (t ? t.value || t : t))
                .reduce((t, e) => t.concat(e), [])
                .reduce(Lk, "");
              if (!Kk(n)) {
                r.setAttributeNS(i, e, n);
              }
            }
          }
        }
        _renderStyleAttribute(t, e) {
          const n = e.node;
          for (const o in t) {
            const i = t[o];
            if (Ek(i)) {
              this._bindToObservable({
                schema: [i],
                updater: Bk(n, o),
                data: e,
              });
            } else {
              n.style[o] = i;
            }
          }
        }
        _renderElementChildren(t) {
          const e = t.node;
          const n = t.intoFragment ? document.createDocumentFragment() : e;
          const o = t.isApplying;
          let i = 0;
          for (const r of this.children) {
            if (Wk(r)) {
              if (!o) {
                r.setParent(e);
                for (const t of r) {
                  n.appendChild(t.element);
                }
              }
            } else if (qk(r)) {
              if (!o) {
                if (!r.isRendered) {
                  r.render();
                }
                n.appendChild(r.element);
              }
            } else if (Dd(r)) {
              n.appendChild(r);
            } else {
              if (o) {
                const e = t.revertData;
                const o = Gk();
                e.children.push(o);
                r._renderNode({
                  node: n.childNodes[i++],
                  isApplying: true,
                  revertData: o,
                });
              } else {
                n.appendChild(r.render());
              }
            }
          }
          if (t.intoFragment) {
            e.appendChild(n);
          }
        }
        _setUpListeners(t) {
          if (!this.eventListeners) {
            return;
          }
          for (const e in this.eventListeners) {
            const n = this.eventListeners[e].map((n) => {
              const [o, i] = e.split("@");
              return n.activateDomEventListener(o, i, t);
            });
            if (t.revertData) {
              t.revertData.bindings.push(n);
            }
          }
        }
        _bindToObservable({ schema: t, updater: e, data: n }) {
          const o = n.revertData;
          Pk(t, e, n);
          const i = t
            .filter((t) => !Kk(t))
            .filter((t) => t.observable)
            .map((o) => o.activateAttributeListener(t, e, n));
          if (o) {
            o.bindings.push(i);
          }
        }
        _revertTemplateFromNode(t, e) {
          for (const t of e.bindings) {
            for (const e of t) {
              e();
            }
          }
          if (e.text) {
            t.textContent = e.text;
            return;
          }
          for (const n in e.attributes) {
            const o = e.attributes[n];
            if (o === null) {
              t.removeAttribute(n);
            } else {
              t.setAttribute(n, o);
            }
          }
          for (let n = 0; n < e.children.length; ++n) {
            this._revertTemplateFromNode(t.childNodes[n], e.children[n]);
          }
        }
      }
      Cs(Ck, ds);
      class vk {
        constructor(t) {
          Object.assign(this, t);
        }
        getValue(t) {
          const e = this.observable[this.attribute];
          return this.callback ? this.callback(e, t) : e;
        }
        activateAttributeListener(t, e, n) {
          const o = () => Pk(t, e, n);
          this.emitter.listenTo(this.observable, "change:" + this.attribute, o);
          return () => {
            this.emitter.stopListening(
              this.observable,
              "change:" + this.attribute,
              o
            );
          };
        }
      }
      class yk extends vk {
        activateDomEventListener(t, e, n) {
          const o = (t, n) => {
            if (!e || n.target.matches(e)) {
              if (typeof this.eventNameOrFunction == "function") {
                this.eventNameOrFunction(n);
              } else {
                this.observable.fire(this.eventNameOrFunction, n);
              }
            }
          };
          this.emitter.listenTo(n.node, t, o);
          return () => {
            this.emitter.stopListening(n.node, t, o);
          };
        }
      }
      class xk extends vk {
        getValue(t) {
          const e = super.getValue(t);
          return Kk(e) ? false : this.valueIfTrue || true;
        }
      }
      function Ek(t) {
        if (!t) {
          return false;
        }
        if (t.value) {
          t = t.value;
        }
        if (Array.isArray(t)) {
          return t.some(Ek);
        } else if (t instanceof vk) {
          return true;
        }
        return false;
      }
      function Sk(t, e) {
        return t.map((t) => {
          if (t instanceof vk) {
            return t.getValue(e);
          }
          return t;
        });
      }
      function Pk(t, e, { node: n }) {
        let o = Sk(t, n);
        if (t.length == 1 && t[0] instanceof xk) {
          o = o[0];
        } else {
          o = o.reduce(Lk, "");
        }
        if (Kk(o)) {
          e.remove();
        } else {
          e.set(o);
        }
      }
      function Dk(t) {
        return {
          set(e) {
            t.textContent = e;
          },
          remove() {
            t.textContent = "";
          },
        };
      }
      function Tk(t, e, n) {
        return {
          set(o) {
            t.setAttributeNS(n, e, o);
          },
          remove() {
            t.removeAttributeNS(n, e);
          },
        };
      }
      function Bk(t, e) {
        return {
          set(n) {
            t.style[e] = n;
          },
          remove() {
            t.style[e] = null;
          },
        };
      }
      function Ik(t) {
        const e = Gr(t, (t) => {
          if (t && (t instanceof vk || $k(t) || qk(t) || Wk(t))) {
            return t;
          }
        });
        return e;
      }
      function Ok(t) {
        if (typeof t == "string") {
          t = Nk(t);
        } else if (t.text) {
          Mk(t);
        }
        if (t.on) {
          t.eventListeners = Fk(t.on);
          delete t.on;
        }
        if (!t.text) {
          if (t.attributes) {
            Rk(t.attributes);
          }
          const e = [];
          if (t.children) {
            if (Wk(t.children)) {
              e.push(t.children);
            } else {
              for (const n of t.children) {
                if ($k(n) || qk(n) || Dd(n)) {
                  e.push(n);
                } else {
                  e.push(new Ck(n));
                }
              }
            }
          }
          t.children = e;
        }
        return t;
      }
      function Rk(t) {
        for (const e in t) {
          if (t[e].value) {
            t[e].value = [].concat(t[e].value);
          }
          Vk(t, e);
        }
      }
      function Fk(t) {
        for (const e in t) {
          Vk(t, e);
        }
        return t;
      }
      function Nk(t) {
        return { text: [t] };
      }
      function Mk(t) {
        if (!Array.isArray(t.text)) {
          t.text = [t.text];
        }
      }
      function Vk(t, e) {
        if (!Array.isArray(t[e])) {
          t[e] = [t[e]];
        }
      }
      function Lk(t, e) {
        if (Kk(e)) {
          return t;
        } else if (Kk(t)) {
          return e;
        } else {
          return `${t} ${e}`;
        }
      }
      function zk(t, e) {
        for (const n in e) {
          if (t[n]) {
            t[n].push(...e[n]);
          } else {
            t[n] = e[n];
          }
        }
      }
      function jk(t, e) {
        if (e.attributes) {
          if (!t.attributes) {
            t.attributes = {};
          }
          zk(t.attributes, e.attributes);
        }
        if (e.eventListeners) {
          if (!t.eventListeners) {
            t.eventListeners = {};
          }
          zk(t.eventListeners, e.eventListeners);
        }
        if (e.text) {
          t.text.push(...e.text);
        }
        if (e.children && e.children.length) {
          if (t.children.length != e.children.length) {
            throw new ss["a"]("ui-template-extend-children-mismatch", t);
          }
          let n = 0;
          for (const o of e.children) {
            jk(t.children[n++], o);
          }
        }
      }
      function Kk(t) {
        return !t && t !== 0;
      }
      function qk(t) {
        return t instanceof Xk;
      }
      function $k(t) {
        return t instanceof Ck;
      }
      function Wk(t) {
        return t instanceof wk;
      }
      function Gk() {
        return { children: [], bindings: [], attributes: {} };
      }
      function Uk(t) {
        return t == "class" || t == "style";
      }
      var Hk = n(13);
      var Jk = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Jk.insert = "head";
      Jk.singleton = true;
      var Yk = ik()(Hk["a"], Jk);
      var Qk = Hk["a"].locals || {};
      class Xk {
        constructor(t) {
          this.element = null;
          this.isRendered = false;
          this.locale = t;
          this.t = t && t.t;
          this._viewCollections = new vs();
          this._unboundChildren = this.createCollection();
          this._viewCollections.on("add", (e, n) => {
            n.locale = t;
          });
          this.decorate("render");
        }
        get bindTemplate() {
          if (this._bindTemplate) {
            return this._bindTemplate;
          }
          return (this._bindTemplate = Ck.bind(this, this));
        }
        createCollection(t) {
          const e = new wk(t);
          this._viewCollections.add(e);
          return e;
        }
        registerChild(t) {
          if (!As(t)) {
            t = [t];
          }
          for (const e of t) {
            this._unboundChildren.add(e);
          }
        }
        deregisterChild(t) {
          if (!As(t)) {
            t = [t];
          }
          for (const e of t) {
            this._unboundChildren.remove(e);
          }
        }
        setTemplate(t) {
          this.template = new Ck(t);
        }
        extendTemplate(t) {
          Ck.extend(this.template, t);
        }
        render() {
          if (this.isRendered) {
            throw new ss["a"]("ui-view-render-already-rendered", this);
          }
          if (this.template) {
            this.element = this.template.render();
            this.registerChild(this.template.getViews());
          }
          this.isRendered = true;
        }
        destroy() {
          this.stopListening();
          this._viewCollections.map((t) => t.destroy());
          if (this.template && this.template._revertData) {
            this.template.revert(this.element);
          }
        }
      }
      Cs(Xk, Yd);
      Cs(Xk, Yc);
      var Zk = "[object String]";
      function tb(t) {
        return typeof t == "string" || (!Je(t) && E(t) && _(t) == Zk);
      }
      var eb = tb;
      function nb(t, e, n = {}, o = []) {
        const i = n && n.xmlns;
        const r = i ? t.createElementNS(i, e) : t.createElement(e);
        for (const t in n) {
          r.setAttribute(t, n[t]);
        }
        if (eb(o) || !As(o)) {
          o = [o];
        }
        for (let e of o) {
          if (eb(e)) {
            e = t.createTextNode(e);
          }
          r.appendChild(e);
        }
        return r;
      }
      class ob extends wk {
        constructor(t, e = []) {
          super(e);
          this.locale = t;
        }
        attachToDom() {
          this._bodyCollectionContainer = new Ck({
            tag: "div",
            attributes: {
              class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"],
              dir: this.locale.uiLanguageDirection,
            },
            children: this,
          }).render();
          let t = document.querySelector(".ck-body-wrapper");
          if (!t) {
            t = nb(document, "div", { class: "ck-body-wrapper" });
            document.body.appendChild(t);
          }
          t.appendChild(this._bodyCollectionContainer);
        }
        detachFromDom() {
          super.destroy();
          if (this._bodyCollectionContainer) {
            this._bodyCollectionContainer.remove();
          }
          const t = document.querySelector(".ck-body-wrapper");
          if (t && t.childElementCount == 0) {
            t.remove();
          }
        }
      }
      var ib = n(14);
      var rb = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      rb.insert = "head";
      rb.singleton = true;
      var sb = ik()(ib["a"], rb);
      var ab = ib["a"].locals || {};
      class cb extends Xk {
        constructor(t) {
          super(t);
          this.body = new ob(t);
        }
        render() {
          super.render();
          this.body.attachToDom();
        }
        destroy() {
          this.body.detachFromDom();
          return super.destroy();
        }
      }
      class lb extends Xk {
        constructor(t, e, n) {
          super(t);
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-content",
                "ck-editor__editable",
                "ck-rounded-corners",
              ],
              lang: t.contentLanguage,
              dir: t.contentLanguageDirection,
            },
          });
          this.name = null;
          this.set("isFocused", false);
          this._editableElement = n;
          this._hasExternalElement = !!this._editableElement;
          this._editingView = e;
        }
        render() {
          super.render();
          if (this._hasExternalElement) {
            this.template.apply((this.element = this._editableElement));
          } else {
            this._editableElement = this.element;
          }
          this.on("change:isFocused", () => this._updateIsFocusedClasses());
          this._updateIsFocusedClasses();
        }
        destroy() {
          if (this._hasExternalElement) {
            this.template.revert(this._editableElement);
          }
          super.destroy();
        }
        _updateIsFocusedClasses() {
          const t = this._editingView;
          if (t.isRenderingInProgress) {
            n(this);
          } else {
            e(this);
          }
          function e(e) {
            t.change((n) => {
              const o = t.document.getRoot(e.name);
              n.addClass(e.isFocused ? "ck-focused" : "ck-blurred", o);
              n.removeClass(e.isFocused ? "ck-blurred" : "ck-focused", o);
            });
          }
          function n(o) {
            t.once("change:isRenderingInProgress", (t, i, r) => {
              if (!r) {
                e(o);
              } else {
                n(o);
              }
            });
          }
        }
      }
      class db extends lb {
        constructor(t, e, n) {
          super(t, e, n);
          this.extendTemplate({
            attributes: {
              role: "textbox",
              class: "ck-editor__editable_inline",
            },
          });
        }
        render() {
          super.render();
          const t = this._editingView;
          const e = this.t;
          t.change((n) => {
            const o = t.document.getRoot(this.name);
            n.setAttribute(
              "aria-label",
              e("Rich Text Editor, %0", this.name),
              o
            );
          });
        }
      }
      function ub(t) {
        if (!t || !t.parentNode) {
          return null;
        }
        if (t.offsetParent === Vd.document.body) {
          return null;
        }
        return t.offsetParent;
      }
      function hb({
        element: t,
        target: e,
        positions: n,
        limiter: o,
        fitInViewport: i,
      }) {
        if (gt(e)) {
          e = e();
        }
        if (gt(o)) {
          o = o();
        }
        const r = ub(t);
        const s = new Eh(t);
        const a = new Eh(e);
        let c;
        let l;
        if (!o && !i) {
          [l, c] = fb(n[0], a, s);
        } else {
          const t = o && new Eh(o).getVisible();
          const e = i && new Eh(Vd.window);
          const r = gb(n, {
            targetRect: a,
            elementRect: s,
            limiterRect: t,
            viewportRect: e,
          });
          [l, c] = r || fb(n[0], a, s);
        }
        let d = bb(c);
        if (r) {
          d = kb(d, r);
        }
        return { left: d.left, top: d.top, name: l };
      }
      function fb(t, e, n) {
        const o = t(e, n);
        if (!o) {
          return null;
        }
        const { left: i, top: r, name: s } = o;
        return [s, n.clone().moveTo(i, r)];
      }
      function gb(t, e) {
        const { elementRect: n, viewportRect: o } = e;
        const i = n.getArea();
        const r = pb(t, e);
        if (o) {
          const t = r.filter(({ viewportIntersectArea: t }) => t === i);
          const e = mb(t, i);
          if (e) {
            return e;
          }
        }
        return mb(r, i);
      }
      function pb(
        t,
        { targetRect: e, elementRect: n, limiterRect: o, viewportRect: i }
      ) {
        const r = [];
        const s = n.getArea();
        for (const a of t) {
          const t = fb(a, e, n);
          if (!t) {
            continue;
          }
          const [c, l] = t;
          let d = 0;
          let u = 0;
          if (o) {
            if (i) {
              const t = o.getIntersection(i);
              if (t) {
                d = t.getIntersectionArea(l);
              }
            } else {
              d = o.getIntersectionArea(l);
            }
          }
          if (i) {
            u = i.getIntersectionArea(l);
          }
          const h = {
            positionName: c,
            positionRect: l,
            limiterIntersectArea: d,
            viewportIntersectArea: u,
          };
          if (d === s) {
            return [h];
          }
          r.push(h);
        }
        return r;
      }
      function mb(t, e) {
        let n = 0;
        let o;
        let i;
        for (const {
          positionName: r,
          positionRect: s,
          limiterIntersectArea: a,
          viewportIntersectArea: c,
        } of t) {
          if (a === e) {
            return [r, s];
          }
          const t = c ** 2 + a ** 2;
          if (t > n) {
            n = t;
            o = s;
            i = r;
          }
        }
        return o ? [i, o] : null;
      }
      function kb({ left: t, top: e }, n) {
        const o = bb(new Eh(n));
        const i = yh(n);
        t -= o.left;
        e -= o.top;
        t += n.scrollLeft;
        e += n.scrollTop;
        t -= i.left;
        e -= i.top;
        return { left: t, top: e };
      }
      function bb({ left: t, top: e }) {
        const { scrollX: n, scrollY: o } = Vd.window;
        return { left: t + n, top: e + o };
      }
      function wb(t) {
        return (e) => e + t;
      }
      var _b = n(15);
      var Ab = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Ab.insert = "head";
      Ab.singleton = true;
      var Cb = ik()(_b["a"], Ab);
      var vb = _b["a"].locals || {};
      const yb = wb("px");
      const xb = Vd.document.body;
      class Eb extends Xk {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("top", 0);
          this.set("left", 0);
          this.set("position", "arrow_nw");
          this.set("isVisible", false);
          this.set("withArrow", true);
          this.set("class");
          this.content = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-balloon-panel",
                e.to("position", (t) => `ck-balloon-panel_${t}`),
                e.if("isVisible", "ck-balloon-panel_visible"),
                e.if("withArrow", "ck-balloon-panel_with-arrow"),
                e.to("class"),
              ],
              style: { top: e.to("top", yb), left: e.to("left", yb) },
            },
            children: this.content,
          });
        }
        show() {
          this.isVisible = true;
        }
        hide() {
          this.isVisible = false;
        }
        attachTo(t) {
          this.show();
          const e = Eb.defaultPositions;
          const n = Object.assign(
            {},
            {
              element: this.element,
              positions: [
                e.southArrowNorth,
                e.southArrowNorthMiddleWest,
                e.southArrowNorthMiddleEast,
                e.southArrowNorthWest,
                e.southArrowNorthEast,
                e.northArrowSouth,
                e.northArrowSouthMiddleWest,
                e.northArrowSouthMiddleEast,
                e.northArrowSouthWest,
                e.northArrowSouthEast,
              ],
              limiter: xb,
              fitInViewport: true,
            },
            t
          );
          const o = Eb._getOptimalPosition(n);
          const i = parseInt(o.left);
          const r = parseInt(o.top);
          const s = o.name;
          Object.assign(this, { top: r, left: i, position: s });
        }
        pin(t) {
          this.unpin();
          this._pinWhenIsVisibleCallback = () => {
            if (this.isVisible) {
              this._startPinning(t);
            } else {
              this._stopPinning();
            }
          };
          this._startPinning(t);
          this.listenTo(
            this,
            "change:isVisible",
            this._pinWhenIsVisibleCallback
          );
        }
        unpin() {
          if (this._pinWhenIsVisibleCallback) {
            this._stopPinning();
            this.stopListening(
              this,
              "change:isVisible",
              this._pinWhenIsVisibleCallback
            );
            this._pinWhenIsVisibleCallback = null;
            this.hide();
          }
        }
        _startPinning(t) {
          this.attachTo(t);
          const e = Sb(t.target);
          const n = t.limiter ? Sb(t.limiter) : xb;
          this.listenTo(
            Vd.document,
            "scroll",
            (o, i) => {
              const r = i.target;
              const s = e && r.contains(e);
              const a = n && r.contains(n);
              if (s || a || !e || !n) {
                this.attachTo(t);
              }
            },
            { useCapture: true }
          );
          this.listenTo(Vd.window, "resize", () => {
            this.attachTo(t);
          });
        }
        _stopPinning() {
          this.stopListening(Vd.document, "scroll");
          this.stopListening(Vd.window, "resize");
        }
      }
      function Sb(t) {
        if (Hr(t)) {
          return t;
        }
        if (vh(t)) {
          return t.commonAncestorContainer;
        }
        if (typeof t == "function") {
          return Sb(t());
        }
        return null;
      }
      Eb.arrowHorizontalOffset = 25;
      Eb.arrowVerticalOffset = 10;
      Eb._getOptimalPosition = hb;
      Eb.defaultPositions = {
        northWestArrowSouthWest: (t, e) => ({
          top: Pb(t, e),
          left: t.left - Eb.arrowHorizontalOffset,
          name: "arrow_sw",
        }),
        northWestArrowSouthMiddleWest: (t, e) => ({
          top: Pb(t, e),
          left: t.left - e.width * 0.25 - Eb.arrowHorizontalOffset,
          name: "arrow_smw",
        }),
        northWestArrowSouth: (t, e) => ({
          top: Pb(t, e),
          left: t.left - e.width / 2,
          name: "arrow_s",
        }),
        northWestArrowSouthMiddleEast: (t, e) => ({
          top: Pb(t, e),
          left: t.left - e.width * 0.75 + Eb.arrowHorizontalOffset,
          name: "arrow_sme",
        }),
        northWestArrowSouthEast: (t, e) => ({
          top: Pb(t, e),
          left: t.left - e.width + Eb.arrowHorizontalOffset,
          name: "arrow_se",
        }),
        northArrowSouthWest: (t, e) => ({
          top: Pb(t, e),
          left: t.left + t.width / 2 - Eb.arrowHorizontalOffset,
          name: "arrow_sw",
        }),
        northArrowSouthMiddleWest: (t, e) => ({
          top: Pb(t, e),
          left:
            t.left + t.width / 2 - e.width * 0.25 - Eb.arrowHorizontalOffset,
          name: "arrow_smw",
        }),
        northArrowSouth: (t, e) => ({
          top: Pb(t, e),
          left: t.left + t.width / 2 - e.width / 2,
          name: "arrow_s",
        }),
        northArrowSouthMiddleEast: (t, e) => ({
          top: Pb(t, e),
          left:
            t.left + t.width / 2 - e.width * 0.75 + Eb.arrowHorizontalOffset,
          name: "arrow_sme",
        }),
        northArrowSouthEast: (t, e) => ({
          top: Pb(t, e),
          left: t.left + t.width / 2 - e.width + Eb.arrowHorizontalOffset,
          name: "arrow_se",
        }),
        northEastArrowSouthWest: (t, e) => ({
          top: Pb(t, e),
          left: t.right - Eb.arrowHorizontalOffset,
          name: "arrow_sw",
        }),
        northEastArrowSouthMiddleWest: (t, e) => ({
          top: Pb(t, e),
          left: t.right - e.width * 0.25 - Eb.arrowHorizontalOffset,
          name: "arrow_smw",
        }),
        northEastArrowSouth: (t, e) => ({
          top: Pb(t, e),
          left: t.right - e.width / 2,
          name: "arrow_s",
        }),
        northEastArrowSouthMiddleEast: (t, e) => ({
          top: Pb(t, e),
          left: t.right - e.width * 0.75 + Eb.arrowHorizontalOffset,
          name: "arrow_sme",
        }),
        northEastArrowSouthEast: (t, e) => ({
          top: Pb(t, e),
          left: t.right - e.width + Eb.arrowHorizontalOffset,
          name: "arrow_se",
        }),
        southWestArrowNorthWest: (t, e) => ({
          top: Db(t, e),
          left: t.left - Eb.arrowHorizontalOffset,
          name: "arrow_nw",
        }),
        southWestArrowNorthMiddleWest: (t, e) => ({
          top: Db(t, e),
          left: t.left - e.width * 0.25 - Eb.arrowHorizontalOffset,
          name: "arrow_nmw",
        }),
        southWestArrowNorth: (t, e) => ({
          top: Db(t, e),
          left: t.left - e.width / 2,
          name: "arrow_n",
        }),
        southWestArrowNorthMiddleEast: (t, e) => ({
          top: Db(t, e),
          left: t.left - e.width * 0.75 + Eb.arrowHorizontalOffset,
          name: "arrow_nme",
        }),
        southWestArrowNorthEast: (t, e) => ({
          top: Db(t, e),
          left: t.left - e.width + Eb.arrowHorizontalOffset,
          name: "arrow_ne",
        }),
        southArrowNorthWest: (t, e) => ({
          top: Db(t, e),
          left: t.left + t.width / 2 - Eb.arrowHorizontalOffset,
          name: "arrow_nw",
        }),
        southArrowNorthMiddleWest: (t, e) => ({
          top: Db(t, e),
          left:
            t.left + t.width / 2 - e.width * 0.25 - Eb.arrowHorizontalOffset,
          name: "arrow_nmw",
        }),
        southArrowNorth: (t, e) => ({
          top: Db(t, e),
          left: t.left + t.width / 2 - e.width / 2,
          name: "arrow_n",
        }),
        southArrowNorthMiddleEast: (t, e) => ({
          top: Db(t, e),
          left:
            t.left + t.width / 2 - e.width * 0.75 + Eb.arrowHorizontalOffset,
          name: "arrow_nme",
        }),
        southArrowNorthEast: (t, e) => ({
          top: Db(t, e),
          left: t.left + t.width / 2 - e.width + Eb.arrowHorizontalOffset,
          name: "arrow_ne",
        }),
        southEastArrowNorthWest: (t, e) => ({
          top: Db(t, e),
          left: t.right - Eb.arrowHorizontalOffset,
          name: "arrow_nw",
        }),
        southEastArrowNorthMiddleWest: (t, e) => ({
          top: Db(t, e),
          left: t.right - e.width * 0.25 - Eb.arrowHorizontalOffset,
          name: "arrow_nmw",
        }),
        southEastArrowNorth: (t, e) => ({
          top: Db(t, e),
          left: t.right - e.width / 2,
          name: "arrow_n",
        }),
        southEastArrowNorthMiddleEast: (t, e) => ({
          top: Db(t, e),
          left: t.right - e.width * 0.75 + Eb.arrowHorizontalOffset,
          name: "arrow_nme",
        }),
        southEastArrowNorthEast: (t, e) => ({
          top: Db(t, e),
          left: t.right - e.width + Eb.arrowHorizontalOffset,
          name: "arrow_ne",
        }),
      };
      function Pb(t, e) {
        return t.top - e.height - Eb.arrowVerticalOffset;
      }
      function Db(t) {
        return t.bottom + Eb.arrowVerticalOffset;
      }
      class Tb {
        constructor(t) {
          Object.assign(this, t);
          if (t.actions && t.keystrokeHandler) {
            for (const e in t.actions) {
              let n = t.actions[e];
              if (typeof n == "string") {
                n = [n];
              }
              for (const o of n) {
                t.keystrokeHandler.set(o, (t, n) => {
                  this[e]();
                  n();
                });
              }
            }
          }
        }
        get first() {
          return this.focusables.find(Bb) || null;
        }
        get last() {
          return this.focusables.filter(Bb).slice(-1)[0] || null;
        }
        get next() {
          return this._getFocusableItem(1);
        }
        get previous() {
          return this._getFocusableItem(-1);
        }
        get current() {
          let t = null;
          if (this.focusTracker.focusedElement === null) {
            return null;
          }
          this.focusables.find((e, n) => {
            const o = e.element === this.focusTracker.focusedElement;
            if (o) {
              t = n;
            }
            return o;
          });
          return t;
        }
        focusFirst() {
          this._focus(this.first);
        }
        focusLast() {
          this._focus(this.last);
        }
        focusNext() {
          this._focus(this.next);
        }
        focusPrevious() {
          this._focus(this.previous);
        }
        _focus(t) {
          if (t) {
            t.focus();
          }
        }
        _getFocusableItem(t) {
          const e = this.current;
          const n = this.focusables.length;
          if (!n) {
            return null;
          }
          if (e === null) {
            return this[t === 1 ? "first" : "last"];
          }
          let o = (e + n + t) % n;
          do {
            const e = this.focusables.get(o);
            if (Bb(e)) {
              return e;
            }
            o = (o + n + t) % n;
          } while (o !== e);
          return null;
        }
      }
      function Bb(t) {
        return !!(
          t.focus && Vd.window.getComputedStyle(t.element).display != "none"
        );
      }
      class Ib extends Xk {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-toolbar__separator"] },
          });
        }
      }
      const Ob = 100;
      class Rb {
        constructor(t, e) {
          if (!Rb._observerInstance) {
            Rb._createObserver();
          }
          this._element = t;
          this._callback = e;
          Rb._addElementCallback(t, e);
          Rb._observerInstance.observe(t);
        }
        destroy() {
          Rb._deleteElementCallback(this._element, this._callback);
        }
        static _addElementCallback(t, e) {
          if (!Rb._elementCallbacks) {
            Rb._elementCallbacks = new Map();
          }
          let n = Rb._elementCallbacks.get(t);
          if (!n) {
            n = new Set();
            Rb._elementCallbacks.set(t, n);
          }
          n.add(e);
        }
        static _deleteElementCallback(t, e) {
          const n = Rb._getElementCallbacks(t);
          if (n) {
            n.delete(e);
            if (!n.size) {
              Rb._elementCallbacks.delete(t);
              Rb._observerInstance.unobserve(t);
            }
          }
          if (Rb._elementCallbacks && !Rb._elementCallbacks.size) {
            Rb._observerInstance = null;
            Rb._elementCallbacks = null;
          }
        }
        static _getElementCallbacks(t) {
          if (!Rb._elementCallbacks) {
            return null;
          }
          return Rb._elementCallbacks.get(t);
        }
        static _createObserver() {
          let t;
          if (typeof Vd.window.ResizeObserver === "function") {
            t = Vd.window.ResizeObserver;
          } else {
            t = Fb;
          }
          Rb._observerInstance = new t((t) => {
            for (const e of t) {
              const t = Rb._getElementCallbacks(e.target);
              if (t) {
                for (const n of t) {
                  n(e);
                }
              }
            }
          });
        }
      }
      Rb._observerInstance = null;
      Rb._elementCallbacks = null;
      class Fb {
        constructor(t) {
          this._callback = t;
          this._elements = new Set();
          this._previousRects = new Map();
          this._periodicCheckTimeout = null;
        }
        observe(t) {
          this._elements.add(t);
          this._checkElementRectsAndExecuteCallback();
          if (this._elements.size === 1) {
            this._startPeriodicCheck();
          }
        }
        unobserve(t) {
          this._elements.delete(t);
          this._previousRects.delete(t);
          if (!this._elements.size) {
            this._stopPeriodicCheck();
          }
        }
        _startPeriodicCheck() {
          const t = () => {
            this._checkElementRectsAndExecuteCallback();
            this._periodicCheckTimeout = setTimeout(t, Ob);
          };
          this.listenTo(Vd.window, "resize", () => {
            this._checkElementRectsAndExecuteCallback();
          });
          this._periodicCheckTimeout = setTimeout(t, Ob);
        }
        _stopPeriodicCheck() {
          clearTimeout(this._periodicCheckTimeout);
          this.stopListening();
          this._previousRects.clear();
        }
        _checkElementRectsAndExecuteCallback() {
          const t = [];
          for (const e of this._elements) {
            if (this._hasRectChanged(e)) {
              t.push({ target: e, contentRect: this._previousRects.get(e) });
            }
          }
          if (t.length) {
            this._callback(t);
          }
        }
        _hasRectChanged(t) {
          if (!t.ownerDocument.body.contains(t)) {
            return false;
          }
          const e = new Eh(t);
          const n = this._previousRects.get(t);
          const o = !n || !n.isEqual(e);
          this._previousRects.set(t, e);
          return o;
        }
      }
      Cs(Fb, Yd);
      function Nb(t) {
        return t.bindTemplate.to((e) => {
          if (e.target === t.element) {
            e.preventDefault();
          }
        });
      }
      class Mb extends Xk {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          this.set("isVisible", false);
          this.set("position", "se");
          this.children = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-reset",
                "ck-dropdown__panel",
                e.to("position", (t) => `ck-dropdown__panel_${t}`),
                e.if("isVisible", "ck-dropdown__panel-visible"),
              ],
            },
            children: this.children,
            on: { selectstart: e.to((t) => t.preventDefault()) },
          });
        }
        focus() {
          if (this.children.length) {
            this.children.first.focus();
          }
        }
        focusLast() {
          if (this.children.length) {
            const t = this.children.last;
            if (typeof t.focusLast === "function") {
              t.focusLast();
            } else {
              t.focus();
            }
          }
        }
      }
      var Vb = n(16);
      var Lb = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Lb.insert = "head";
      Lb.singleton = true;
      var zb = ik()(Vb["a"], Lb);
      var jb = Vb["a"].locals || {};
      class Kb extends Xk {
        constructor(t, e, n) {
          super(t);
          const o = this.bindTemplate;
          this.buttonView = e;
          this.panelView = n;
          this.set("isOpen", false);
          this.set("isEnabled", true);
          this.set("class");
          this.set("id");
          this.set("panelPosition", "auto");
          this.keystrokes = new zm();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-dropdown",
                o.to("class"),
                o.if("isEnabled", "ck-disabled", (t) => !t),
              ],
              id: o.to("id"),
              "aria-describedby": o.to("ariaDescribedById"),
            },
            children: [e, n],
          });
          e.extendTemplate({ attributes: { class: ["ck-dropdown__button"] } });
        }
        render() {
          super.render();
          this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen;
          });
          this.panelView.bind("isVisible").to(this, "isOpen");
          this.on("change:isOpen", () => {
            if (!this.isOpen) {
              return;
            }
            if (this.panelPosition === "auto") {
              this.panelView.position = Kb._getOptimalPosition({
                element: this.panelView.element,
                target: this.buttonView.element,
                fitInViewport: true,
                positions: this._panelPositions,
              }).name;
            } else {
              this.panelView.position = this.panelPosition;
            }
          });
          this.keystrokes.listenTo(this.element);
          const t = (t, e) => {
            if (this.isOpen) {
              this.buttonView.focus();
              this.isOpen = false;
              e();
            }
          };
          this.keystrokes.set("arrowdown", (t, e) => {
            if (this.buttonView.isEnabled && !this.isOpen) {
              this.isOpen = true;
              e();
            }
          });
          this.keystrokes.set("arrowright", (t, e) => {
            if (this.isOpen) {
              e();
            }
          });
          this.keystrokes.set("arrowleft", t);
          this.keystrokes.set("esc", t);
        }
        focus() {
          this.buttonView.focus();
        }
        get _panelPositions() {
          const {
            southEast: t,
            southWest: e,
            northEast: n,
            northWest: o,
          } = Kb.defaultPanelPositions;
          if (this.locale.uiLanguageDirection === "ltr") {
            return [t, e, n, o];
          } else {
            return [e, t, o, n];
          }
        }
      }
      Kb.defaultPanelPositions = {
        southEast: (t) => ({ top: t.bottom, left: t.left, name: "se" }),
        southWest: (t, e) => ({
          top: t.bottom,
          left: t.left - e.width + t.width,
          name: "sw",
        }),
        northEast: (t, e) => ({
          top: t.top - e.height,
          left: t.left,
          name: "ne",
        }),
        northWest: (t, e) => ({
          top: t.bottom - e.height,
          left: t.left - e.width + t.width,
          name: "nw",
        }),
      };
      Kb._getOptimalPosition = hb;
      var qb = n(17);
      var $b = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      $b.insert = "head";
      $b.singleton = true;
      var Wb = ik()(qb["a"], $b);
      var Gb = qb["a"].locals || {};
      class Ub extends Xk {
        constructor() {
          super();
          const t = this.bindTemplate;
          this.set("content", "");
          this.set("viewBox", "0 0 20 20");
          this.set("fillColor", "");
          this.setTemplate({
            tag: "svg",
            ns: "http://www.w3.org/2000/svg",
            attributes: { class: ["ck", "ck-icon"], viewBox: t.to("viewBox") },
          });
        }
        render() {
          super.render();
          this._updateXMLContent();
          this._colorFillPaths();
          this.on("change:content", () => {
            this._updateXMLContent();
            this._colorFillPaths();
          });
          this.on("change:fillColor", () => {
            this._colorFillPaths();
          });
        }
        _updateXMLContent() {
          if (this.content) {
            const t = new DOMParser().parseFromString(
              this.content.trim(),
              "image/svg+xml"
            );
            const e = t.querySelector("svg");
            const n = e.getAttribute("viewBox");
            if (n) {
              this.viewBox = n;
            }
            this.element.innerHTML = "";
            while (e.childNodes.length > 0) {
              this.element.appendChild(e.childNodes[0]);
            }
          }
        }
        _colorFillPaths() {
          if (this.fillColor) {
            this.element.querySelectorAll(".ck-icon__fill").forEach((t) => {
              t.style.fill = this.fillColor;
            });
          }
        }
      }
      var Hb = n(18);
      var Jb = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Jb.insert = "head";
      Jb.singleton = true;
      var Yb = ik()(Hb["a"], Jb);
      var Qb = Hb["a"].locals || {};
      class Xb extends Xk {
        constructor(t) {
          super(t);
          this.set("text", "");
          this.set("position", "s");
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "span",
            attributes: {
              class: [
                "ck",
                "ck-tooltip",
                e.to("position", (t) => "ck-tooltip_" + t),
                e.if("text", "ck-hidden", (t) => !t.trim()),
              ],
            },
            children: [
              {
                tag: "span",
                attributes: { class: ["ck", "ck-tooltip__text"] },
                children: [{ text: e.to("text") }],
              },
            ],
          });
        }
      }
      var Zb = n(19);
      var tw = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      tw.insert = "head";
      tw.singleton = true;
      var ew = ik()(Zb["a"], tw);
      var nw = Zb["a"].locals || {};
      class ow extends Xk {
        constructor(t) {
          super(t);
          const e = this.bindTemplate;
          const n = ns();
          this.set("class");
          this.set("labelStyle");
          this.set("icon");
          this.set("isEnabled", true);
          this.set("isOn", false);
          this.set("isVisible", true);
          this.set("isToggleable", false);
          this.set("keystroke");
          this.set("label");
          this.set("tabindex", -1);
          this.set("tooltip");
          this.set("tooltipPosition", "s");
          this.set("type", "button");
          this.set("withText", false);
          this.set("withKeystroke", false);
          this.children = this.createCollection();
          this.tooltipView = this._createTooltipView();
          this.labelView = this._createLabelView(n);
          this.iconView = new Ub();
          this.iconView.extendTemplate({
            attributes: { class: "ck-button__icon" },
          });
          this.keystrokeView = this._createKeystrokeView();
          this.bind("_tooltipString").to(
            this,
            "tooltip",
            this,
            "label",
            this,
            "keystroke",
            this._getTooltipString.bind(this)
          );
          this.setTemplate({
            tag: "button",
            attributes: {
              class: [
                "ck",
                "ck-button",
                e.to("class"),
                e.if("isEnabled", "ck-disabled", (t) => !t),
                e.if("isVisible", "ck-hidden", (t) => !t),
                e.to("isOn", (t) => (t ? "ck-on" : "ck-off")),
                e.if("withText", "ck-button_with-text"),
                e.if("withKeystroke", "ck-button_with-keystroke"),
              ],
              type: e.to("type", (t) => (t ? t : "button")),
              tabindex: e.to("tabindex"),
              "aria-labelledby": `ck-editor__aria-label_${n}`,
              "aria-disabled": e.if("isEnabled", true, (t) => !t),
              "aria-pressed": e.to("isOn", (t) =>
                this.isToggleable ? String(t) : false
              ),
            },
            children: this.children,
            on: {
              mousedown: e.to((t) => {
                t.preventDefault();
              }),
              click: e.to((t) => {
                if (this.isEnabled) {
                  this.fire("execute");
                } else {
                  t.preventDefault();
                }
              }),
            },
          });
        }
        render() {
          super.render();
          if (this.icon) {
            this.iconView.bind("content").to(this, "icon");
            this.children.add(this.iconView);
          }
          this.children.add(this.tooltipView);
          this.children.add(this.labelView);
          if (this.withKeystroke) {
            this.children.add(this.keystrokeView);
          }
        }
        focus() {
          this.element.focus();
        }
        _createTooltipView() {
          const t = new Xb();
          t.bind("text").to(this, "_tooltipString");
          t.bind("position").to(this, "tooltipPosition");
          return t;
        }
        _createLabelView(t) {
          const e = new Xk();
          const n = this.bindTemplate;
          e.setTemplate({
            tag: "span",
            attributes: {
              class: ["ck", "ck-button__label"],
              style: n.to("labelStyle"),
              id: `ck-editor__aria-label_${t}`,
            },
            children: [{ text: this.bindTemplate.to("label") }],
          });
          return e;
        }
        _createKeystrokeView() {
          const t = new Xk();
          t.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__keystroke"] },
            children: [
              { text: this.bindTemplate.to("keystroke", (t) => Vl(t)) },
            ],
          });
          return t;
        }
        _getTooltipString(t, e, n) {
          if (t) {
            if (typeof t == "string") {
              return t;
            } else {
              if (n) {
                n = Vl(n);
              }
              if (t instanceof Function) {
                return t(e, n);
              } else {
                return `${e}${n ? ` (${n})` : ""}`;
              }
            }
          }
          return "";
        }
      }
      var iw =
        '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
      class rw extends ow {
        constructor(t) {
          super(t);
          this.arrowView = this._createArrowView();
          this.extendTemplate({ attributes: { "aria-haspopup": true } });
          this.delegate("execute").to(this, "open");
        }
        render() {
          super.render();
          this.children.add(this.arrowView);
        }
        _createArrowView() {
          const t = new Ub();
          t.content = iw;
          t.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } });
          return t;
        }
      }
      var sw = n(20);
      var aw = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      aw.insert = "head";
      aw.singleton = true;
      var cw = ik()(sw["a"], aw);
      var lw = sw["a"].locals || {};
      class dw extends Xk {
        constructor() {
          super();
          this.items = this.createCollection();
          this.focusTracker = new Zm();
          this.keystrokes = new zm();
          this._focusCycler = new Tb({
            focusables: this.items,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "arrowup", focusNext: "arrowdown" },
          });
          this.setTemplate({
            tag: "ul",
            attributes: { class: ["ck", "ck-reset", "ck-list"] },
            children: this.items,
          });
        }
        render() {
          super.render();
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on("add", (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
      }
      class uw extends Xk {
        constructor(t) {
          super(t);
          this.children = this.createCollection();
          this.setTemplate({
            tag: "li",
            attributes: { class: ["ck", "ck-list__item"] },
            children: this.children,
          });
        }
        focus() {
          this.children.first.focus();
        }
      }
      class hw extends Xk {
        constructor(t) {
          super(t);
          this.setTemplate({
            tag: "li",
            attributes: { class: ["ck", "ck-list__separator"] },
          });
        }
      }
      var fw = n(21);
      var gw = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      gw.insert = "head";
      gw.singleton = true;
      var pw = ik()(fw["a"], gw);
      var mw = fw["a"].locals || {};
      class kw extends ow {
        constructor(t) {
          super(t);
          this.isToggleable = true;
          this.toggleSwitchView = this._createToggleView();
          this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
        }
        render() {
          super.render();
          this.children.add(this.toggleSwitchView);
        }
        _createToggleView() {
          const t = new Xk();
          t.setTemplate({
            tag: "span",
            attributes: { class: ["ck", "ck-button__toggle"] },
            children: [
              {
                tag: "span",
                attributes: { class: ["ck", "ck-button__toggle__inner"] },
              },
            ],
          });
          return t;
        }
      }
      function bw({
        emitter: t,
        activator: e,
        callback: n,
        contextElements: o,
      }) {
        t.listenTo(document, "mousedown", (t, i) => {
          if (!e()) {
            return;
          }
          const r = typeof i.composedPath == "function" ? i.composedPath() : [];
          for (const t of o) {
            if (t.contains(i.target) || r.includes(t)) {
              return;
            }
          }
          n();
        });
      }
      var ww = n(22);
      var _w = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      _w.insert = "head";
      _w.singleton = true;
      var Aw = ik()(ww["a"], _w);
      var Cw = ww["a"].locals || {};
      var vw = n(23);
      var yw = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      yw.insert = "head";
      yw.singleton = true;
      var xw = ik()(vw["a"], yw);
      var Ew = vw["a"].locals || {};
      function Sw(t, e = rw) {
        const n = new e(t);
        const o = new Mb(t);
        const i = new Kb(t, n, o);
        n.bind("isEnabled").to(i);
        if (n instanceof rw) {
          n.bind("isOn").to(i, "isOpen");
        } else {
          n.arrowView.bind("isOn").to(i, "isOpen");
        }
        Tw(i);
        return i;
      }
      function Pw(t, e) {
        const n = t.locale;
        const o = n.t;
        const i = (t.toolbarView = new Lw(n));
        i.set("ariaLabel", o("Dropdown toolbar"));
        t.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } });
        e.map((t) => i.items.add(t));
        t.panelView.children.add(i);
        i.items.delegate("execute").to(t);
      }
      function Dw(t, e) {
        const n = t.locale;
        const o = (t.listView = new dw(n));
        o.items.bindTo(e).using(({ type: t, model: e }) => {
          if (t === "separator") {
            return new hw(n);
          } else if (t === "button" || t === "switchbutton") {
            const o = new uw(n);
            let i;
            if (t === "button") {
              i = new ow(n);
            } else {
              i = new kw(n);
            }
            i.bind(...Object.keys(e)).to(e);
            i.delegate("execute").to(o);
            o.children.add(i);
            return o;
          }
        });
        t.panelView.children.add(o);
        o.items.delegate("execute").to(t);
      }
      function Tw(t) {
        Bw(t);
        Iw(t);
        Ow(t);
      }
      function Bw(t) {
        t.on("render", () => {
          bw({
            emitter: t,
            activator: () => t.isOpen,
            callback: () => {
              t.isOpen = false;
            },
            contextElements: [t.element],
          });
        });
      }
      function Iw(t) {
        t.on("execute", (e) => {
          if (e.source instanceof kw) {
            return;
          }
          t.isOpen = false;
        });
      }
      function Ow(t) {
        t.keystrokes.set("arrowdown", (e, n) => {
          if (t.isOpen) {
            t.panelView.focus();
            n();
          }
        });
        t.keystrokes.set("arrowup", (e, n) => {
          if (t.isOpen) {
            t.panelView.focusLast();
            n();
          }
        });
      }
      var Rw =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>';
      var Fw = n(24);
      var Nw = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Nw.insert = "head";
      Nw.singleton = true;
      var Mw = ik()(Fw["a"], Nw);
      var Vw = Fw["a"].locals || {};
      class Lw extends Xk {
        constructor(t, e) {
          super(t);
          const n = this.bindTemplate;
          const o = this.t;
          this.options = e || {};
          this.set("ariaLabel", o("Editor toolbar"));
          this.set("maxWidth", "auto");
          this.items = this.createCollection();
          this.focusTracker = new Zm();
          this.keystrokes = new zm();
          this.set("class");
          this.set("isCompact", false);
          this.itemsView = new zw(t);
          this.children = this.createCollection();
          this.children.add(this.itemsView);
          this.focusables = this.createCollection();
          this._focusCycler = new Tb({
            focusables: this.focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: {
              focusPrevious: ["arrowleft", "arrowup"],
              focusNext: ["arrowright", "arrowdown"],
            },
          });
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-toolbar",
                n.to("class"),
                n.if("isCompact", "ck-toolbar_compact"),
              ],
              role: "toolbar",
              "aria-label": n.to("ariaLabel"),
              style: { maxWidth: n.to("maxWidth") },
            },
            children: this.children,
            on: { mousedown: Nb(this) },
          });
          this._behavior = this.options.shouldGroupWhenFull
            ? new Kw(this)
            : new jw(this);
        }
        render() {
          super.render();
          for (const t of this.items) {
            this.focusTracker.add(t.element);
          }
          this.items.on("add", (t, e) => {
            this.focusTracker.add(e.element);
          });
          this.items.on("remove", (t, e) => {
            this.focusTracker.remove(e.element);
          });
          this.keystrokes.listenTo(this.element);
          this._behavior.render(this);
        }
        destroy() {
          this._behavior.destroy();
          return super.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        fillFromConfig(t, e) {
          this.items.addMany(
            t
              .map((t) => {
                if (t == "|") {
                  return new Ib();
                } else if (e.has(t)) {
                  return e.create(t);
                } else {
                  Object(ss["c"])("toolbarview-item-unavailable", { name: t });
                }
              })
              .filter((t) => t !== undefined)
          );
        }
      }
      class zw extends Xk {
        constructor(t) {
          super(t);
          this.children = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: { class: ["ck", "ck-toolbar__items"] },
            children: this.children,
          });
        }
      }
      class jw {
        constructor(t) {
          const e = t.bindTemplate;
          t.set("isVertical", false);
          t.itemsView.children.bindTo(t.items).using((t) => t);
          t.focusables.bindTo(t.items).using((t) => t);
          t.extendTemplate({
            attributes: { class: [e.if("isVertical", "ck-toolbar_vertical")] },
          });
        }
        render() {}
        destroy() {}
      }
      class Kw {
        constructor(t) {
          this.view = t;
          this.viewChildren = t.children;
          this.viewFocusables = t.focusables;
          this.viewItemsView = t.itemsView;
          this.viewFocusTracker = t.focusTracker;
          this.viewLocale = t.locale;
          this.ungroupedItems = t.createCollection();
          this.groupedItems = t.createCollection();
          this.groupedItemsDropdown = this._createGroupedItemsDropdown();
          this.resizeObserver = null;
          this.cachedPadding = null;
          this.shouldUpdateGroupingOnNextResize = false;
          t.itemsView.children.bindTo(this.ungroupedItems).using((t) => t);
          this.ungroupedItems.on(
            "add",
            this._updateFocusCycleableItems.bind(this)
          );
          this.ungroupedItems.on(
            "remove",
            this._updateFocusCycleableItems.bind(this)
          );
          t.children.on("add", this._updateFocusCycleableItems.bind(this));
          t.children.on("remove", this._updateFocusCycleableItems.bind(this));
          t.items.on("change", (t, e) => {
            const n = e.index;
            for (const t of e.removed) {
              if (n >= this.ungroupedItems.length) {
                this.groupedItems.remove(t);
              } else {
                this.ungroupedItems.remove(t);
              }
            }
            for (let t = n; t < n + e.added.length; t++) {
              const o = e.added[t - n];
              if (t > this.ungroupedItems.length) {
                this.groupedItems.add(o, t - this.ungroupedItems.length);
              } else {
                this.ungroupedItems.add(o, t);
              }
            }
            this._updateGrouping();
          });
          t.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
        }
        render(t) {
          this.viewElement = t.element;
          this._enableGroupingOnResize();
          this._enableGroupingOnMaxWidthChange(t);
        }
        destroy() {
          this.groupedItemsDropdown.destroy();
          this.resizeObserver.destroy();
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
            return;
          }
          if (!this.viewElement.offsetParent) {
            this.shouldUpdateGroupingOnNextResize = true;
            return;
          }
          const t = this.groupedItems.length;
          let e;
          while (this._areItemsOverflowing) {
            this._groupLastItem();
            e = true;
          }
          if (!e && this.groupedItems.length) {
            while (this.groupedItems.length && !this._areItemsOverflowing) {
              this._ungroupFirstItem();
            }
            if (this._areItemsOverflowing) {
              this._groupLastItem();
            }
          }
          if (this.groupedItems.length !== t) {
            this.view.fire("groupedItemsUpdate");
          }
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length) {
            return false;
          }
          const t = this.viewElement;
          const e = this.viewLocale.uiLanguageDirection;
          const n = new Eh(t.lastChild);
          const o = new Eh(t);
          if (!this.cachedPadding) {
            const n = Vd.window.getComputedStyle(t);
            const o = e === "ltr" ? "paddingRight" : "paddingLeft";
            this.cachedPadding = Number.parseInt(n[o]);
          }
          if (e === "ltr") {
            return n.right > o.right - this.cachedPadding;
          } else {
            return n.left < o.left + this.cachedPadding;
          }
        }
        _enableGroupingOnResize() {
          let t;
          this.resizeObserver = new Rb(this.viewElement, (e) => {
            if (
              !t ||
              t !== e.contentRect.width ||
              this.shouldUpdateGroupingOnNextResize
            ) {
              this.shouldUpdateGroupingOnNextResize = false;
              this._updateGrouping();
              t = e.contentRect.width;
            }
          });
          this._updateGrouping();
        }
        _enableGroupingOnMaxWidthChange(t) {
          t.on("change:maxWidth", () => {
            this._updateGrouping();
          });
        }
        _groupLastItem() {
          if (!this.groupedItems.length) {
            this.viewChildren.add(new Ib());
            this.viewChildren.add(this.groupedItemsDropdown);
            this.viewFocusTracker.add(this.groupedItemsDropdown.element);
          }
          this.groupedItems.add(
            this.ungroupedItems.remove(this.ungroupedItems.last),
            0
          );
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(
            this.groupedItems.remove(this.groupedItems.first)
          );
          if (!this.groupedItems.length) {
            this.viewChildren.remove(this.groupedItemsDropdown);
            this.viewChildren.remove(this.viewChildren.last);
            this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
          }
        }
        _createGroupedItemsDropdown() {
          const t = this.viewLocale;
          const e = t.t;
          const n = Sw(t);
          n.class = "ck-toolbar__grouped-dropdown";
          n.panelPosition = t.uiLanguageDirection === "ltr" ? "sw" : "se";
          Pw(n, []);
          n.buttonView.set({
            label: e("Show more items"),
            tooltip: true,
            icon: Rw,
          });
          n.toolbarView.items.bindTo(this.groupedItems).using((t) => t);
          return n;
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear();
          this.ungroupedItems.map((t) => {
            this.viewFocusables.add(t);
          });
          if (this.groupedItems.length) {
            this.viewFocusables.add(this.groupedItemsDropdown);
          }
        }
      }
      const qw = wb("px");
      class $w extends cb {
        constructor(t, e, n, o = {}) {
          super(t);
          this.toolbar = new Lw(t, {
            shouldGroupWhenFull: o.shouldToolbarGroupWhenFull,
          });
          this.set("viewportTopOffset", 0);
          this.toolbar.extendTemplate({
            attributes: { class: ["ck-toolbar_floating"] },
          });
          this.panel = new Eb(t);
          this.panel.withArrow = false;
          this.panelPositions = this._getPanelPositions();
          this.panel.extendTemplate({
            attributes: { class: "ck-toolbar-container" },
          });
          this.editable = new db(t, e, n);
          this._resizeObserver = null;
        }
        render() {
          super.render();
          this.body.add(this.panel);
          this.registerChild(this.editable);
          this.panel.content.add(this.toolbar);
          const t = this.toolbar.options;
          if (t.shouldGroupWhenFull) {
            const t = this.editable.element;
            this._resizeObserver = new Rb(t, () => {
              this.toolbar.maxWidth = qw(new Eh(t).width);
            });
          }
        }
        destroy() {
          super.destroy();
          if (this._resizeObserver) {
            this._resizeObserver.destroy();
          }
        }
        _getPanelPositionTop(t, e) {
          let n;
          if (t.top > e.height + this.viewportTopOffset) {
            n = t.top - e.height;
          } else if (t.bottom > e.height + this.viewportTopOffset + 50) {
            n = this.viewportTopOffset;
          } else {
            n = t.bottom;
          }
          return n;
        }
        _getPanelPositions() {
          const t = [
            (t, e) => ({
              top: this._getPanelPositionTop(t, e),
              left: t.left,
              name: "toolbar_west",
            }),
            (t, e) => ({
              top: this._getPanelPositionTop(t, e),
              left: t.left + t.width - e.width,
              name: "toolbar_east",
            }),
          ];
          if (this.locale.uiLanguageDirection === "ltr") {
            return t;
          } else {
            return t.reverse();
          }
        }
      }
      function Ww(t) {
        if (t instanceof HTMLTextAreaElement) {
          return t.value;
        }
        return t.innerHTML;
      }
      function Gw(t) {
        const e = t.sourceElement;
        if (!e) {
          return;
        }
        if (e.ckeditorInstance) {
          throw new ss["a"]("editor-source-element-already-used", t);
        }
        e.ckeditorInstance = t;
        t.once("destroy", () => {
          delete e.ckeditorInstance;
        });
      }
      class Uw extends Km {
        constructor(t, e) {
          super(e);
          this.data.processor = new Ym(this.data.viewDocument);
          this.model.document.createRoot();
          if (Hr(t)) {
            this.sourceElement = t;
            Gw(this);
          }
          const n = !this.config.get("toolbar.shouldNotGroupWhenFull");
          const o = new $w(this.locale, this.editing.view, this.sourceElement, {
            shouldToolbarGroupWhenFull: n,
          });
          this.ui = new bk(this, o);
          Hm(this);
        }
        destroy() {
          const t = this.getData();
          this.ui.destroy();
          return super.destroy().then(() => {
            if (this.sourceElement) {
              Wm(this.sourceElement, t);
            }
          });
        }
        static create(t, e = {}) {
          return new Promise((n) => {
            const o = Hr(t);
            if (o && t.tagName === "TEXTAREA") {
              throw new ss["a"]("editor-wrong-element", null);
            }
            const i = new this(t, e);
            n(
              i
                .initPlugins()
                .then(() => {
                  i.ui.init();
                })
                .then(() => {
                  if (!o && e.initialData) {
                    throw new ss["a"]("editor-create-initial-data", null);
                  }
                  const n = e.initialData || Hw(t);
                  return i.data.init(n);
                })
                .then(() => i.fire("ready"))
                .then(() => i)
            );
          });
        }
      }
      Cs(Uw, $m);
      Cs(Uw, Um);
      function Hw(t) {
        return Hr(t) ? Ww(t) : t;
      }
      function Jw(t) {
        const e = t.next();
        if (e.done) {
          return null;
        }
        return e.value;
      }
      function Yw(t, e, n, o) {
        let i;
        let r = null;
        if (typeof o == "function") {
          i = o;
        } else {
          r = t.commands.get(o);
          i = () => {
            t.execute(o);
          };
        }
        t.model.document.on("change:data", (o, s) => {
          if ((r && !r.isEnabled) || !e.isEnabled) {
            return;
          }
          const a = Jw(t.model.document.selection.getRanges());
          if (!a.isCollapsed) {
            return;
          }
          if (s.type == "transparent") {
            return;
          }
          const c = Array.from(t.model.document.differ.getChanges());
          const l = c[0];
          if (
            c.length != 1 ||
            l.type !== "insert" ||
            l.name != "$text" ||
            l.length != 1
          ) {
            return;
          }
          const d = l.position.parent;
          if (d.is("element", "codeBlock")) {
            return;
          }
          if (r && r.value === true) {
            return;
          }
          const u = d.getChild(0);
          const h = t.model.createRangeOn(u);
          if (!h.containsRange(a) && !a.end.isEqual(h.end)) {
            return;
          }
          const f = n.exec(u.data.substr(0, a.end.offset));
          if (!f) {
            return;
          }
          t.model.enqueueChange((t) => {
            const e = t.createPositionAt(d, 0);
            const n = t.createPositionAt(d, f[0].length);
            const o = new mf(e, n);
            const r = i({ match: f });
            if (r !== false) {
              t.remove(o);
            }
            o.detach();
          });
        });
      }
      function Qw(t, e, n, o) {
        let i;
        let r;
        if (n instanceof RegExp) {
          i = n;
        } else {
          r = n;
        }
        r =
          r ||
          ((t) => {
            let e;
            const n = [];
            const o = [];
            while ((e = i.exec(t)) !== null) {
              if (e && e.length < 4) {
                break;
              }
              let { index: t, 1: i, 2: r, 3: s } = e;
              const a = i + r + s;
              t += e[0].length - a.length;
              const c = [t, t + i.length];
              const l = [
                t + i.length + r.length,
                t + i.length + r.length + s.length,
              ];
              n.push(c);
              n.push(l);
              o.push([t + i.length, t + i.length + r.length]);
            }
            return { remove: n, format: o };
          });
        t.model.document.on("change:data", (n, i) => {
          if (i.type == "transparent" || !e.isEnabled) {
            return;
          }
          const s = t.model;
          const a = s.document.selection;
          if (!a.isCollapsed) {
            return;
          }
          const c = Array.from(s.document.differ.getChanges());
          const l = c[0];
          if (
            c.length != 1 ||
            l.type !== "insert" ||
            l.name != "$text" ||
            l.length != 1
          ) {
            return;
          }
          const d = a.focus;
          const u = d.parent;
          const { text: h, range: f } = Zw(
            s.createRange(s.createPositionAt(u, 0), d),
            s
          );
          const g = r(h);
          const p = Xw(f.start, g.format, s);
          const m = Xw(f.start, g.remove, s);
          if (!(p.length && m.length)) {
            return;
          }
          s.enqueueChange((t) => {
            const e = o(t, p);
            if (e === false) {
              return;
            }
            for (const e of m.reverse()) {
              t.remove(e);
            }
          });
        });
      }
      function Xw(t, e, n) {
        return e
          .filter((t) => t[0] !== undefined && t[1] !== undefined)
          .map((e) =>
            n.createRange(t.getShiftedBy(e[0]), t.getShiftedBy(e[1]))
          );
      }
      function Zw(t, e) {
        let n = t.start;
        const o = Array.from(t.getItems()).reduce((t, o) => {
          if (
            !(o.is("$text") || o.is("$textProxy")) ||
            o.getAttribute("code")
          ) {
            n = e.createPositionAfter(o);
            return "";
          }
          return t + o.data;
        }, "");
        return { text: o, range: e.createRange(n, t.end) };
      }
      class t_ {
        constructor(t) {
          this.editor = t;
          this.set("isEnabled", true);
          this._disableStack = new Set();
        }
        forceDisabled(t) {
          this._disableStack.add(t);
          if (this._disableStack.size == 1) {
            this.on("set:isEnabled", e_, { priority: "highest" });
            this.isEnabled = false;
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t);
          if (this._disableStack.size == 0) {
            this.off("set:isEnabled", e_);
            this.isEnabled = true;
          }
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return false;
        }
      }
      Cs(t_, Yc);
      function e_(t) {
        t.return = false;
        t.stop();
      }
      class n_ extends t_ {
        static get pluginName() {
          return "Autoformat";
        }
        afterInit() {
          this._addListAutoformats();
          this._addBasicStylesAutoformats();
          this._addHeadingAutoformats();
          this._addBlockQuoteAutoformats();
          this._addCodeBlockAutoformats();
        }
        _addListAutoformats() {
          const t = this.editor.commands;
          if (t.get("bulletedList")) {
            Yw(this.editor, this, /^[*-]\s$/, "bulletedList");
          }
          if (t.get("numberedList")) {
            Yw(this.editor, this, /^1[.|)]\s$/, "numberedList");
          }
        }
        _addBasicStylesAutoformats() {
          const t = this.editor.commands;
          if (t.get("bold")) {
            const t = o_(this.editor, "bold");
            Qw(this.editor, this, /(\*\*)([^*]+)(\*\*)$/g, t);
            Qw(this.editor, this, /(__)([^_]+)(__)$/g, t);
          }
          if (t.get("italic")) {
            const t = o_(this.editor, "italic");
            Qw(this.editor, this, /(?:^|[^*])(\*)([^*_]+)(\*)$/g, t);
            Qw(this.editor, this, /(?:^|[^_])(_)([^_]+)(_)$/g, t);
          }
          if (t.get("code")) {
            const t = o_(this.editor, "code");
            Qw(this.editor, this, /(`)([^`]+)(`)$/g, t);
          }
          if (t.get("strikethrough")) {
            const t = o_(this.editor, "strikethrough");
            Qw(this.editor, this, /(~~)([^~]+)(~~)$/g, t);
          }
        }
        _addHeadingAutoformats() {
          const t = this.editor.commands.get("heading");
          if (t) {
            t.modelElements
              .filter((t) => t.match(/^heading[1-6]$/))
              .forEach((e) => {
                const n = e[7];
                const o = new RegExp(`^(#{${n}})\\s$`);
                Yw(this.editor, this, o, () => {
                  if (!t.isEnabled || t.value === e) {
                    return false;
                  }
                  this.editor.execute("heading", { value: e });
                });
              });
          }
        }
        _addBlockQuoteAutoformats() {
          if (this.editor.commands.get("blockQuote")) {
            Yw(this.editor, this, /^>\s$/, "blockQuote");
          }
        }
        _addCodeBlockAutoformats() {
          if (this.editor.commands.get("codeBlock")) {
            Yw(this.editor, this, /^```$/, "codeBlock");
          }
        }
      }
      function o_(t, e) {
        return (n, o) => {
          const i = t.commands.get(e);
          if (!i.isEnabled) {
            return false;
          }
          const r = t.model.schema.getValidRanges(o, e);
          for (const t of r) {
            n.setAttribute(e, true, t);
          }
          n.removeSelectionAttribute(e);
        };
      }
      class i_ {
        constructor(t) {
          this.editor = t;
          this.set("value", undefined);
          this.set("isEnabled", false);
          this._disableStack = new Set();
          this.decorate("execute");
          this.listenTo(this.editor.model.document, "change", () => {
            this.refresh();
          });
          this.on(
            "execute",
            (t) => {
              if (!this.isEnabled) {
                t.stop();
              }
            },
            { priority: "high" }
          );
          this.listenTo(t, "change:isReadOnly", (t, e, n) => {
            if (n) {
              this.forceDisabled("readOnlyMode");
            } else {
              this.clearForceDisabled("readOnlyMode");
            }
          });
        }
        refresh() {
          this.isEnabled = true;
        }
        forceDisabled(t) {
          this._disableStack.add(t);
          if (this._disableStack.size == 1) {
            this.on("set:isEnabled", r_, { priority: "highest" });
            this.isEnabled = false;
          }
        }
        clearForceDisabled(t) {
          this._disableStack.delete(t);
          if (this._disableStack.size == 0) {
            this.off("set:isEnabled", r_);
            this.refresh();
          }
        }
        execute() {}
        destroy() {
          this.stopListening();
        }
      }
      Cs(i_, Yc);
      function r_(t) {
        t.return = false;
        t.stop();
      }
      class s_ extends i_ {
        refresh() {
          this.value = this._getValue();
          this.isEnabled = this._checkEnabled();
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.schema;
          const o = e.document.selection;
          const i = Array.from(o.getSelectedBlocks());
          const r = t.forceValue === undefined ? !this.value : t.forceValue;
          e.change((t) => {
            if (!r) {
              this._removeQuote(t, i.filter(a_));
            } else {
              const e = i.filter((t) => a_(t) || l_(n, t));
              this._applyQuote(t, e);
            }
          });
        }
        _getValue() {
          const t = this.editor.model.document.selection;
          const e = Jw(t.getSelectedBlocks());
          return !!(e && a_(e));
        }
        _checkEnabled() {
          if (this.value) {
            return true;
          }
          const t = this.editor.model.document.selection;
          const e = this.editor.model.schema;
          const n = Jw(t.getSelectedBlocks());
          if (!n) {
            return false;
          }
          return l_(e, n);
        }
        _removeQuote(t, e) {
          c_(t, e)
            .reverse()
            .forEach((e) => {
              if (e.start.isAtStart && e.end.isAtEnd) {
                t.unwrap(e.start.parent);
                return;
              }
              if (e.start.isAtStart) {
                const n = t.createPositionBefore(e.start.parent);
                t.move(e, n);
                return;
              }
              if (!e.end.isAtEnd) {
                t.split(e.end);
              }
              const n = t.createPositionAfter(e.end.parent);
              t.move(e, n);
            });
        }
        _applyQuote(t, e) {
          const n = [];
          c_(t, e)
            .reverse()
            .forEach((e) => {
              let o = a_(e.start);
              if (!o) {
                o = t.createElement("blockQuote");
                t.wrap(e, o);
              }
              n.push(o);
            });
          n.reverse().reduce((e, n) => {
            if (e.nextSibling == n) {
              t.merge(t.createPositionAfter(e));
              return e;
            }
            return n;
          });
        }
      }
      function a_(t) {
        return t.parent.name == "blockQuote" ? t.parent : null;
      }
      function c_(t, e) {
        let n;
        let o = 0;
        const i = [];
        while (o < e.length) {
          const r = e[o];
          const s = e[o + 1];
          if (!n) {
            n = t.createPositionBefore(r);
          }
          if (!s || r.nextSibling != s) {
            i.push(t.createRange(n, t.createPositionAfter(r)));
            n = null;
          }
          o++;
        }
        return i;
      }
      function l_(t, e) {
        const n = t.checkChild(e.parent, "blockQuote");
        const o = t.checkChild(["$root", "blockQuote"], e);
        return n && o;
      }
      class d_ extends t_ {
        static get pluginName() {
          return "BlockQuoteEditing";
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          t.commands.add("blockQuote", new s_(t));
          e.register("blockQuote", {
            allowWhere: "$block",
            allowContentOf: "$root",
          });
          e.addChildCheck((t, e) => {
            if (t.endsWith("blockQuote") && e.name == "blockQuote") {
              return false;
            }
          });
          t.conversion.elementToElement({
            model: "blockQuote",
            view: "blockquote",
          });
          t.model.document.registerPostFixer((n) => {
            const o = t.model.document.differ.getChanges();
            for (const t of o) {
              if (t.type == "insert") {
                const o = t.position.nodeAfter;
                if (!o) {
                  continue;
                }
                if (o.is("element", "blockQuote") && o.isEmpty) {
                  n.remove(o);
                  return true;
                } else if (
                  o.is("element", "blockQuote") &&
                  !e.checkChild(t.position, o)
                ) {
                  n.unwrap(o);
                  return true;
                } else if (o.is("element")) {
                  const t = n.createRangeIn(o);
                  for (const o of t.getItems()) {
                    if (
                      o.is("element", "blockQuote") &&
                      !e.checkChild(n.createPositionBefore(o), o)
                    ) {
                      n.unwrap(o);
                      return true;
                    }
                  }
                }
              } else if (t.type == "remove") {
                const e = t.position.parent;
                if (e.is("element", "blockQuote") && e.isEmpty) {
                  n.remove(e);
                  return true;
                }
              }
            }
            return false;
          });
        }
        afterInit() {
          const t = this.editor;
          const e = t.commands.get("blockQuote");
          this.listenTo(this.editor.editing.view.document, "enter", (t, n) => {
            const o = this.editor.model.document;
            const i = o.selection.getLastPosition().parent;
            if (o.selection.isCollapsed && i.isEmpty && e.value) {
              this.editor.execute("blockQuote");
              this.editor.editing.view.scrollToTheSelection();
              n.preventDefault();
              t.stop();
            }
          });
        }
      }
      var u_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>';
      var h_ = n(25);
      var f_ = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      f_.insert = "head";
      f_.singleton = true;
      var g_ = ik()(h_["a"], f_);
      var p_ = h_["a"].locals || {};
      class m_ extends t_ {
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("blockQuote", (n) => {
            const o = t.commands.get("blockQuote");
            const i = new ow(n);
            i.set({
              label: e("Block quote"),
              icon: u_,
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute("blockQuote");
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class k_ extends t_ {
        static get requires() {
          return [d_, m_];
        }
        static get pluginName() {
          return "BlockQuote";
        }
      }
      class b_ extends i_ {
        constructor(t, e) {
          super(t);
          this.attributeKey = e;
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.value = this._getValueFromFirstAllowedNode();
          this.isEnabled = t.schema.checkAttributeInSelection(
            e.selection,
            this.attributeKey
          );
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const o = n.selection;
          const i = t.forceValue === undefined ? !this.value : t.forceValue;
          e.change((t) => {
            if (o.isCollapsed) {
              if (i) {
                t.setSelectionAttribute(this.attributeKey, true);
              } else {
                t.removeSelectionAttribute(this.attributeKey);
              }
            } else {
              const n = e.schema.getValidRanges(
                o.getRanges(),
                this.attributeKey
              );
              for (const e of n) {
                if (i) {
                  t.setAttribute(this.attributeKey, i, e);
                } else {
                  t.removeAttribute(this.attributeKey, e);
                }
              }
            }
          });
        }
        _getValueFromFirstAllowedNode() {
          const t = this.editor.model;
          const e = t.schema;
          const n = t.document.selection;
          if (n.isCollapsed) {
            return n.hasAttribute(this.attributeKey);
          }
          for (const t of n.getRanges()) {
            for (const n of t.getItems()) {
              if (e.checkAttribute(n, this.attributeKey)) {
                return n.hasAttribute(this.attributeKey);
              }
            }
          }
          return false;
        }
      }
      const w_ = "bold";
      class __ extends t_ {
        static get pluginName() {
          return "BoldEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: w_ });
          t.model.schema.setAttributeProperties(w_, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: w_,
            view: "b",
            upcastAlso: [
              "b",
              (t) => {
                const e = t.getStyle("font-weight");
                if (!e) {
                  return null;
                }
                if (e == "bold" || Number(e) >= 600) {
                  return { name: true, styles: ["font-weight"] };
                }
              },
            ],
          });
          t.commands.add(w_, new b_(t, w_));
          t.keystrokes.set("CTRL+B", w_);
        }
      }
      var A_ =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>';
      const C_ = "bold";
      class v_ extends t_ {
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(C_, (n) => {
            const o = t.commands.get(C_);
            const i = new ow(n);
            i.set({
              label: e("Bold"),
              icon: A_,
              keystroke: "CTRL+B",
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute(C_);
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class y_ extends t_ {
        static get requires() {
          return [__, v_];
        }
        static get pluginName() {
          return "Bold";
        }
      }
      class x_ {
        constructor(t) {
          this.files = E_(t);
          this._native = t;
        }
        get types() {
          return this._native.types;
        }
        getData(t) {
          return this._native.getData(t);
        }
        setData(t, e) {
          this._native.setData(t, e);
        }
      }
      function E_(t) {
        const e = t.files ? Array.from(t.files) : [];
        const n = t.items ? Array.from(t.items) : [];
        if (e.length) {
          return e;
        }
        return n.filter((t) => t.kind === "file").map((t) => t.getAsFile());
      }
      class S_ extends eh {
        constructor(t) {
          super(t);
          const e = this.document;
          this.domEventType = ["paste", "copy", "cut", "drop", "dragover"];
          this.listenTo(e, "paste", n, { priority: "low" });
          this.listenTo(e, "drop", n, { priority: "low" });
          function n(t, n) {
            n.preventDefault();
            const o = n.dropRange
              ? [n.dropRange]
              : Array.from(e.selection.getRanges());
            const i = new ts(e, "clipboardInput");
            e.fire(i, { dataTransfer: n.dataTransfer, targetRanges: o });
            if (i.stop.called) {
              n.stopPropagation();
            }
          }
        }
        onDomEvent(t) {
          const e = {
            dataTransfer: new x_(
              t.clipboardData ? t.clipboardData : t.dataTransfer
            ),
          };
          if (t.type == "drop") {
            e.dropRange = P_(this.view, t);
          }
          this.fire(t.type, t, e);
        }
      }
      function P_(t, e) {
        const n = e.target.ownerDocument;
        const o = e.clientX;
        const i = e.clientY;
        let r;
        if (n.caretRangeFromPoint && n.caretRangeFromPoint(o, i)) {
          r = n.caretRangeFromPoint(o, i);
        } else if (e.rangeParent) {
          r = n.createRange();
          r.setStart(e.rangeParent, e.rangeOffset);
          r.collapse(true);
        }
        if (r) {
          return t.domConverter.domRangeToView(r);
        } else {
          return t.document.selection.getFirstRange();
        }
      }
      class D_ extends t_ {
        static get pluginName() {
          return "PastePlainText";
        }
        init() {
          const t = this.editor.editing.view;
          const e = t.document;
          let n = false;
          t.addObserver(S_);
          this.listenTo(e, "keydown", (t, e) => {
            n = e.shiftKey;
          });
          this.listenTo(
            e,
            "clipboardInput",
            (t, e) => {
              if (n) {
                e.asPlainText = true;
              }
            },
            { priority: "high" }
          );
        }
      }
      function T_(t) {
        t = t
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/\r?\n\r?\n/g, "</p><p>")
          .replace(/\r?\n/g, "<br>")
          .replace(/^\s/, "&nbsp;")
          .replace(/\s$/, "&nbsp;")
          .replace(/\s\s/g, " &nbsp;");
        if (t.includes("</p><p>") || t.includes("<br>")) {
          t = `<p>${t}</p>`;
        }
        return t;
      }
      function B_(t) {
        return t.replace(
          /<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g,
          (t, e) => {
            if (e.length == 1) {
              return " ";
            }
            return e;
          }
        );
      }
      const I_ = ["figcaption", "li"];
      function O_(t) {
        let e = "";
        if (t.is("$text") || t.is("$textProxy")) {
          e = t.data;
        } else if (t.is("element", "img") && t.hasAttribute("alt")) {
          e = t.getAttribute("alt");
        } else if (t.is("element", "br")) {
          e = "\n";
        } else {
          let n = null;
          for (const o of t.getChildren()) {
            const t = O_(o);
            if (n && (n.is("containerElement") || o.is("containerElement"))) {
              if (I_.includes(n.name) || I_.includes(o.name)) {
                e += "\n";
              } else {
                e += "\n\n";
              }
            }
            e += t;
            n = o;
          }
        }
        return e;
      }
      class R_ extends t_ {
        static get pluginName() {
          return "Clipboard";
        }
        static get requires() {
          return [D_];
        }
        init() {
          const t = this.editor;
          const e = t.model.document;
          const n = t.editing.view;
          const o = n.document;
          this._htmlDataProcessor = new Ym(o);
          n.addObserver(S_);
          this.listenTo(
            o,
            "clipboardInput",
            (e) => {
              if (t.isReadOnly) {
                e.stop();
              }
            },
            { priority: "highest" }
          );
          this.listenTo(
            o,
            "clipboardInput",
            (t, e) => {
              const o = e.dataTransfer;
              let i = "";
              if (o.getData("text/html")) {
                i = B_(o.getData("text/html"));
              } else if (o.getData("text/plain")) {
                i = T_(o.getData("text/plain"));
              }
              i = this._htmlDataProcessor.toView(i);
              const r = new ts(this, "inputTransformation");
              this.fire(r, {
                content: i,
                dataTransfer: o,
                asPlainText: e.asPlainText,
              });
              if (r.stop.called) {
                t.stop();
              }
              n.scrollToTheSelection();
            },
            { priority: "low" }
          );
          this.listenTo(
            this,
            "inputTransformation",
            (n, o) => {
              if (!o.content.isEmpty) {
                const i = this.editor.data;
                const r = this.editor.model;
                const s = i.toModel(o.content, "$clipboardHolder");
                if (s.childCount == 0) {
                  return;
                }
                if (o.asPlainText || F_(s)) {
                  const n = new Map(
                    Array.from(e.selection.getAttributes()).filter(
                      (e) =>
                        t.model.schema.getAttributeProperties(e[0]).isFormatting
                    )
                  );
                  r.change((t) => {
                    const e = t.createRangeIn(s);
                    for (const o of e.getItems()) {
                      if (o.is("$text") || o.is("$textProxy")) {
                        t.setAttributes(n, o);
                      }
                    }
                  });
                }
                r.insertContent(s);
                n.stop();
              }
            },
            { priority: "low" }
          );
          function i(n, i) {
            const r = i.dataTransfer;
            i.preventDefault();
            const s = t.data.toView(t.model.getSelectedContent(e.selection));
            o.fire("clipboardOutput", {
              dataTransfer: r,
              content: s,
              method: n.name,
            });
          }
          this.listenTo(o, "copy", i, { priority: "low" });
          this.listenTo(
            o,
            "cut",
            (e, n) => {
              if (t.isReadOnly) {
                n.preventDefault();
              } else {
                i(e, n);
              }
            },
            { priority: "low" }
          );
          this.listenTo(
            o,
            "clipboardOutput",
            (n, o) => {
              if (!o.content.isEmpty) {
                o.dataTransfer.setData(
                  "text/html",
                  this._htmlDataProcessor.toData(o.content)
                );
                o.dataTransfer.setData("text/plain", O_(o.content));
              }
              if (o.method == "cut") {
                t.model.deleteContent(e.selection);
              }
            },
            { priority: "low" }
          );
        }
      }
      function F_(t) {
        if (t.childCount > 1) {
          return false;
        }
        const e = t.getChild(0);
        return [...e.getAttributeKeys()].length == 0;
      }
      function* N_(t, e) {
        for (const n of e) {
          if (n && t.getAttributeProperties(n[0]).copyOnEnter) {
            yield n;
          }
        }
      }
      class M_ extends i_ {
        execute() {
          const t = this.editor.model;
          const e = t.document;
          t.change((n) => {
            V_(this.editor.model, n, e.selection, t.schema);
            this.fire("afterExecute", { writer: n });
          });
        }
      }
      function V_(t, e, n, o) {
        const i = n.isCollapsed;
        const r = n.getFirstRange();
        const s = r.start.parent;
        const a = r.end.parent;
        if (o.isLimit(s) || o.isLimit(a)) {
          if (!i && s == a) {
            t.deleteContent(n);
          }
          return;
        }
        if (i) {
          const t = N_(e.model.schema, n.getAttributes());
          L_(e, r.start);
          e.setSelectionAttribute(t);
        } else {
          const o = !(r.start.isAtStart && r.end.isAtEnd);
          const i = s == a;
          t.deleteContent(n, { leaveUnmerged: o });
          if (o) {
            if (i) {
              L_(e, n.focus);
            } else {
              e.setSelection(a, 0);
            }
          }
        }
      }
      function L_(t, e) {
        t.split(e);
        t.setSelection(e.parent.nextSibling, 0);
      }
      class z_ extends Zd {
        constructor(t) {
          super(t);
          const e = this.document;
          e.on("keydown", (t, n) => {
            if (this.isEnabled && n.keyCode == Fl.enter) {
              let o;
              e.once("enter", (t) => (o = t), { priority: "highest" });
              e.fire("enter", new th(e, n.domEvent, { isSoft: n.shiftKey }));
              if (o && o.stop.called) {
                t.stop();
              }
            }
          });
        }
        observe() {}
      }
      class j_ extends t_ {
        static get pluginName() {
          return "Enter";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          e.addObserver(z_);
          t.commands.add("enter", new M_(t));
          this.listenTo(
            n,
            "enter",
            (n, o) => {
              o.preventDefault();
              if (o.isSoft) {
                return;
              }
              t.execute("enter");
              e.scrollToTheSelection();
            },
            { priority: "low" }
          );
        }
      }
      class K_ extends i_ {
        execute() {
          const t = this.editor.model;
          const e = t.document;
          t.change((n) => {
            $_(t, n, e.selection);
            this.fire("afterExecute", { writer: n });
          });
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          this.isEnabled = q_(t.schema, e.selection);
        }
      }
      function q_(t, e) {
        if (e.rangeCount > 1) {
          return false;
        }
        const n = e.anchor;
        if (!n || !t.checkChild(n, "softBreak")) {
          return false;
        }
        const o = e.getFirstRange();
        const i = o.start.parent;
        const r = o.end.parent;
        if ((G_(i, t) || G_(r, t)) && i !== r) {
          return false;
        }
        return true;
      }
      function $_(t, e, n) {
        const o = n.isCollapsed;
        const i = n.getFirstRange();
        const r = i.start.parent;
        const s = i.end.parent;
        const a = r == s;
        if (o) {
          const o = N_(t.schema, n.getAttributes());
          W_(t, e, i.end);
          e.removeSelectionAttribute(n.getAttributeKeys());
          e.setSelectionAttribute(o);
        } else {
          const o = !(i.start.isAtStart && i.end.isAtEnd);
          t.deleteContent(n, { leaveUnmerged: o });
          if (a) {
            W_(t, e, n.focus);
          } else {
            if (o) {
              e.setSelection(s, 0);
            }
          }
        }
      }
      function W_(t, e, n) {
        const o = e.createElement("softBreak");
        t.insertContent(o, n);
        e.setSelection(o, "after");
      }
      function G_(t, e) {
        if (t.is("rootElement")) {
          return false;
        }
        return e.isLimit(t) || G_(t.parent, e);
      }
      class U_ extends t_ {
        static get pluginName() {
          return "ShiftEnter";
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.conversion;
          const o = t.editing.view;
          const i = o.document;
          e.register("softBreak", { allowWhere: "$text", isInline: true });
          n.for("upcast").elementToElement({ model: "softBreak", view: "br" });
          n.for("downcast").elementToElement({
            model: "softBreak",
            view: (t, { writer: e }) => e.createEmptyElement("br"),
          });
          o.addObserver(z_);
          t.commands.add("shiftEnter", new K_(t));
          this.listenTo(
            i,
            "enter",
            (e, n) => {
              n.preventDefault();
              if (!n.isSoft) {
                return;
              }
              t.execute("shiftEnter");
              o.scrollToTheSelection();
            },
            { priority: "low" }
          );
        }
      }
      class H_ extends i_ {
        execute() {
          const t = this.editor.model;
          const e = t.document.selection;
          let n = t.schema.getLimitElement(e);
          if (e.containsEntireContent(n) || !J_(t.schema, n)) {
            do {
              n = n.parent;
              if (!n) {
                return;
              }
            } while (!J_(t.schema, n));
          }
          t.change((t) => {
            t.setSelection(n, "in");
          });
        }
      }
      function J_(t, e) {
        return (
          t.isLimit(e) &&
          (t.checkChild(e, "$text") || t.checkChild(e, "paragraph"))
        );
      }
      const Y_ = Ml("Ctrl+A");
      class Q_ extends t_ {
        static get pluginName() {
          return "SelectAllEditing";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          t.commands.add("selectAll", new H_(t));
          this.listenTo(n, "keydown", (e, n) => {
            if (Nl(n) === Y_) {
              t.execute("selectAll");
              n.preventDefault();
            }
          });
        }
      }
      var X_ =
        '<svg width="20" height="20" xmlns="http://www.w3.org/2000/svg"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>';
      class Z_ extends t_ {
        static get pluginName() {
          return "SelectAllUI";
        }
        init() {
          const t = this.editor;
          t.ui.componentFactory.add("selectAll", (e) => {
            const n = t.commands.get("selectAll");
            const o = new ow(e);
            const i = e.t;
            o.set({
              label: i("Select all"),
              icon: X_,
              keystroke: "Ctrl+A",
              tooltip: true,
            });
            o.bind("isOn", "isEnabled").to(n, "value", "isEnabled");
            this.listenTo(o, "execute", () => {
              t.execute("selectAll");
              t.editing.view.focus();
            });
            return o;
          });
        }
      }
      class tA extends t_ {
        static get requires() {
          return [Q_, Z_];
        }
        static get pluginName() {
          return "SelectAll";
        }
      }
      class eA {
        constructor(t, e = 20) {
          this.model = t;
          this.size = 0;
          this.limit = e;
          this.isLocked = false;
          this._changeCallback = (t, e) => {
            if (e.type != "transparent" && e !== this._batch) {
              this._reset(true);
            }
          };
          this._selectionChangeCallback = () => {
            this._reset();
          };
          this.model.document.on("change", this._changeCallback);
          this.model.document.selection.on(
            "change:range",
            this._selectionChangeCallback
          );
          this.model.document.selection.on(
            "change:attribute",
            this._selectionChangeCallback
          );
        }
        get batch() {
          if (!this._batch) {
            this._batch = this.model.createBatch();
          }
          return this._batch;
        }
        input(t) {
          this.size += t;
          if (this.size >= this.limit) {
            this._reset(true);
          }
        }
        lock() {
          this.isLocked = true;
        }
        unlock() {
          this.isLocked = false;
        }
        destroy() {
          this.model.document.off("change", this._changeCallback);
          this.model.document.selection.off(
            "change:range",
            this._selectionChangeCallback
          );
          this.model.document.selection.off(
            "change:attribute",
            this._selectionChangeCallback
          );
        }
        _reset(t) {
          if (!this.isLocked || t) {
            this._batch = null;
            this.size = 0;
          }
        }
      }
      class nA extends i_ {
        constructor(t, e) {
          super(t);
          this._buffer = new eA(t.model, e);
          this._batches = new WeakSet();
        }
        get buffer() {
          return this._buffer;
        }
        destroy() {
          super.destroy();
          this._buffer.destroy();
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          const o = t.text || "";
          const i = o.length;
          const r = t.range ? e.createSelection(t.range) : n.selection;
          const s = t.resultRange;
          e.enqueueChange(this._buffer.batch, (t) => {
            this._buffer.lock();
            this._batches.add(this._buffer.batch);
            e.deleteContent(r);
            if (o) {
              e.insertContent(t.createText(o, n.selection.getAttributes()), r);
            }
            if (s) {
              t.setSelection(s);
            } else if (!r.is("documentSelection")) {
              t.setSelection(r);
            }
            this._buffer.unlock();
            this._buffer.input(i);
          });
        }
      }
      function oA(t) {
        let e = null;
        const n = t.model;
        const o = t.editing.view;
        const i = t.commands.get("input");
        if (El.isAndroid) {
          o.document.on("beforeinput", (t, e) => r(e), { priority: "lowest" });
        } else {
          o.document.on("keydown", (t, e) => r(e), { priority: "lowest" });
        }
        o.document.on("compositionstart", s, { priority: "lowest" });
        o.document.on(
          "compositionend",
          () => {
            e = n.createSelection(n.document.selection);
          },
          { priority: "lowest" }
        );
        function r(t) {
          const r = n.document;
          const s = o.document.isComposing;
          const c = e && e.isEqual(r.selection);
          e = null;
          if (!i.isEnabled) {
            return;
          }
          if (rA(t) || r.selection.isCollapsed) {
            return;
          }
          if (s && t.keyCode === 229) {
            return;
          }
          if (!s && t.keyCode === 229 && c) {
            return;
          }
          a();
        }
        function s() {
          const t = n.document;
          const e =
            t.selection.rangeCount === 1
              ? t.selection.getFirstRange().isFlat
              : true;
          if (t.selection.isCollapsed || e) {
            return;
          }
          a();
        }
        function a() {
          const t = i.buffer;
          t.lock();
          const e = t.batch;
          i._batches.add(e);
          n.enqueueChange(e, () => {
            n.deleteContent(n.document.selection);
          });
          t.unlock();
        }
      }
      const iA = [
        Nl("arrowUp"),
        Nl("arrowRight"),
        Nl("arrowDown"),
        Nl("arrowLeft"),
        9,
        16,
        17,
        18,
        19,
        20,
        27,
        33,
        34,
        35,
        36,
        45,
        91,
        93,
        144,
        145,
        173,
        174,
        175,
        176,
        177,
        178,
        179,
        255,
      ];
      for (let t = 112; t <= 135; t++) {
        iA.push(t);
      }
      function rA(t) {
        if (t.ctrlKey) {
          return true;
        }
        return iA.includes(t.keyCode);
      }
      function sA(t, e) {
        const n = [];
        let o = 0;
        let i;
        t.forEach((t) => {
          if (t == "equal") {
            r();
            o++;
          } else if (t == "insert") {
            if (s("insert")) {
              i.values.push(e[o]);
            } else {
              r();
              i = { type: "insert", index: o, values: [e[o]] };
            }
            o++;
          } else {
            if (s("delete")) {
              i.howMany++;
            } else {
              r();
              i = { type: "delete", index: o, howMany: 1 };
            }
          }
        });
        r();
        return n;
        function r() {
          if (i) {
            n.push(i);
            i = null;
          }
        }
        function s(t) {
          return i && i.type == t;
        }
      }
      function aA(t) {
        if (t.length == 0) {
          return false;
        }
        for (const e of t) {
          if (e.type === "children" && !cA(e)) {
            return true;
          }
        }
        return false;
      }
      function cA(t) {
        if (t.newChildren.length - t.oldChildren.length != 1) {
          return;
        }
        const e = Ed(t.oldChildren, t.newChildren, lA);
        const n = sA(e, t.newChildren);
        if (n.length > 1) {
          return;
        }
        const o = n[0];
        if (!(!!o.values[0] && o.values[0].is("$text"))) {
          return;
        }
        return o;
      }
      function lA(t, e) {
        if (!!t && t.is("$text") && !!e && e.is("$text")) {
          return t.data === e.data;
        } else {
          return t === e;
        }
      }
      function dA(t) {
        t.editing.view.document.on("mutations", (e, n, o) => {
          new uA(t).handle(n, o);
        });
      }
      class uA {
        constructor(t) {
          this.editor = t;
          this.editing = this.editor.editing;
        }
        handle(t, e) {
          if (aA(t)) {
            this._handleContainerChildrenMutations(t, e);
          } else {
            for (const n of t) {
              this._handleTextMutation(n, e);
              this._handleTextNodeInsertion(n);
            }
          }
        }
        _handleContainerChildrenMutations(t, e) {
          const n = hA(t);
          if (!n) {
            return;
          }
          const o = this.editor.editing.view.domConverter;
          const i = o.mapViewToDom(n);
          const r = new qd(this.editor.editing.view.document);
          const s = this.editor.data.toModel(r.domToView(i)).getChild(0);
          const a = this.editor.editing.mapper.toModelElement(n);
          if (!a) {
            return;
          }
          const c = Array.from(s.getChildren());
          const l = Array.from(a.getChildren());
          const d = c[c.length - 1];
          const u = l[l.length - 1];
          const h = d && d.is("element", "softBreak");
          const f = u && !u.is("element", "softBreak");
          if (h && f) {
            c.pop();
          }
          const g = this.editor.model.schema;
          if (!fA(c, g) || !fA(l, g)) {
            return;
          }
          const p = c
            .map((t) => (t.is("$text") ? t.data : "@"))
            .join("")
            .replace(/\u00A0/g, " ");
          const m = l
            .map((t) => (t.is("$text") ? t.data : "@"))
            .join("")
            .replace(/\u00A0/g, " ");
          if (m === p) {
            return;
          }
          const k = Ed(m, p);
          const { firstChangeAt: b, insertions: w, deletions: _ } = gA(k);
          let A = null;
          if (e) {
            A = this.editing.mapper.toModelRange(e.getFirstRange());
          }
          const C = p.substr(b, w);
          const v = this.editor.model.createRange(
            this.editor.model.createPositionAt(a, b),
            this.editor.model.createPositionAt(a, b + _)
          );
          this.editor.execute("input", { text: C, range: v, resultRange: A });
        }
        _handleTextMutation(t, e) {
          if (t.type != "text") {
            return;
          }
          const n = t.newText.replace(/\u00A0/g, " ");
          const o = t.oldText.replace(/\u00A0/g, " ");
          if (o === n) {
            return;
          }
          const i = Ed(o, n);
          const { firstChangeAt: r, insertions: s, deletions: a } = gA(i);
          let c = null;
          if (e) {
            c = this.editing.mapper.toModelRange(e.getFirstRange());
          }
          const l = this.editing.view.createPositionAt(t.node, r);
          const d = this.editing.mapper.toModelPosition(l);
          const u = this.editor.model.createRange(d, d.getShiftedBy(a));
          const h = n.substr(r, s);
          this.editor.execute("input", { text: h, range: u, resultRange: c });
        }
        _handleTextNodeInsertion(t) {
          if (t.type != "children") {
            return;
          }
          const e = cA(t);
          const n = this.editing.view.createPositionAt(t.node, e.index);
          const o = this.editing.mapper.toModelPosition(n);
          const i = e.values[0].data;
          this.editor.execute("input", {
            text: i.replace(/\u00A0/g, " "),
            range: this.editor.model.createRange(o),
          });
        }
      }
      function hA(t) {
        const e = t
          .map((t) => t.node)
          .reduce((t, e) => t.getCommonAncestor(e, { includeSelf: true }));
        if (!e) {
          return;
        }
        return e
          .getAncestors({ includeSelf: true, parentFirst: true })
          .find((t) => t.is("containerElement") || t.is("rootElement"));
      }
      function fA(t, e) {
        return t.every((t) => e.isInline(t));
      }
      function gA(t) {
        let e = null;
        let n = null;
        for (let o = 0; o < t.length; o++) {
          const i = t[o];
          if (i != "equal") {
            e = e === null ? o : e;
            n = o;
          }
        }
        let o = 0;
        let i = 0;
        for (let r = e; r <= n; r++) {
          if (t[r] != "insert") {
            o++;
          }
          if (t[r] != "delete") {
            i++;
          }
        }
        return { insertions: i, deletions: o, firstChangeAt: e };
      }
      class pA extends t_ {
        static get pluginName() {
          return "Input";
        }
        init() {
          const t = this.editor;
          const e = new nA(t, t.config.get("typing.undoStep") || 20);
          t.commands.add("input", e);
          oA(t);
          dA(t);
        }
        isInput(t) {
          const e = this.editor.commands.get("input");
          return e._batches.has(t);
        }
      }
      class mA extends i_ {
        constructor(t, e) {
          super(t);
          this.direction = e;
          this._buffer = new eA(t.model, t.config.get("typing.undoStep"));
        }
        get buffer() {
          return this._buffer;
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          e.enqueueChange(this._buffer.batch, (o) => {
            this._buffer.lock();
            const i = o.createSelection(t.selection || n.selection);
            const r = i.isCollapsed;
            if (i.isCollapsed) {
              e.modifySelection(i, { direction: this.direction, unit: t.unit });
            }
            if (
              this._shouldEntireContentBeReplacedWithParagraph(t.sequence || 1)
            ) {
              this._replaceEntireContentWithParagraph(o);
              return;
            }
            if (i.isCollapsed) {
              return;
            }
            let s = 0;
            i.getFirstRange()
              .getMinimalFlatRanges()
              .forEach((t) => {
                s += gl(
                  t.getWalker({
                    singleCharacters: true,
                    ignoreElementEnd: true,
                    shallow: true,
                  })
                );
              });
            e.deleteContent(i, {
              doNotResetEntireContent: r,
              direction: this.direction,
            });
            this._buffer.input(s);
            o.setSelection(i);
            this._buffer.unlock();
          });
        }
        _shouldEntireContentBeReplacedWithParagraph(t) {
          if (t > 1) {
            return false;
          }
          const e = this.editor.model;
          const n = e.document;
          const o = n.selection;
          const i = e.schema.getLimitElement(o);
          const r = o.isCollapsed && o.containsEntireContent(i);
          if (!r) {
            return false;
          }
          if (!e.schema.checkChild(i, "paragraph")) {
            return false;
          }
          const s = i.getChild(0);
          if (s && s.name === "paragraph") {
            return false;
          }
          return true;
        }
        _replaceEntireContentWithParagraph(t) {
          const e = this.editor.model;
          const n = e.document;
          const o = n.selection;
          const i = e.schema.getLimitElement(o);
          const r = t.createElement("paragraph");
          t.remove(t.createRangeIn(i));
          t.insert(r, i);
          t.setSelection(r, 0);
        }
      }
      class kA extends Zd {
        constructor(t) {
          super(t);
          const e = t.document;
          let n = 0;
          e.on("keyup", (t, e) => {
            if (e.keyCode == Fl.delete || e.keyCode == Fl.backspace) {
              n = 0;
            }
          });
          e.on("keydown", (t, e) => {
            const i = {};
            if (e.keyCode == Fl.delete) {
              i.direction = "forward";
              i.unit = "character";
            } else if (e.keyCode == Fl.backspace) {
              i.direction = "backward";
              i.unit = "codePoint";
            } else {
              return;
            }
            const r = El.isMac ? e.altKey : e.ctrlKey;
            i.unit = r ? "word" : i.unit;
            i.sequence = ++n;
            o(t, e.domEvent, i);
          });
          if (El.isAndroid) {
            e.on("beforeinput", (e, n) => {
              if (n.domEvent.inputType != "deleteContentBackward") {
                return;
              }
              const i = {
                unit: "codepoint",
                direction: "backward",
                sequence: 1,
              };
              const r = n.domTarget.ownerDocument.defaultView.getSelection();
              if (
                r.anchorNode == r.focusNode &&
                r.anchorOffset + 1 != r.focusOffset
              ) {
                i.selectionToRemove = t.domConverter.domSelectionToView(r);
              }
              o(e, n.domEvent, i);
            });
          }
          function o(t, n, o) {
            let i;
            e.once("delete", (t) => (i = t), {
              priority: Number.POSITIVE_INFINITY,
            });
            e.fire("delete", new th(e, n, o));
            if (i && i.stop.called) {
              t.stop();
            }
          }
        }
        observe() {}
      }
      class bA extends t_ {
        static get pluginName() {
          return "Delete";
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          e.addObserver(kA);
          t.commands.add("forwardDelete", new mA(t, "forward"));
          t.commands.add("delete", new mA(t, "backward"));
          this.listenTo(n, "delete", (n, o) => {
            const i = { unit: o.unit, sequence: o.sequence };
            if (o.selectionToRemove) {
              const e = t.model.createSelection();
              const n = [];
              for (const e of o.selectionToRemove.getRanges()) {
                n.push(t.editing.mapper.toModelRange(e));
              }
              e.setTo(n);
              i.selection = e;
            }
            t.execute(o.direction == "forward" ? "forwardDelete" : "delete", i);
            o.preventDefault();
            e.scrollToTheSelection();
          });
          if (El.isAndroid) {
            let t = null;
            this.listenTo(
              n,
              "delete",
              (e, n) => {
                const o = n.domTarget.ownerDocument.defaultView.getSelection();
                t = {
                  anchorNode: o.anchorNode,
                  anchorOffset: o.anchorOffset,
                  focusNode: o.focusNode,
                  focusOffset: o.focusOffset,
                };
              },
              { priority: "lowest" }
            );
            this.listenTo(n, "keyup", (e, n) => {
              if (t) {
                const e = n.domTarget.ownerDocument.defaultView.getSelection();
                e.collapse(t.anchorNode, t.anchorOffset);
                e.extend(t.focusNode, t.focusOffset);
                t = null;
              }
            });
          }
        }
      }
      class wA extends t_ {
        static get requires() {
          return [pA, bA];
        }
        static get pluginName() {
          return "Typing";
        }
      }
      const _A = new Map();
      function AA(t, e, n) {
        let o = _A.get(t);
        if (!o) {
          o = new Map();
          _A.set(t, o);
        }
        o.set(e, n);
      }
      function CA(t, e) {
        const n = _A.get(t);
        if (n && n.has(e)) {
          return n.get(e);
        }
        return vA;
      }
      function vA(t) {
        return [t];
      }
      function yA(t, e, n = {}) {
        const o = CA(t.constructor, e.constructor);
        try {
          t = t.clone();
          return o(t, e, n);
        } catch (t) {
          throw t;
        }
      }
      function xA(t, e, n) {
        t = t.slice();
        e = e.slice();
        const o = new EA(n.document, n.useRelations, n.forceWeakRemove);
        o.setOriginalOperations(t);
        o.setOriginalOperations(e);
        const i = o.originalOperations;
        if (t.length == 0 || e.length == 0) {
          return { operationsA: t, operationsB: e, originalOperations: i };
        }
        const r = new WeakMap();
        for (const e of t) {
          r.set(e, 0);
        }
        const s = {
          nextBaseVersionA: t[t.length - 1].baseVersion + 1,
          nextBaseVersionB: e[e.length - 1].baseVersion + 1,
          originalOperationsACount: t.length,
          originalOperationsBCount: e.length,
        };
        let a = 0;
        while (a < t.length) {
          const n = t[a];
          const i = r.get(n);
          if (i == e.length) {
            a++;
            continue;
          }
          const s = e[i];
          const c = yA(n, s, o.getContext(n, s, true));
          const l = yA(s, n, o.getContext(s, n, false));
          o.updateRelation(n, s);
          o.setOriginalOperations(c, n);
          o.setOriginalOperations(l, s);
          for (const t of c) {
            r.set(t, i + l.length);
          }
          t.splice(a, 1, ...c);
          e.splice(i, 1, ...l);
        }
        if (n.padWithNoOps) {
          const n = t.length - s.originalOperationsACount;
          const o = e.length - s.originalOperationsBCount;
          PA(t, o - n);
          PA(e, n - o);
        }
        SA(t, s.nextBaseVersionB);
        SA(e, s.nextBaseVersionA);
        return { operationsA: t, operationsB: e, originalOperations: i };
      }
      class EA {
        constructor(t, e, n = false) {
          this.originalOperations = new Map();
          this._history = t.history;
          this._useRelations = e;
          this._forceWeakRemove = !!n;
          this._relations = new Map();
        }
        setOriginalOperations(t, e = null) {
          const n = e ? this.originalOperations.get(e) : null;
          for (const e of t) {
            this.originalOperations.set(e, n || e);
          }
        }
        updateRelation(t, e) {
          switch (t.constructor) {
            case Cp: {
              switch (e.constructor) {
                case Sp: {
                  if (
                    t.targetPosition.isEqual(e.sourcePosition) ||
                    e.movedRange.containsPosition(t.targetPosition)
                  ) {
                    this._setRelation(t, e, "insertAtSource");
                  } else if (t.targetPosition.isEqual(e.deletionPosition)) {
                    this._setRelation(t, e, "insertBetween");
                  } else if (t.targetPosition.isAfter(e.sourcePosition)) {
                    this._setRelation(t, e, "moveTargetAfter");
                  }
                  break;
                }
                case Cp: {
                  if (
                    t.targetPosition.isEqual(e.sourcePosition) ||
                    t.targetPosition.isBefore(e.sourcePosition)
                  ) {
                    this._setRelation(t, e, "insertBefore");
                  } else {
                    this._setRelation(t, e, "insertAfter");
                  }
                  break;
                }
              }
              break;
            }
            case Pp: {
              switch (e.constructor) {
                case Sp: {
                  if (t.splitPosition.isBefore(e.sourcePosition)) {
                    this._setRelation(t, e, "splitBefore");
                  }
                  break;
                }
                case Cp: {
                  if (
                    t.splitPosition.isEqual(e.sourcePosition) ||
                    t.splitPosition.isBefore(e.sourcePosition)
                  ) {
                    this._setRelation(t, e, "splitBefore");
                  }
                  break;
                }
              }
              break;
            }
            case Sp: {
              switch (e.constructor) {
                case Sp: {
                  if (!t.targetPosition.isEqual(e.sourcePosition)) {
                    this._setRelation(t, e, "mergeTargetNotMoved");
                  }
                  if (t.sourcePosition.isEqual(e.targetPosition)) {
                    this._setRelation(t, e, "mergeSourceNotMoved");
                  }
                  if (t.sourcePosition.isEqual(e.sourcePosition)) {
                    this._setRelation(t, e, "mergeSameElement");
                  }
                  break;
                }
                case Pp: {
                  if (t.sourcePosition.isEqual(e.splitPosition)) {
                    this._setRelation(t, e, "splitAtSource");
                  }
                }
              }
              break;
            }
            case yp: {
              const n = t.newRange;
              if (!n) {
                return;
              }
              switch (e.constructor) {
                case Cp: {
                  const o = tf._createFromPositionAndShift(
                    e.sourcePosition,
                    e.howMany
                  );
                  const i =
                    o.containsPosition(n.start) || o.start.isEqual(n.start);
                  const r = o.containsPosition(n.end) || o.end.isEqual(n.end);
                  if ((i || r) && !o.containsRange(n)) {
                    this._setRelation(t, e, {
                      side: i ? "left" : "right",
                      path: i ? n.start.path.slice() : n.end.path.slice(),
                    });
                  }
                  break;
                }
                case Sp: {
                  const o = n.start.isEqual(e.targetPosition);
                  const i = n.start.isEqual(e.deletionPosition);
                  const r = n.end.isEqual(e.deletionPosition);
                  const s = n.end.isEqual(e.sourcePosition);
                  if (o || i || r || s) {
                    this._setRelation(t, e, {
                      wasInLeftElement: o,
                      wasStartBeforeMergedElement: i,
                      wasEndBeforeMergedElement: r,
                      wasInRightElement: s,
                    });
                  }
                  break;
                }
              }
              break;
            }
          }
        }
        getContext(t, e, n) {
          return {
            aIsStrong: n,
            aWasUndone: this._wasUndone(t),
            bWasUndone: this._wasUndone(e),
            abRelation: this._useRelations ? this._getRelation(t, e) : null,
            baRelation: this._useRelations ? this._getRelation(e, t) : null,
            forceWeakRemove: this._forceWeakRemove,
          };
        }
        _wasUndone(t) {
          const e = this.originalOperations.get(t);
          return e.wasUndone || this._history.isUndoneOperation(e);
        }
        _getRelation(t, e) {
          const n = this.originalOperations.get(e);
          const o = this._history.getUndoneOperation(n);
          if (!o) {
            return null;
          }
          const i = this.originalOperations.get(t);
          const r = this._relations.get(i);
          if (r) {
            return r.get(o) || null;
          }
          return null;
        }
        _setRelation(t, e, n) {
          const o = this.originalOperations.get(t);
          const i = this.originalOperations.get(e);
          let r = this._relations.get(o);
          if (!r) {
            r = new Map();
            this._relations.set(o, r);
          }
          r.set(i, n);
        }
      }
      function SA(t, e) {
        for (const n of t) {
          n.baseVersion = e++;
        }
      }
      function PA(t, e) {
        for (let n = 0; n < e; n++) {
          t.push(new Qp(0));
        }
      }
      AA(_p, _p, (t, e, n) => {
        if (t.key === e.key && t.range.start.hasSameParentAs(e.range.start)) {
          const o = t.range
            .getDifference(e.range)
            .map((e) => new _p(e, t.key, t.oldValue, t.newValue, 0));
          const i = t.range.getIntersection(e.range);
          if (i) {
            if (n.aIsStrong) {
              o.push(new _p(i, e.key, e.newValue, t.newValue, 0));
            }
          }
          if (o.length == 0) {
            return [new Qp(0)];
          }
          return o;
        } else {
          return [t];
        }
      });
      AA(_p, vp, (t, e) => {
        if (
          t.range.start.hasSameParentAs(e.position) &&
          t.range.containsPosition(e.position)
        ) {
          const n = t.range._getTransformedByInsertion(
            e.position,
            e.howMany,
            !e.shouldReceiveAttributes
          );
          const o = n.map(
            (e) => new _p(e, t.key, t.oldValue, t.newValue, t.baseVersion)
          );
          if (e.shouldReceiveAttributes) {
            const n = DA(e, t.key, t.oldValue);
            if (n) {
              o.unshift(n);
            }
          }
          return o;
        }
        t.range = t.range._getTransformedByInsertion(
          e.position,
          e.howMany,
          false
        )[0];
        return [t];
      });
      function DA(t, e, n) {
        const o = t.nodes;
        const i = o.getNode(0).getAttribute(e);
        if (i == n) {
          return null;
        }
        const r = new tf(t.position, t.position.getShiftedBy(t.howMany));
        return new _p(r, e, i, n, 0);
      }
      AA(_p, Sp, (t, e) => {
        const n = [];
        if (t.range.start.hasSameParentAs(e.deletionPosition)) {
          if (
            t.range.containsPosition(e.deletionPosition) ||
            t.range.start.isEqual(e.deletionPosition)
          ) {
            n.push(tf._createFromPositionAndShift(e.graveyardPosition, 1));
          }
        }
        const o = t.range._getTransformedByMergeOperation(e);
        if (!o.isCollapsed) {
          n.push(o);
        }
        return n.map(
          (e) => new _p(e, t.key, t.oldValue, t.newValue, t.baseVersion)
        );
      });
      AA(_p, Cp, (t, e) => {
        const n = TA(t.range, e);
        return n.map(
          (e) => new _p(e, t.key, t.oldValue, t.newValue, t.baseVersion)
        );
      });
      function TA(t, e) {
        const n = tf._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let o = null;
        let i = [];
        if (n.containsRange(t, true)) {
          o = t;
        } else if (t.start.hasSameParentAs(n.start)) {
          i = t.getDifference(n);
          o = t.getIntersection(n);
        } else {
          i = [t];
        }
        const r = [];
        for (let t of i) {
          t = t._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const n = e.getMovedRangeStart();
          const o = t.start.hasSameParentAs(n);
          t = t._getTransformedByInsertion(n, e.howMany, o);
          r.push(...t);
        }
        if (o) {
          r.push(
            o._getTransformedByMove(
              e.sourcePosition,
              e.targetPosition,
              e.howMany,
              false
            )[0]
          );
        }
        return r;
      }
      AA(_p, Pp, (t, e) => {
        if (t.range.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.range.end.offset++;
          }
          return [t];
        }
        if (
          t.range.start.hasSameParentAs(e.splitPosition) &&
          t.range.containsPosition(e.splitPosition)
        ) {
          const n = t.clone();
          n.range = new tf(
            e.moveTargetPosition.clone(),
            t.range.end._getCombined(e.splitPosition, e.moveTargetPosition)
          );
          t.range.end = e.splitPosition.clone();
          t.range.end.stickiness = "toPrevious";
          return [t, n];
        }
        t.range = t.range._getTransformedBySplitOperation(e);
        return [t];
      });
      AA(vp, _p, (t, e) => {
        const n = [t];
        if (
          t.shouldReceiveAttributes &&
          t.position.hasSameParentAs(e.range.start) &&
          e.range.containsPosition(t.position)
        ) {
          const o = DA(t, e.key, e.newValue);
          if (o) {
            n.push(o);
          }
        }
        return n;
      });
      AA(vp, vp, (t, e, n) => {
        if (t.position.isEqual(e.position) && n.aIsStrong) {
          return [t];
        }
        t.position = t.position._getTransformedByInsertOperation(e);
        return [t];
      });
      AA(vp, Cp, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e);
        return [t];
      });
      AA(vp, Pp, (t, e) => {
        t.position = t.position._getTransformedBySplitOperation(e);
        return [t];
      });
      AA(vp, Sp, (t, e) => {
        t.position = t.position._getTransformedByMergeOperation(e);
        return [t];
      });
      AA(yp, vp, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByInsertOperation(e)[0];
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByInsertOperation(e)[0];
        }
        return [t];
      });
      AA(yp, yp, (t, e, n) => {
        if (t.name == e.name) {
          if (n.aIsStrong) {
            t.oldRange = e.newRange ? e.newRange.clone() : null;
          } else {
            return [new Qp(0)];
          }
        }
        return [t];
      });
      AA(yp, Sp, (t, e) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedByMergeOperation(e);
        }
        if (t.newRange) {
          t.newRange = t.newRange._getTransformedByMergeOperation(e);
        }
        return [t];
      });
      AA(yp, Cp, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = tf._createFromRanges(
            t.oldRange._getTransformedByMoveOperation(e)
          );
        }
        if (t.newRange) {
          if (n.abRelation) {
            const o = tf._createFromRanges(
              t.newRange._getTransformedByMoveOperation(e)
            );
            if (
              n.abRelation.side == "left" &&
              e.targetPosition.isEqual(t.newRange.start)
            ) {
              t.newRange.start.path = n.abRelation.path;
              t.newRange.end = o.end;
              return [t];
            } else if (
              n.abRelation.side == "right" &&
              e.targetPosition.isEqual(t.newRange.end)
            ) {
              t.newRange.start = o.start;
              t.newRange.end.path = n.abRelation.path;
              return [t];
            }
          }
          t.newRange = tf._createFromRanges(
            t.newRange._getTransformedByMoveOperation(e)
          );
        }
        return [t];
      });
      AA(yp, Pp, (t, e, n) => {
        if (t.oldRange) {
          t.oldRange = t.oldRange._getTransformedBySplitOperation(e);
        }
        if (t.newRange) {
          if (n.abRelation) {
            const o = t.newRange._getTransformedBySplitOperation(e);
            if (
              t.newRange.start.isEqual(e.splitPosition) &&
              n.abRelation.wasStartBeforeMergedElement
            ) {
              t.newRange.start = Yh._createAt(e.insertionPosition);
            } else if (
              t.newRange.start.isEqual(e.splitPosition) &&
              !n.abRelation.wasInLeftElement
            ) {
              t.newRange.start = Yh._createAt(e.moveTargetPosition);
            }
            if (
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasInRightElement
            ) {
              t.newRange.end = Yh._createAt(e.moveTargetPosition);
            } else if (
              t.newRange.end.isEqual(e.splitPosition) &&
              n.abRelation.wasEndBeforeMergedElement
            ) {
              t.newRange.end = Yh._createAt(e.insertionPosition);
            } else {
              t.newRange.end = o.end;
            }
            return [t];
          }
          t.newRange = t.newRange._getTransformedBySplitOperation(e);
        }
        return [t];
      });
      AA(Sp, vp, (t, e) => {
        if (t.sourcePosition.hasSameParentAs(e.position)) {
          t.howMany += e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByInsertOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByInsertOperation(e);
        return [t];
      });
      AA(Sp, Sp, (t, e, n) => {
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          t.targetPosition.isEqual(e.targetPosition)
        ) {
          if (!n.bWasUndone) {
            return [new Qp(0)];
          } else {
            const n = e.graveyardPosition.path.slice();
            n.push(0);
            t.sourcePosition = new Yh(e.graveyardPosition.root, n);
            t.howMany = 0;
            return [t];
          }
        }
        if (
          t.sourcePosition.isEqual(e.sourcePosition) &&
          !t.targetPosition.isEqual(e.targetPosition) &&
          !n.bWasUndone &&
          n.abRelation != "splitAtSource"
        ) {
          const o = t.targetPosition.root.rootName == "$graveyard";
          const i = e.targetPosition.root.rootName == "$graveyard";
          const r = o && !i;
          const s = i && !o;
          const a = s || (!r && n.aIsStrong);
          if (a) {
            const n = e.targetPosition._getTransformedByMergeOperation(e);
            const o = t.targetPosition._getTransformedByMergeOperation(e);
            return [new Cp(n, t.howMany, o, 0)];
          } else {
            return [new Qp(0)];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMergeOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
        if (!t.graveyardPosition.isEqual(e.graveyardPosition) || !n.aIsStrong) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(
            e
          );
        }
        return [t];
      });
      AA(Sp, Cp, (t, e, n) => {
        const o = tf._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (e.type == "remove" && !n.bWasUndone && !n.forceWeakRemove) {
          if (
            t.deletionPosition.hasSameParentAs(e.sourcePosition) &&
            o.containsPosition(t.sourcePosition)
          ) {
            return [new Qp(0)];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        if (t.sourcePosition.hasSameParentAs(e.sourcePosition)) {
          t.howMany -= e.howMany;
        }
        t.sourcePosition = t.sourcePosition._getTransformedByMoveOperation(e);
        t.targetPosition = t.targetPosition._getTransformedByMoveOperation(e);
        if (!t.graveyardPosition.isEqual(e.targetPosition)) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(
            e
          );
        }
        return [t];
      });
      AA(Sp, Pp, (t, e, n) => {
        if (e.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByDeletion(
            e.graveyardPosition,
            1
          );
          if (t.deletionPosition.isEqual(e.graveyardPosition)) {
            t.howMany = e.howMany;
          }
        }
        if (t.targetPosition.isEqual(e.splitPosition)) {
          const o = e.howMany != 0;
          const i =
            e.graveyardPosition &&
            t.deletionPosition.isEqual(e.graveyardPosition);
          if (o || i || n.abRelation == "mergeTargetNotMoved") {
            t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(
              e
            );
            return [t];
          }
        }
        if (t.sourcePosition.isEqual(e.splitPosition)) {
          if (n.abRelation == "mergeSourceNotMoved") {
            t.howMany = 0;
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(
              e
            );
            return [t];
          }
          if (
            n.abRelation == "mergeSameElement" ||
            t.sourcePosition.offset > 0
          ) {
            t.sourcePosition = e.moveTargetPosition.clone();
            t.targetPosition = t.targetPosition._getTransformedBySplitOperation(
              e
            );
            return [t];
          }
        }
        if (t.sourcePosition.hasSameParentAs(e.splitPosition)) {
          t.howMany = e.splitPosition.offset;
        }
        t.sourcePosition = t.sourcePosition._getTransformedBySplitOperation(e);
        t.targetPosition = t.targetPosition._getTransformedBySplitOperation(e);
        return [t];
      });
      AA(Cp, vp, (t, e) => {
        const n = tf._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const o = n._getTransformedByInsertOperation(e, false)[0];
        t.sourcePosition = o.start;
        t.howMany = o.end.offset - o.start.offset;
        if (!t.targetPosition.isEqual(e.position)) {
          t.targetPosition = t.targetPosition._getTransformedByInsertOperation(
            e
          );
        }
        return [t];
      });
      AA(Cp, Cp, (t, e, n) => {
        const o = tf._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const i = tf._createFromPositionAndShift(e.sourcePosition, e.howMany);
        let r = n.aIsStrong;
        let s = !n.aIsStrong;
        if (n.abRelation == "insertBefore" || n.baRelation == "insertAfter") {
          s = true;
        } else if (
          n.abRelation == "insertAfter" ||
          n.baRelation == "insertBefore"
        ) {
          s = false;
        }
        let a;
        if (t.targetPosition.isEqual(e.targetPosition) && s) {
          a = t.targetPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
        } else {
          a = t.targetPosition._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
        }
        if (BA(t, e) && BA(e, t)) {
          return [e.getReversed()];
        }
        const c = o.containsPosition(e.targetPosition);
        if (c && o.containsRange(i, true)) {
          o.start = o.start._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          o.end = o.end._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          return IA([o], a);
        }
        const l = i.containsPosition(t.targetPosition);
        if (l && i.containsRange(o, true)) {
          o.start = o.start._getCombined(
            e.sourcePosition,
            e.getMovedRangeStart()
          );
          o.end = o.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
          return IA([o], a);
        }
        const d = Fs(
          t.sourcePosition.getParentPath(),
          e.sourcePosition.getParentPath()
        );
        if (d == "prefix" || d == "extension") {
          o.start = o.start._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          o.end = o.end._getTransformedByMove(
            e.sourcePosition,
            e.targetPosition,
            e.howMany
          );
          return IA([o], a);
        }
        if (
          t.type == "remove" &&
          e.type != "remove" &&
          !n.aWasUndone &&
          !n.forceWeakRemove
        ) {
          r = true;
        } else if (
          t.type != "remove" &&
          e.type == "remove" &&
          !n.bWasUndone &&
          !n.forceWeakRemove
        ) {
          r = false;
        }
        const u = [];
        const h = o.getDifference(i);
        for (const t of h) {
          t.start = t.start._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
          t.end = t.end._getTransformedByDeletion(e.sourcePosition, e.howMany);
          const n =
            Fs(
              t.start.getParentPath(),
              e.getMovedRangeStart().getParentPath()
            ) == "same";
          const o = t._getTransformedByInsertion(
            e.getMovedRangeStart(),
            e.howMany,
            n
          );
          u.push(...o);
        }
        const f = o.getIntersection(i);
        if (f !== null && r) {
          f.start = f.start._getCombined(
            e.sourcePosition,
            e.getMovedRangeStart()
          );
          f.end = f.end._getCombined(e.sourcePosition, e.getMovedRangeStart());
          if (u.length === 0) {
            u.push(f);
          } else if (u.length == 1) {
            if (i.start.isBefore(o.start) || i.start.isEqual(o.start)) {
              u.unshift(f);
            } else {
              u.push(f);
            }
          } else {
            u.splice(1, 0, f);
          }
        }
        if (u.length === 0) {
          return [new Qp(t.baseVersion)];
        }
        return IA(u, a);
      });
      AA(Cp, Pp, (t, e, n) => {
        let o = t.targetPosition.clone();
        if (
          !t.targetPosition.isEqual(e.insertionPosition) ||
          !e.graveyardPosition ||
          n.abRelation == "moveTargetAfter"
        ) {
          o = t.targetPosition._getTransformedBySplitOperation(e);
        }
        const i = tf._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (i.end.isEqual(e.insertionPosition)) {
          if (!e.graveyardPosition) {
            t.howMany++;
          }
          t.targetPosition = o;
          return [t];
        }
        if (
          i.start.hasSameParentAs(e.splitPosition) &&
          i.containsPosition(e.splitPosition)
        ) {
          let t = new tf(e.splitPosition, i.end);
          t = t._getTransformedBySplitOperation(e);
          const n = [new tf(i.start, e.splitPosition), t];
          return IA(n, o);
        }
        if (
          t.targetPosition.isEqual(e.splitPosition) &&
          n.abRelation == "insertAtSource"
        ) {
          o = e.moveTargetPosition;
        }
        if (
          t.targetPosition.isEqual(e.insertionPosition) &&
          n.abRelation == "insertBetween"
        ) {
          o = t.targetPosition;
        }
        const r = i._getTransformedBySplitOperation(e);
        const s = [r];
        if (e.graveyardPosition) {
          const o =
            i.start.isEqual(e.graveyardPosition) ||
            i.containsPosition(e.graveyardPosition);
          if (t.howMany > 1 && o && !n.aWasUndone) {
            s.push(tf._createFromPositionAndShift(e.insertionPosition, 1));
          }
        }
        return IA(s, o);
      });
      AA(Cp, Sp, (t, e, n) => {
        const o = tf._createFromPositionAndShift(t.sourcePosition, t.howMany);
        if (
          e.deletionPosition.hasSameParentAs(t.sourcePosition) &&
          o.containsPosition(e.sourcePosition)
        ) {
          if (t.type == "remove" && !n.forceWeakRemove) {
            if (!n.aWasUndone) {
              const n = [];
              let o = e.graveyardPosition.clone();
              let i = e.targetPosition._getTransformedByMergeOperation(e);
              if (t.howMany > 1) {
                n.push(
                  new Cp(t.sourcePosition, t.howMany - 1, t.targetPosition, 0)
                );
                o = o._getTransformedByMove(
                  t.sourcePosition,
                  t.targetPosition,
                  t.howMany - 1
                );
                i = i._getTransformedByMove(
                  t.sourcePosition,
                  t.targetPosition,
                  t.howMany - 1
                );
              }
              const r = e.deletionPosition._getCombined(
                t.sourcePosition,
                t.targetPosition
              );
              const s = new Cp(o, 1, r, 0);
              const a = s.getMovedRangeStart().path.slice();
              a.push(0);
              const c = new Yh(s.targetPosition.root, a);
              i = i._getTransformedByMove(o, r, 1);
              const l = new Cp(i, e.howMany, c, 0);
              n.push(s);
              n.push(l);
              return n;
            }
          } else {
            if (t.howMany == 1) {
              if (!n.bWasUndone) {
                return [new Qp(0)];
              } else {
                t.sourcePosition = e.graveyardPosition.clone();
                t.targetPosition = t.targetPosition._getTransformedByMergeOperation(
                  e
                );
                return [t];
              }
            }
          }
        }
        const i = tf._createFromPositionAndShift(t.sourcePosition, t.howMany);
        const r = i._getTransformedByMergeOperation(e);
        t.sourcePosition = r.start;
        t.howMany = r.end.offset - r.start.offset;
        t.targetPosition = t.targetPosition._getTransformedByMergeOperation(e);
        return [t];
      });
      AA(xp, vp, (t, e) => {
        t.position = t.position._getTransformedByInsertOperation(e);
        return [t];
      });
      AA(xp, Sp, (t, e) => {
        if (t.position.isEqual(e.deletionPosition)) {
          t.position = e.graveyardPosition.clone();
          t.position.stickiness = "toNext";
          return [t];
        }
        t.position = t.position._getTransformedByMergeOperation(e);
        return [t];
      });
      AA(xp, Cp, (t, e) => {
        t.position = t.position._getTransformedByMoveOperation(e);
        return [t];
      });
      AA(xp, xp, (t, e, n) => {
        if (t.position.isEqual(e.position)) {
          if (n.aIsStrong) {
            t.oldName = e.newName;
          } else {
            return [new Qp(0)];
          }
        }
        return [t];
      });
      AA(xp, Pp, (t, e) => {
        const n = t.position.path;
        const o = e.splitPosition.getParentPath();
        if (Fs(n, o) == "same" && !e.graveyardPosition) {
          const e = new xp(t.position.getShiftedBy(1), t.oldName, t.newName, 0);
          return [t, e];
        }
        t.position = t.position._getTransformedBySplitOperation(e);
        return [t];
      });
      AA(Ep, Ep, (t, e, n) => {
        if (t.root === e.root && t.key === e.key) {
          if (!n.aIsStrong || t.newValue === e.newValue) {
            return [new Qp(0)];
          } else {
            t.oldValue = e.newValue;
          }
        }
        return [t];
      });
      AA(Pp, vp, (t, e) => {
        if (
          t.splitPosition.hasSameParentAs(e.position) &&
          t.splitPosition.offset < e.position.offset
        ) {
          t.howMany += e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedByInsertOperation(e);
        t.insertionPosition = Pp.getInsertionPosition(t.splitPosition);
        return [t];
      });
      AA(Pp, Sp, (t, e, n) => {
        if (
          !t.graveyardPosition &&
          !n.bWasUndone &&
          t.splitPosition.hasSameParentAs(e.sourcePosition)
        ) {
          const n = e.graveyardPosition.path.slice();
          n.push(0);
          const o = new Yh(e.graveyardPosition.root, n);
          const i = Pp.getInsertionPosition(
            new Yh(e.graveyardPosition.root, n)
          );
          const r = new Pp(o, 0, null, 0);
          r.insertionPosition = i;
          t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
          t.insertionPosition = Pp.getInsertionPosition(t.splitPosition);
          t.graveyardPosition = r.insertionPosition.clone();
          t.graveyardPosition.stickiness = "toNext";
          return [r, t];
        }
        if (
          t.splitPosition.hasSameParentAs(e.deletionPosition) &&
          !t.splitPosition.isAfter(e.deletionPosition)
        ) {
          t.howMany--;
        }
        if (t.splitPosition.hasSameParentAs(e.targetPosition)) {
          t.howMany += e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedByMergeOperation(e);
        t.insertionPosition = Pp.getInsertionPosition(t.splitPosition);
        if (t.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedByMergeOperation(
            e
          );
        }
        return [t];
      });
      AA(Pp, Cp, (t, e, n) => {
        const o = tf._createFromPositionAndShift(e.sourcePosition, e.howMany);
        if (t.graveyardPosition) {
          const i =
            o.start.isEqual(t.graveyardPosition) ||
            o.containsPosition(t.graveyardPosition);
          if (!n.bWasUndone && i) {
            const n = t.splitPosition._getTransformedByMoveOperation(e);
            const o = t.graveyardPosition._getTransformedByMoveOperation(e);
            const i = o.path.slice();
            i.push(0);
            const r = new Yh(o.root, i);
            const s = new Cp(n, t.howMany, r, 0);
            return [s];
          }
          t.graveyardPosition = t.graveyardPosition._getTransformedByMoveOperation(
            e
          );
        }
        if (
          t.splitPosition.hasSameParentAs(e.sourcePosition) &&
          o.containsPosition(t.splitPosition)
        ) {
          const n =
            e.howMany - (t.splitPosition.offset - e.sourcePosition.offset);
          t.howMany -= n;
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany;
          }
          t.splitPosition = e.sourcePosition.clone();
          t.insertionPosition = Pp.getInsertionPosition(t.splitPosition);
          return [t];
        }
        const i = t.splitPosition.isEqual(e.targetPosition);
        if (
          i &&
          (n.baRelation == "insertAtSource" || n.abRelation == "splitBefore")
        ) {
          t.howMany += e.howMany;
          t.splitPosition = t.splitPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          );
          t.insertionPosition = Pp.getInsertionPosition(t.splitPosition);
          return [t];
        }
        if (!e.sourcePosition.isEqual(e.targetPosition)) {
          if (
            t.splitPosition.hasSameParentAs(e.sourcePosition) &&
            t.splitPosition.offset <= e.sourcePosition.offset
          ) {
            t.howMany -= e.howMany;
          }
          if (
            t.splitPosition.hasSameParentAs(e.targetPosition) &&
            t.splitPosition.offset < e.targetPosition.offset
          ) {
            t.howMany += e.howMany;
          }
        }
        t.splitPosition.stickiness = "toNone";
        t.splitPosition = t.splitPosition._getTransformedByMoveOperation(e);
        t.splitPosition.stickiness = "toNext";
        if (t.graveyardPosition) {
          t.insertionPosition = t.insertionPosition._getTransformedByMoveOperation(
            e
          );
        } else {
          t.insertionPosition = Pp.getInsertionPosition(t.splitPosition);
        }
        return [t];
      });
      AA(Pp, Pp, (t, e, n) => {
        if (t.splitPosition.isEqual(e.splitPosition)) {
          if (!t.graveyardPosition && !e.graveyardPosition) {
            return [new Qp(0)];
          }
          if (
            t.graveyardPosition &&
            e.graveyardPosition &&
            t.graveyardPosition.isEqual(e.graveyardPosition)
          ) {
            return [new Qp(0)];
          }
          if (n.abRelation == "splitBefore") {
            t.howMany = 0;
            t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(
              e
            );
            return [t];
          }
        }
        if (
          t.graveyardPosition &&
          e.graveyardPosition &&
          t.graveyardPosition.isEqual(e.graveyardPosition)
        ) {
          const o = t.splitPosition.root.rootName == "$graveyard";
          const i = e.splitPosition.root.rootName == "$graveyard";
          const r = o && !i;
          const s = i && !o;
          const a = s || (!r && n.aIsStrong);
          if (a) {
            const n = [];
            if (e.howMany) {
              n.push(
                new Cp(e.moveTargetPosition, e.howMany, e.splitPosition, 0)
              );
            }
            if (t.howMany) {
              n.push(
                new Cp(t.splitPosition, t.howMany, t.moveTargetPosition, 0)
              );
            }
            return n;
          } else {
            return [new Qp(0)];
          }
        }
        if (t.graveyardPosition) {
          t.graveyardPosition = t.graveyardPosition._getTransformedBySplitOperation(
            e
          );
        }
        if (
          t.splitPosition.isEqual(e.insertionPosition) &&
          n.abRelation == "splitBefore"
        ) {
          t.howMany++;
          return [t];
        }
        if (
          e.splitPosition.isEqual(t.insertionPosition) &&
          n.baRelation == "splitBefore"
        ) {
          const n = e.insertionPosition.path.slice();
          n.push(0);
          const o = new Yh(e.insertionPosition.root, n);
          const i = new Cp(t.insertionPosition, 1, o, 0);
          return [t, i];
        }
        if (
          t.splitPosition.hasSameParentAs(e.splitPosition) &&
          t.splitPosition.offset < e.splitPosition.offset
        ) {
          t.howMany -= e.howMany;
        }
        t.splitPosition = t.splitPosition._getTransformedBySplitOperation(e);
        t.insertionPosition = Pp.getInsertionPosition(t.splitPosition);
        return [t];
      });
      function BA(t, e) {
        return (
          t.targetPosition._getTransformedByDeletion(
            e.sourcePosition,
            e.howMany
          ) === null
        );
      }
      function IA(t, e) {
        const n = [];
        for (let o = 0; o < t.length; o++) {
          const i = t[o];
          const r = new Cp(i.start, i.end.offset - i.start.offset, e, 0);
          n.push(r);
          for (let e = o + 1; e < t.length; e++) {
            t[e] = t[e]._getTransformedByMove(
              r.sourcePosition,
              r.targetPosition,
              r.howMany
            )[0];
          }
          e = e._getTransformedByMove(
            r.sourcePosition,
            r.targetPosition,
            r.howMany
          );
        }
        return n;
      }
      class OA extends i_ {
        constructor(t) {
          super(t);
          this._stack = [];
          this._createdBatches = new WeakSet();
          this.refresh();
          this.listenTo(t.data, "set", () => this.clearStack());
        }
        refresh() {
          this.isEnabled = this._stack.length > 0;
        }
        addBatch(t) {
          const e = this.editor.model.document.selection;
          const n = {
            ranges: e.hasOwnRange ? Array.from(e.getRanges()) : [],
            isBackward: e.isBackward,
          };
          this._stack.push({ batch: t, selection: n });
          this.refresh();
        }
        clearStack() {
          this._stack = [];
          this.refresh();
        }
        _restoreSelection(t, e, n) {
          const o = this.editor.model;
          const i = o.document;
          const r = [];
          const s = t.map((t) => t.getTransformedByOperations(n));
          const a = s.flat();
          for (const t of s) {
            const e = t.filter((t) => !FA(t, a));
            RA(e);
            const n = e.find((t) => t.root != i.graveyard);
            if (n) {
              r.push(n);
            }
          }
          if (r.length) {
            o.change((t) => {
              t.setSelection(r, { backward: e });
            });
          }
        }
        _undo(t, e) {
          const n = this.editor.model;
          const o = n.document;
          this._createdBatches.add(e);
          const i = t.operations.slice().filter((t) => t.isDocumentOperation);
          i.reverse();
          for (const t of i) {
            const i = t.baseVersion + 1;
            const r = Array.from(o.history.getOperations(i));
            const s = xA([t.getReversed()], r, {
              useRelations: true,
              document: this.editor.model.document,
              padWithNoOps: false,
              forceWeakRemove: true,
            });
            const a = s.operationsA;
            for (const i of a) {
              e.addOperation(i);
              n.applyOperation(i);
              o.history.setOperationAsUndone(t, i);
            }
          }
        }
      }
      function RA(t) {
        t.sort((t, e) => (t.start.isBefore(e.start) ? -1 : 1));
        for (let e = 1; e < t.length; e++) {
          const n = t[e - 1];
          const o = n.getJoined(t[e], true);
          if (o) {
            e--;
            t.splice(e, 2, o);
          }
        }
      }
      function FA(t, e) {
        return e.some((e) => e !== t && e.containsRange(t, true));
      }
      class NA extends OA {
        execute(t = null) {
          const e = t
            ? this._stack.findIndex((e) => e.batch == t)
            : this._stack.length - 1;
          const n = this._stack.splice(e, 1)[0];
          const o = this.editor.model.createBatch("transparent");
          this.editor.model.enqueueChange(o, () => {
            this._undo(n.batch, o);
            const t = this.editor.model.document.history.getOperations(
              n.batch.baseVersion
            );
            this._restoreSelection(
              n.selection.ranges,
              n.selection.isBackward,
              t
            );
            this.fire("revert", n.batch, o);
          });
          this.refresh();
        }
      }
      class MA extends OA {
        execute() {
          const t = this._stack.pop();
          const e = this.editor.model.createBatch("transparent");
          this.editor.model.enqueueChange(e, () => {
            const n = t.batch.operations[t.batch.operations.length - 1];
            const o = n.baseVersion + 1;
            const i = this.editor.model.document.history.getOperations(o);
            this._restoreSelection(
              t.selection.ranges,
              t.selection.isBackward,
              i
            );
            this._undo(t.batch, e);
          });
          this.refresh();
        }
      }
      class VA extends t_ {
        static get pluginName() {
          return "UndoEditing";
        }
        constructor(t) {
          super(t);
          this._batchRegistry = new WeakSet();
        }
        init() {
          const t = this.editor;
          this._undoCommand = new NA(t);
          this._redoCommand = new MA(t);
          t.commands.add("undo", this._undoCommand);
          t.commands.add("redo", this._redoCommand);
          this.listenTo(
            t.model,
            "applyOperation",
            (t, e) => {
              const n = e[0];
              if (!n.isDocumentOperation) {
                return;
              }
              const o = n.batch;
              const i = this._redoCommand._createdBatches.has(o);
              const r = this._undoCommand._createdBatches.has(o);
              const s = this._batchRegistry.has(o);
              if (s || (o.type == "transparent" && !i && !r)) {
                return;
              } else {
                if (i) {
                  this._undoCommand.addBatch(o);
                } else if (!r) {
                  this._undoCommand.addBatch(o);
                  this._redoCommand.clearStack();
                }
              }
              this._batchRegistry.add(o);
            },
            { priority: "highest" }
          );
          this.listenTo(this._undoCommand, "revert", (t, e, n) => {
            this._redoCommand.addBatch(n);
          });
          t.keystrokes.set("CTRL+Z", "undo");
          t.keystrokes.set("CTRL+Y", "redo");
          t.keystrokes.set("CTRL+SHIFT+Z", "redo");
        }
      }
      var LA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.042 9.367l2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>';
      var zA =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M14.958 9.367l-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
      class jA extends t_ {
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = t.t;
          const o = e.uiLanguageDirection == "ltr" ? LA : zA;
          const i = e.uiLanguageDirection == "ltr" ? zA : LA;
          this._addButton("undo", n("Undo"), "CTRL+Z", o);
          this._addButton("redo", n("Redo"), "CTRL+Y", i);
        }
        _addButton(t, e, n, o) {
          const i = this.editor;
          i.ui.componentFactory.add(t, (r) => {
            const s = i.commands.get(t);
            const a = new ow(r);
            a.set({ label: e, icon: o, keystroke: n, tooltip: true });
            a.bind("isEnabled").to(s, "isEnabled");
            this.listenTo(a, "execute", () => {
              i.execute(t);
              i.editing.view.focus();
            });
            return a;
          });
        }
      }
      class KA extends t_ {
        static get requires() {
          return [VA, jA];
        }
        static get pluginName() {
          return "Undo";
        }
      }
      class qA extends t_ {
        static get requires() {
          return [R_, j_, tA, U_, wA, KA];
        }
        static get pluginName() {
          return "Essentials";
        }
      }
      class $A extends i_ {
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          const n = Jw(e.selection.getSelectedBlocks());
          this.value = !!n && n.is("element", "paragraph");
          this.isEnabled = !!n && WA(n, t.schema);
        }
        execute(t = {}) {
          const e = this.editor.model;
          const n = e.document;
          e.change((o) => {
            const i = (t.selection || n.selection).getSelectedBlocks();
            for (const t of i) {
              if (!t.is("element", "paragraph") && WA(t, e.schema)) {
                o.rename(t, "paragraph");
              }
            }
          });
        }
      }
      function WA(t, e) {
        return e.checkChild(t.parent, "paragraph") && !e.isObject(t);
      }
      class GA extends i_ {
        execute(t) {
          const e = this.editor.model;
          let n = t.position;
          e.change((t) => {
            const o = t.createElement("paragraph");
            if (!e.schema.checkChild(n.parent, o)) {
              const i = e.schema.findAllowedParent(n, o);
              if (!i) {
                return;
              }
              n = t.split(n, i).position;
            }
            e.insertContent(o, n);
            t.setSelection(o, "in");
          });
        }
      }
      class UA extends t_ {
        static get pluginName() {
          return "Paragraph";
        }
        init() {
          const t = this.editor;
          const e = t.model;
          t.commands.add("paragraph", new $A(t));
          t.commands.add("insertParagraph", new GA(t));
          e.schema.register("paragraph", { inheritAllFrom: "$block" });
          t.conversion.elementToElement({ model: "paragraph", view: "p" });
          t.conversion.for("upcast").elementToElement({
            model: (t, { writer: e }) => {
              if (!UA.paragraphLikeElements.has(t.name)) {
                return null;
              }
              if (t.isEmpty) {
                return null;
              }
              return e.createElement("paragraph");
            },
            view: /.+/,
            converterPriority: "low",
          });
        }
      }
      UA.paragraphLikeElements = new Set([
        "blockquote",
        "dd",
        "div",
        "dt",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "li",
        "p",
        "td",
        "th",
      ]);
      class HA extends i_ {
        constructor(t, e) {
          super(t);
          this.modelElements = e;
        }
        refresh() {
          const t = Jw(
            this.editor.model.document.selection.getSelectedBlocks()
          );
          this.value = !!t && this.modelElements.includes(t.name) && t.name;
          this.isEnabled =
            !!t &&
            this.modelElements.some((e) => JA(t, e, this.editor.model.schema));
        }
        execute(t) {
          const e = this.editor.model;
          const n = e.document;
          const o = t.value;
          e.change((t) => {
            const i = Array.from(n.selection.getSelectedBlocks()).filter((t) =>
              JA(t, o, e.schema)
            );
            for (const e of i) {
              if (!e.is("element", o)) {
                t.rename(e, o);
              }
            }
          });
        }
      }
      function JA(t, e, n) {
        return n.checkChild(t.parent, e) && !n.isObject(t);
      }
      const YA = "paragraph";
      class QA extends t_ {
        static get pluginName() {
          return "HeadingEditing";
        }
        constructor(t) {
          super(t);
          t.config.define("heading", {
            options: [
              {
                model: "paragraph",
                title: "Paragraph",
                class: "ck-heading_paragraph",
              },
              {
                model: "heading1",
                view: "h2",
                title: "Heading 1",
                class: "ck-heading_heading1",
              },
              {
                model: "heading2",
                view: "h3",
                title: "Heading 2",
                class: "ck-heading_heading2",
              },
              {
                model: "heading3",
                view: "h4",
                title: "Heading 3",
                class: "ck-heading_heading3",
              },
            ],
          });
        }
        static get requires() {
          return [UA];
        }
        init() {
          const t = this.editor;
          const e = t.config.get("heading.options");
          const n = [];
          for (const o of e) {
            if (o.model !== YA) {
              t.model.schema.register(o.model, { inheritAllFrom: "$block" });
              t.conversion.elementToElement(o);
              n.push(o.model);
            }
          }
          this._addDefaultH1Conversion(t);
          t.commands.add("heading", new HA(t, n));
        }
        afterInit() {
          const t = this.editor;
          const e = t.commands.get("enter");
          const n = t.config.get("heading.options");
          if (e) {
            this.listenTo(e, "afterExecute", (e, o) => {
              const i = t.model.document.selection.getFirstPosition().parent;
              const r = n.some((t) => i.is("element", t.model));
              if (r && !i.is("element", YA) && i.childCount === 0) {
                o.writer.rename(i, YA);
              }
            });
          }
        }
        _addDefaultH1Conversion(t) {
          t.conversion.for("upcast").elementToElement({
            model: "heading1",
            view: "h1",
            converterPriority: is.get("low") + 1,
          });
        }
      }
      class XA {
        constructor(t, e) {
          if (e) {
            Wc(this, e);
          }
          if (t) {
            this.set(t);
          }
        }
      }
      Cs(XA, Yc);
      function ZA(t) {
        const e = t.t;
        const n = {
          Paragraph: e("Paragraph"),
          "Heading 1": e("Heading 1"),
          "Heading 2": e("Heading 2"),
          "Heading 3": e("Heading 3"),
          "Heading 4": e("Heading 4"),
          "Heading 5": e("Heading 5"),
          "Heading 6": e("Heading 6"),
        };
        return t.config.get("heading.options").map((t) => {
          const e = n[t.title];
          if (e && e != t.title) {
            t.title = e;
          }
          return t;
        });
      }
      var tC = n(26);
      var eC = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      eC.insert = "head";
      eC.singleton = true;
      var nC = ik()(tC["a"], eC);
      var oC = tC["a"].locals || {};
      class iC extends t_ {
        init() {
          const t = this.editor;
          const e = t.t;
          const n = ZA(t);
          const o = e("Choose heading");
          const i = e("Heading");
          t.ui.componentFactory.add("heading", (e) => {
            const r = {};
            const s = new vs();
            const a = t.commands.get("heading");
            const c = t.commands.get("paragraph");
            const l = [a];
            for (const t of n) {
              const e = {
                type: "button",
                model: new XA({
                  label: t.title,
                  class: t.class,
                  withText: true,
                }),
              };
              if (t.model === "paragraph") {
                e.model.bind("isOn").to(c, "value");
                e.model.set("commandName", "paragraph");
                l.push(c);
              } else {
                e.model.bind("isOn").to(a, "value", (e) => e === t.model);
                e.model.set({ commandName: "heading", commandValue: t.model });
              }
              s.add(e);
              r[t.model] = t.title;
            }
            const d = Sw(e);
            Dw(d, s);
            d.buttonView.set({ isOn: false, withText: true, tooltip: i });
            d.extendTemplate({
              attributes: { class: ["ck-heading-dropdown"] },
            });
            d.bind("isEnabled").toMany(l, "isEnabled", (...t) =>
              t.some((t) => t)
            );
            d.buttonView.bind("label").to(a, "value", c, "value", (t, e) => {
              const n = t || (e && "paragraph");
              return r[n] ? r[n] : o;
            });
            this.listenTo(d, "execute", (e) => {
              t.execute(
                e.source.commandName,
                e.source.commandValue
                  ? { value: e.source.commandValue }
                  : undefined
              );
              t.editing.view.focus();
            });
            return d;
          });
        }
      }
      class rC extends t_ {
        static get requires() {
          return [QA, iC];
        }
        static get pluginName() {
          return "Heading";
        }
      }
      class sC extends Zd {
        observe(t) {
          this.listenTo(
            t,
            "load",
            (t, e) => {
              const n = e.target;
              if (this.checkShouldIgnoreEventFromTarget(n)) {
                return;
              }
              if (n.tagName == "IMG") {
                this._fireEvents(e);
              }
            },
            { useCapture: true }
          );
        }
        _fireEvents(t) {
          if (this.isEnabled) {
            this.document.fire("layoutChanged");
            this.document.fire("imageLoaded", t);
          }
        }
      }
      class aC {
        constructor() {
          this._stack = [];
        }
        add(t, e) {
          const n = this._stack;
          const o = n[0];
          this._insertDescriptor(t);
          const i = n[0];
          if (o !== i && !cC(o, i)) {
            this.fire("change:top", {
              oldDescriptor: o,
              newDescriptor: i,
              writer: e,
            });
          }
        }
        remove(t, e) {
          const n = this._stack;
          const o = n[0];
          this._removeDescriptor(t);
          const i = n[0];
          if (o !== i && !cC(o, i)) {
            this.fire("change:top", {
              oldDescriptor: o,
              newDescriptor: i,
              writer: e,
            });
          }
        }
        _insertDescriptor(t) {
          const e = this._stack;
          const n = e.findIndex((e) => e.id === t.id);
          if (cC(t, e[n])) {
            return;
          }
          if (n > -1) {
            e.splice(n, 1);
          }
          let o = 0;
          while (e[o] && lC(e[o], t)) {
            o++;
          }
          e.splice(o, 0, t);
        }
        _removeDescriptor(t) {
          const e = this._stack;
          const n = e.findIndex((e) => e.id === t);
          if (n > -1) {
            e.splice(n, 1);
          }
        }
      }
      Cs(aC, ds);
      function cC(t, e) {
        return (
          t && e && t.priority == e.priority && dC(t.classes) == dC(e.classes)
        );
      }
      function lC(t, e) {
        if (t.priority > e.priority) {
          return true;
        } else if (t.priority < e.priority) {
          return false;
        }
        return dC(t.classes) > dC(e.classes);
      }
      function dC(t) {
        return Array.isArray(t) ? t.sort().join(",") : t;
      }
      var uC =
        '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>';
      const hC = "widget-type-around";
      function fC(t, e, n) {
        return t && _C(t) && !n.isInline(e);
      }
      function gC(t) {
        return t.closest(".ck-widget__type-around__button");
      }
      function pC(t) {
        return t.classList.contains("ck-widget__type-around__button_before")
          ? "before"
          : "after";
      }
      function mC(t, e) {
        const n = t.closest(".ck-widget");
        return e.mapDomToView(n);
      }
      function kC(t) {
        return t.getAttribute(hC);
      }
      const bC = "ck-widget";
      const wC = "ck-widget_selected";
      function _C(t) {
        if (!t.is("element")) {
          return false;
        }
        return !!t.getCustomProperty("widget");
      }
      function AC(t, e, n = {}) {
        if (!t.is("containerElement")) {
          throw new ss["a"]("widget-to-widget-wrong-element-type", null, {
            element: t,
          });
        }
        e.setAttribute("contenteditable", "false", t);
        e.addClass(bC, t);
        e.setCustomProperty("widget", true, t);
        t.getFillerOffset = DC;
        if (n.label) {
          vC(t, n.label, e);
        }
        if (n.hasSelectionHandle) {
          TC(t, e);
        }
        CC(
          t,
          e,
          (t, e, n) => n.addClass(o(e.classes), t),
          (t, e, n) => n.removeClass(o(e.classes), t)
        );
        return t;
        function o(t) {
          return Array.isArray(t) ? t : [t];
        }
      }
      function CC(t, e, n, o) {
        const i = new aC();
        i.on("change:top", (e, i) => {
          if (i.oldDescriptor) {
            o(t, i.oldDescriptor, i.writer);
          }
          if (i.newDescriptor) {
            n(t, i.newDescriptor, i.writer);
          }
        });
        e.setCustomProperty("addHighlight", (t, e, n) => i.add(e, n), t);
        e.setCustomProperty("removeHighlight", (t, e, n) => i.remove(e, n), t);
      }
      function vC(t, e, n) {
        n.setCustomProperty("widgetLabel", e, t);
      }
      function yC(t) {
        const e = t.getCustomProperty("widgetLabel");
        if (!e) {
          return "";
        }
        return typeof e == "function" ? e() : e;
      }
      function xC(t, e) {
        e.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t);
        e.setAttribute("contenteditable", t.isReadOnly ? "false" : "true", t);
        t.on("change:isReadOnly", (n, o, i) => {
          e.setAttribute("contenteditable", i ? "false" : "true", t);
        });
        t.on("change:isFocused", (n, o, i) => {
          if (i) {
            e.addClass("ck-editor__nested-editable_focused", t);
          } else {
            e.removeClass("ck-editor__nested-editable_focused", t);
          }
        });
        return t;
      }
      function EC(t, e) {
        const n = t.getSelectedElement();
        if (n) {
          const o = kC(t);
          if (o) {
            return e.createPositionAt(n, o);
          }
          if (e.schema.isBlock(n)) {
            return e.createPositionAfter(n);
          }
        }
        const o = t.getSelectedBlocks().next().value;
        if (o) {
          if (o.isEmpty) {
            return e.createPositionAt(o, 0);
          }
          const n = e.createPositionAfter(o);
          if (t.focus.isTouching(n)) {
            return n;
          }
          return e.createPositionBefore(o);
        }
        return t.focus;
      }
      function SC(t, e) {
        return (n, o) => {
          const { mapper: i, viewPosition: r } = o;
          const s = i.findMappedViewAncestor(r);
          if (!e(s)) {
            return;
          }
          const a = i.toModelElement(s);
          o.modelPosition = t.createPositionAt(
            a,
            r.isAtStart ? "before" : "after"
          );
        };
      }
      function PC(t, e) {
        const n = new Eh(Vd.window);
        const o = n.getIntersection(t);
        const i = e.height + Eb.arrowVerticalOffset;
        if (t.top - i > n.top || t.bottom + i < n.bottom) {
          return null;
        }
        const r = o || t;
        const s = r.left + r.width / 2 - e.width / 2;
        return {
          top: Math.max(t.top, 0) + Eb.arrowVerticalOffset,
          left: s,
          name: "arrow_n",
        };
      }
      function DC() {
        return null;
      }
      function TC(t, e) {
        const n = e.createUIElement(
          "div",
          { class: "ck ck-widget__selection-handle" },
          function (t) {
            const e = this.toDomElement(t);
            const n = new Ub();
            n.set("content", uC);
            n.render();
            e.appendChild(n.element);
            return e;
          }
        );
        e.insert(e.createPositionAt(t, 0), n);
        e.addClass(["ck-widget_with-selection-handle"], t);
      }
      function BC(t, e, n) {
        e.setCustomProperty("image", true, t);
        return AC(t, e, { label: o });
        function o() {
          const e = MC(t);
          const o = e.getAttribute("alt");
          return o ? `${o} ${n}` : n;
        }
      }
      function IC(t) {
        return !!t.getCustomProperty("image") && _C(t);
      }
      function OC(t) {
        const e = t.getSelectedElement();
        if (e && IC(e)) {
          return e;
        }
        return null;
      }
      function RC(t) {
        return !!t && t.is("element", "image");
      }
      function FC(t, e, n = {}) {
        const o = t.createElement("image", n);
        const i = EC(e.document.selection, e);
        e.insertContent(o, i);
        if (o.parent) {
          t.setSelection(o, "on");
        }
      }
      function NC(t) {
        const e = t.schema;
        const n = t.document.selection;
        return VC(n, e, t) && !LC(n, e) && zC(n);
      }
      function MC(t) {
        const e = [];
        for (const n of t.getChildren()) {
          e.push(n);
          if (n.is("element")) {
            e.push(...n.getChildren());
          }
        }
        return e.find((t) => t.is("element", "img"));
      }
      function VC(t, e, n) {
        const o = jC(t, n);
        return e.checkChild(o, "image");
      }
      function LC(t, e) {
        const n = t.getSelectedElement();
        return n && e.isObject(n);
      }
      function zC(t) {
        return [...t.focus.getAncestors()].every(
          (t) => !t.is("element", "image")
        );
      }
      function jC(t, e) {
        const n = EC(t, e);
        const o = n.parent;
        if (o.isEmpty && !o.is("element", "$root")) {
          return o.parent;
        }
        return o;
      }
      function KC() {
        return (e) => {
          e.on("element:figure", t);
        };
        function t(t, e, n) {
          if (
            !n.consumable.test(e.viewItem, { name: true, classes: "image" })
          ) {
            return;
          }
          const o = MC(e.viewItem);
          if (
            !o ||
            !o.hasAttribute("src") ||
            !n.consumable.test(o, { name: true })
          ) {
            return;
          }
          const i = n.convertItem(o, e.modelCursor);
          const r = Jw(i.modelRange.getItems());
          if (!r) {
            return;
          }
          n.convertChildren(e.viewItem, r);
          n.updateConversionResult(r, e);
        }
      }
      function qC() {
        return (e) => {
          e.on("attribute:srcset:image", t);
        };
        function t(t, e, n) {
          if (!n.consumable.consume(e.item, t.name)) {
            return;
          }
          const o = n.writer;
          const i = n.mapper.toViewElement(e.item);
          const r = MC(i);
          if (e.attributeNewValue === null) {
            const t = e.attributeOldValue;
            if (t.data) {
              o.removeAttribute("srcset", r);
              o.removeAttribute("sizes", r);
              if (t.width) {
                o.removeAttribute("width", r);
              }
            }
          } else {
            const t = e.attributeNewValue;
            if (t.data) {
              o.setAttribute("srcset", t.data, r);
              o.setAttribute("sizes", "100vw", r);
              if (t.width) {
                o.setAttribute("width", t.width, r);
              }
            }
          }
        }
      }
      function $C(t) {
        return (n) => {
          n.on(`attribute:${t}:image`, e);
        };
        function e(t, e, n) {
          if (!n.consumable.consume(e.item, t.name)) {
            return;
          }
          const o = n.writer;
          const i = n.mapper.toViewElement(e.item);
          const r = MC(i);
          o.setAttribute(e.attributeKey, e.attributeNewValue || "", r);
        }
      }
      class WC extends i_ {
        refresh() {
          this.isEnabled = NC(this.editor.model);
        }
        execute(t) {
          const e = this.editor.model;
          e.change((n) => {
            const o = Array.isArray(t.source) ? t.source : [t.source];
            for (const t of o) {
              FC(n, e, { src: t });
            }
          });
        }
      }
      class GC extends t_ {
        static get pluginName() {
          return "ImageEditing";
        }
        init() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.t;
          const o = t.conversion;
          t.editing.view.addObserver(sC);
          e.register("image", {
            isObject: true,
            isBlock: true,
            allowWhere: "$block",
            allowAttributes: ["alt", "src", "srcset"],
          });
          o.for("dataDowncast").elementToElement({
            model: "image",
            view: (t, { writer: e }) => UC(e),
          });
          o.for("editingDowncast").elementToElement({
            model: "image",
            view: (t, { writer: e }) => BC(UC(e), e, n("image widget")),
          });
          o.for("downcast").add($C("src")).add($C("alt")).add(qC());
          o.for("upcast")
            .elementToElement({
              view: { name: "img", attributes: { src: true } },
              model: (t, { writer: e }) =>
                e.createElement("image", { src: t.getAttribute("src") }),
            })
            .attributeToAttribute({
              view: { name: "img", key: "alt" },
              model: "alt",
            })
            .attributeToAttribute({
              view: { name: "img", key: "srcset" },
              model: {
                key: "srcset",
                value: (t) => {
                  const e = { data: t.getAttribute("srcset") };
                  if (t.hasAttribute("width")) {
                    e.width = t.getAttribute("width");
                  }
                  return e;
                },
              },
            })
            .add(KC());
          t.commands.add("imageInsert", new WC(t));
        }
      }
      function UC(t) {
        const e = t.createEmptyElement("img");
        const n = t.createContainerElement("figure", { class: "image" });
        t.insert(t.createPositionAt(n, 0), e);
        return n;
      }
      class HC extends eh {
        constructor(t) {
          super(t);
          this.domEventType = "mousedown";
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      var JC =
        '<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038M1 4.178l2 2.038"/></svg>';
      var YC = n(27);
      var QC = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      QC.insert = "head";
      QC.singleton = true;
      var XC = ik()(YC["a"], QC);
      var ZC = YC["a"].locals || {};
      const tv = ["before", "after"];
      const ev = new DOMParser().parseFromString(JC, "image/svg+xml")
        .firstChild;
      const nv = "ck-widget__type-around_disabled";
      class ov extends t_ {
        static get pluginName() {
          return "WidgetTypeAround";
        }
        constructor(t) {
          super(t);
          this._currentFakeCaretModelElement = null;
        }
        init() {
          const t = this.editor;
          const e = t.editing.view;
          this.on("change:isEnabled", (n, o, i) => {
            e.change((t) => {
              for (const n of e.document.roots) {
                if (i) {
                  t.removeClass(nv, n);
                } else {
                  t.addClass(nv, n);
                }
              }
            });
            if (!i) {
              t.model.change((t) => {
                t.removeSelectionAttribute(hC);
              });
            }
          });
          this._enableTypeAroundUIInjection();
          this._enableInsertingParagraphsOnButtonClick();
          this._enableInsertingParagraphsOnEnterKeypress();
          this._enableInsertingParagraphsOnTypingKeystroke();
          this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();
          this._enableDeleteIntegration();
          this._enableInsertContentIntegration();
        }
        destroy() {
          this._currentFakeCaretModelElement = null;
        }
        _insertParagraph(t, e) {
          const n = this.editor;
          const o = n.editing.view;
          n.execute("insertParagraph", {
            position: n.model.createPositionAt(t, e),
          });
          o.focus();
          o.scrollToTheSelection();
        }
        _listenToIfEnabled(t, e, n, o) {
          this.listenTo(
            t,
            e,
            (...t) => {
              if (this.isEnabled) {
                n(...t);
              }
            },
            o
          );
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const o = kC(n);
          if (!o) {
            return false;
          }
          const i = n.getSelectedElement();
          this._insertParagraph(i, o);
          return true;
        }
        _enableTypeAroundUIInjection() {
          const t = this.editor;
          const e = t.model.schema;
          const n = t.locale.t;
          const o = {
            before: n("Insert paragraph before block"),
            after: n("Insert paragraph after block"),
          };
          t.editing.downcastDispatcher.on(
            "insert",
            (t, n, i) => {
              const r = i.mapper.toViewElement(n.item);
              if (fC(r, n.item, e)) {
                iv(i.writer, o, r);
              }
            },
            { priority: "low" }
          );
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const o = e.schema;
          const i = t.editing.view;
          this._listenToIfEnabled(
            i.document,
            "keydown",
            (t, e) => {
              if (Ll(e.keyCode)) {
                this._handleArrowKeyPress(t, e);
              }
            },
            { priority: is.get("high") + 10 }
          );
          this._listenToIfEnabled(n, "change:range", (e, n) => {
            if (!n.directChange) {
              return;
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(hC);
            });
          });
          this._listenToIfEnabled(e.document, "change:data", () => {
            const e = n.getSelectedElement();
            if (e) {
              const n = t.editing.mapper.toViewElement(e);
              if (fC(n, e, o)) {
                return;
              }
            }
            t.model.change((t) => {
              t.removeSelectionAttribute(hC);
            });
          });
          this._listenToIfEnabled(
            t.editing.downcastDispatcher,
            "selection",
            (t, e, n) => {
              const i = n.writer;
              if (this._currentFakeCaretModelElement) {
                const t = n.mapper.toViewElement(
                  this._currentFakeCaretModelElement
                );
                if (t) {
                  i.removeClass(tv.map(r), t);
                  this._currentFakeCaretModelElement = null;
                }
              }
              const s = e.selection.getSelectedElement();
              if (!s) {
                return;
              }
              const a = n.mapper.toViewElement(s);
              if (!fC(a, s, o)) {
                return;
              }
              const c = kC(e.selection);
              if (!c) {
                return;
              }
              i.addClass(r(c), a);
              this._currentFakeCaretModelElement = s;
            }
          );
          this._listenToIfEnabled(
            t.ui.focusTracker,
            "change:isFocused",
            (e, n, o) => {
              if (!o) {
                t.model.change((t) => {
                  t.removeSelectionAttribute(hC);
                });
              }
            }
          );
          function r(t) {
            return `ck-widget_type-around_show-fake-caret_${t}`;
          }
        }
        _handleArrowKeyPress(t, e) {
          const n = this.editor;
          const o = n.model;
          const i = o.document.selection;
          const r = o.schema;
          const s = n.editing.view;
          const a = e.keyCode;
          const c = jl(a, n.locale.contentLanguageDirection);
          const l = s.document.selection.getSelectedElement();
          const d = n.editing.mapper.toModelElement(l);
          let u;
          if (fC(l, d, r)) {
            u = this._handleArrowKeyPressOnSelectedWidget(c);
          } else if (i.isCollapsed) {
            u = this._handleArrowKeyPressWhenSelectionNextToAWidget(c);
          }
          if (u) {
            e.preventDefault();
            t.stop();
          }
        }
        _handleArrowKeyPressOnSelectedWidget(t) {
          const e = this.editor;
          const n = e.model;
          const o = n.document.selection;
          const i = kC(o);
          return n.change((e) => {
            if (i) {
              const n = i === (t ? "after" : "before");
              if (!n) {
                e.removeSelectionAttribute(hC);
                return true;
              }
            } else {
              e.setSelectionAttribute(hC, t ? "after" : "before");
              return true;
            }
            return false;
          });
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(t) {
          const e = this.editor;
          const n = e.model;
          const o = n.schema;
          const i = e.plugins.get("Widget");
          const r = i._getObjectElementNextToSelection(t);
          const s = e.editing.mapper.toViewElement(r);
          if (fC(s, r, o)) {
            n.change((e) => {
              i._setSelectionOverElement(r);
              e.setSelectionAttribute(hC, t ? "before" : "after");
            });
            return true;
          }
          return false;
        }
        _enableInsertingParagraphsOnButtonClick() {
          const t = this.editor;
          const e = t.editing.view;
          this._listenToIfEnabled(e.document, "mousedown", (n, o) => {
            const i = gC(o.domTarget);
            if (!i) {
              return;
            }
            const r = pC(i);
            const s = mC(i, e.domConverter);
            const a = t.editing.mapper.toModelElement(s);
            this._insertParagraph(a, r);
            o.preventDefault();
            n.stop();
          });
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const t = this.editor;
          const e = t.editing.view;
          this._listenToIfEnabled(e.document, "enter", (n, o) => {
            const i = e.document.selection.getSelectedElement();
            const r = t.editing.mapper.toModelElement(i);
            const s = t.model.schema;
            let a;
            if (this._insertParagraphAccordingToFakeCaretPosition()) {
              a = true;
            } else if (fC(i, r, s)) {
              this._insertParagraph(r, o.isSoft ? "before" : "after");
              a = true;
            }
            if (a) {
              o.preventDefault();
              n.stop();
            }
          });
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const t = this.editor;
          const e = t.editing.view;
          const n = [Fl.enter, Fl.delete, Fl.backspace];
          this._listenToIfEnabled(
            e.document,
            "keydown",
            (t, e) => {
              if (!n.includes(e.keyCode) && !rA(e)) {
                this._insertParagraphAccordingToFakeCaretPosition();
              }
            },
            { priority: is.get("high") + 1 }
          );
        }
        _enableDeleteIntegration() {
          const t = this.editor;
          const e = t.editing.view;
          const n = t.model;
          const o = n.schema;
          this._listenToIfEnabled(
            e.document,
            "delete",
            (e, i) => {
              const r = kC(n.document.selection);
              if (!r) {
                return;
              }
              const s = i.direction;
              const a = n.document.selection.getSelectedElement();
              const c = r === "before";
              const l = s == "forward";
              const d = c === l;
              if (d) {
                t.execute("delete", { selection: n.createSelection(a, "on") });
              } else {
                const e = o.getNearestSelectionRange(
                  n.createPositionAt(a, r),
                  s
                );
                if (e) {
                  if (!e.isCollapsed) {
                    n.change((n) => {
                      n.setSelection(e);
                      t.execute(l ? "forwardDelete" : "delete");
                    });
                  } else {
                    const i = n.createSelection(e.start);
                    n.modifySelection(i, { direction: s });
                    if (!i.focus.isEqual(e.start)) {
                      n.change((n) => {
                        n.setSelection(e);
                        t.execute(l ? "forwardDelete" : "delete");
                      });
                    } else {
                      const t = av(o, e.start.parent);
                      n.deleteContent(n.createSelection(t, "on"), {
                        doNotAutoparagraph: true,
                      });
                    }
                  }
                }
              }
              i.preventDefault();
              e.stop();
            },
            { priority: is.get("high") + 1 }
          );
        }
        _enableInsertContentIntegration() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          this._listenToIfEnabled(
            t.model,
            "insertContent",
            (t, [o, i]) => {
              if (i && !i.is("documentSelection")) {
                return;
              }
              const r = kC(n);
              if (!r) {
                return;
              }
              t.stop();
              return e.change((t) => {
                const i = n.getSelectedElement();
                const s = e.createPositionAt(i, r);
                const a = t.createSelection(s);
                const c = e.insertContent(o, a);
                t.setSelection(a);
                return c;
              });
            },
            { priority: "high" }
          );
        }
      }
      function iv(t, e, n) {
        const o = t.createUIElement(
          "div",
          { class: "ck ck-reset_all ck-widget__type-around" },
          function (t) {
            const n = this.toDomElement(t);
            rv(n, e);
            sv(n);
            return n;
          }
        );
        t.insert(t.createPositionAt(n, "end"), o);
      }
      function rv(t, e) {
        for (const n of tv) {
          const o = new Ck({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-widget__type-around__button",
                `ck-widget__type-around__button_${n}`,
              ],
              title: e[n],
            },
            children: [t.ownerDocument.importNode(ev, true)],
          });
          t.appendChild(o.render());
        }
      }
      function sv(t) {
        const e = new Ck({
          tag: "div",
          attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] },
        });
        t.appendChild(e.render());
      }
      function av(t, e) {
        let n = e;
        for (const o of e.getAncestors({ parentFirst: true })) {
          if (o.childCount > 1 || t.isLimit(o)) {
            break;
          }
          n = o;
        }
        return n;
      }
      var cv = n(28);
      var lv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      lv.insert = "head";
      lv.singleton = true;
      var dv = ik()(cv["a"], lv);
      var uv = cv["a"].locals || {};
      function hv(t) {
        const e = t.model;
        return (n, o) => {
          const i = o.keyCode == Fl.arrowup;
          const r = o.keyCode == Fl.arrowdown;
          const s = o.shiftKey;
          const a = e.document.selection;
          if (!i && !r) {
            return;
          }
          const c = r;
          if (s && kv(a, c)) {
            return;
          }
          const l = fv(t, a, c);
          if (!l || l.isCollapsed) {
            return;
          }
          if (mv(t, l, c)) {
            e.change((t) => {
              const n = c ? l.end : l.start;
              if (s) {
                const o = e.createSelection(a.anchor);
                o.setFocus(n);
                t.setSelection(o);
              } else {
                t.setSelection(n);
              }
            });
            n.stop();
            o.preventDefault();
            o.stopPropagation();
          }
        };
      }
      function fv(t, e, n) {
        const o = t.model;
        if (n) {
          const t = e.isCollapsed ? e.focus : e.getLastPosition();
          const n = gv(o, t, "forward");
          if (!n) {
            return null;
          }
          const i = o.createRange(t, n);
          const r = pv(o.schema, i, "backward");
          if (r && t.isBefore(r)) {
            return o.createRange(t, r);
          }
          return null;
        } else {
          const t = e.isCollapsed ? e.focus : e.getFirstPosition();
          const n = gv(o, t, "backward");
          if (!n) {
            return null;
          }
          const i = o.createRange(n, t);
          const r = pv(o.schema, i, "forward");
          if (r && t.isAfter(r)) {
            return o.createRange(r, t);
          }
          return null;
        }
      }
      function gv(t, e, n) {
        const o = t.schema;
        const i = t.createRangeIn(e.root);
        const r = n == "forward" ? "elementStart" : "elementEnd";
        for (const { previousPosition: t, item: s, type: a } of i.getWalker({
          startPosition: e,
          direction: n,
        })) {
          if (o.isLimit(s) && !o.isInline(s)) {
            return t;
          }
          if (a == r && o.isBlock(s)) {
            return null;
          }
        }
        return null;
      }
      function pv(t, e, n) {
        const o = n == "backward" ? e.end : e.start;
        if (t.checkChild(o, "$text")) {
          return o;
        }
        for (const { nextPosition: o } of e.getWalker({ direction: n })) {
          if (t.checkChild(o, "$text")) {
            return o;
          }
        }
      }
      function mv(t, e, n) {
        const o = t.model;
        const i = t.view.domConverter;
        if (n) {
          const t = o.createSelection(e.start);
          o.modifySelection(t);
          if (!t.focus.isAtEnd && !e.start.isEqual(t.focus)) {
            e = o.createRange(t.focus, e.end);
          }
        }
        const r = t.mapper.toViewRange(e);
        const s = i.viewRangeToDom(r);
        const a = Eh.getDomRangeRects(s);
        let c;
        for (const t of a) {
          if (c === undefined) {
            c = Math.round(t.bottom);
            continue;
          }
          if (Math.round(t.top) >= c) {
            return false;
          }
          c = Math.max(c, Math.round(t.bottom));
        }
        return true;
      }
      function kv(t, e) {
        return !t.isCollapsed && t.isBackward == e;
      }
      class bv extends t_ {
        static get pluginName() {
          return "Widget";
        }
        static get requires() {
          return [ov];
        }
        init() {
          const t = this.editor.editing.view;
          const e = t.document;
          this._previouslySelected = new Set();
          this.editor.editing.downcastDispatcher.on(
            "selection",
            (t, e, n) => {
              this._clearPreviouslySelectedWidgets(n.writer);
              const o = n.writer;
              const i = o.document.selection;
              const r = i.getSelectedElement();
              let s = null;
              for (const t of i.getRanges()) {
                for (const e of t) {
                  const t = e.item;
                  if (_C(t) && !_v(t, s)) {
                    o.addClass(wC, t);
                    this._previouslySelected.add(t);
                    s = t;
                    if (t == r) {
                      o.setSelection(i.getRanges(), {
                        fake: true,
                        label: yC(r),
                      });
                    }
                  }
                }
              }
            },
            { priority: "low" }
          );
          t.addObserver(HC);
          this.listenTo(e, "mousedown", (...t) => this._onMousedown(...t));
          this.listenTo(
            e,
            "keydown",
            (...t) => {
              this._handleSelectionChangeOnArrowKeyPress(...t);
            },
            { priority: "high" }
          );
          this.listenTo(
            e,
            "keydown",
            (...t) => {
              this._preventDefaultOnArrowKeyPress(...t);
            },
            { priority: is.get("high") - 20 }
          );
          this.listenTo(e, "keydown", hv(this.editor.editing));
          this.listenTo(
            e,
            "delete",
            (t, e) => {
              if (this._handleDelete(e.direction == "forward")) {
                e.preventDefault();
                t.stop();
              }
            },
            { priority: "high" }
          );
        }
        _onMousedown(t, e) {
          const n = this.editor;
          const o = n.editing.view;
          const i = o.document;
          let r = e.target;
          if (wv(r)) {
            if ((El.isSafari || El.isGecko) && e.domEvent.detail >= 3) {
              const t = n.editing.mapper;
              const o = r.is("attributeElement")
                ? r.findAncestor((t) => !t.is("attributeElement"))
                : r;
              const i = t.toModelElement(o);
              e.preventDefault();
              this.editor.model.change((t) => {
                t.setSelection(i, "in");
              });
            }
            return;
          }
          if (!_C(r)) {
            r = r.findAncestor(_C);
            if (!r) {
              return;
            }
          }
          e.preventDefault();
          if (!i.isFocused) {
            o.focus();
          }
          const s = n.editing.mapper.toModelElement(r);
          this._setSelectionOverElement(s);
        }
        _handleSelectionChangeOnArrowKeyPress(t, e) {
          const n = e.keyCode;
          if (!Ll(n)) {
            return;
          }
          const o = this.editor.model;
          const i = o.schema;
          const r = o.document.selection;
          const s = r.getSelectedElement();
          const a = jl(n, this.editor.locale.contentLanguageDirection);
          if (s && i.isObject(s)) {
            const n = a ? r.getLastPosition() : r.getFirstPosition();
            const s = i.getNearestSelectionRange(n, a ? "forward" : "backward");
            if (s) {
              o.change((t) => {
                t.setSelection(s);
              });
              e.preventDefault();
              t.stop();
            }
            return;
          }
          if (!r.isCollapsed) {
            return;
          }
          const c = this._getObjectElementNextToSelection(a);
          if (c && i.isObject(c)) {
            this._setSelectionOverElement(c);
            e.preventDefault();
            t.stop();
          }
        }
        _preventDefaultOnArrowKeyPress(t, e) {
          const n = e.keyCode;
          if (!Ll(n)) {
            return;
          }
          const o = this.editor.model;
          const i = o.schema;
          const r = o.document.selection.getSelectedElement();
          if (r && i.isObject(r)) {
            e.preventDefault();
            t.stop();
          }
        }
        _handleDelete(t) {
          if (this.editor.isReadOnly) {
            return;
          }
          const e = this.editor.model.document;
          const n = e.selection;
          if (!n.isCollapsed) {
            return;
          }
          const o = this._getObjectElementNextToSelection(t);
          if (o) {
            this.editor.model.change((t) => {
              let e = n.anchor.parent;
              while (e.isEmpty) {
                const n = e;
                e = n.parent;
                t.remove(n);
              }
              this._setSelectionOverElement(o);
            });
            return true;
          }
        }
        _setSelectionOverElement(t) {
          this.editor.model.change((e) => {
            e.setSelection(e.createRangeOn(t));
          });
        }
        _getObjectElementNextToSelection(t) {
          const e = this.editor.model;
          const n = e.schema;
          const o = e.document.selection;
          const i = e.createSelection(o);
          e.modifySelection(i, { direction: t ? "forward" : "backward" });
          const r = t ? i.focus.nodeBefore : i.focus.nodeAfter;
          if (!!r && n.isObject(r)) {
            return r;
          }
          return null;
        }
        _clearPreviouslySelectedWidgets(t) {
          for (const e of this._previouslySelected) {
            t.removeClass(wC, e);
          }
          this._previouslySelected.clear();
        }
      }
      function wv(t) {
        while (t) {
          if (t.is("editableElement") && !t.is("rootElement")) {
            return true;
          }
          if (_C(t)) {
            return false;
          }
          t = t.parent;
        }
        return false;
      }
      function _v(t, e) {
        if (!e) {
          return false;
        }
        return Array.from(t.getAncestors()).includes(e);
      }
      class Av extends i_ {
        refresh() {
          const t = this.editor.model.document.selection.getSelectedElement();
          this.isEnabled = RC(t);
          if (RC(t) && t.hasAttribute("alt")) {
            this.value = t.getAttribute("alt");
          } else {
            this.value = false;
          }
        }
        execute(t) {
          const e = this.editor.model;
          const n = e.document.selection.getSelectedElement();
          e.change((e) => {
            e.setAttribute("alt", t.newValue, n);
          });
        }
      }
      class Cv extends t_ {
        static get pluginName() {
          return "ImageTextAlternativeEditing";
        }
        init() {
          this.editor.commands.add("imageTextAlternative", new Av(this.editor));
        }
      }
      var vv = n(29);
      var yv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      yv.insert = "head";
      yv.singleton = true;
      var xv = ik()(vv["a"], yv);
      var Ev = vv["a"].locals || {};
      class Sv extends Xk {
        constructor(t) {
          super(t);
          this.set("text");
          this.set("for");
          this.id = `ck-editor__label_${ns()}`;
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "label",
            attributes: {
              class: ["ck", "ck-label"],
              id: this.id,
              for: e.to("for"),
            },
            children: [{ text: e.to("text") }],
          });
        }
      }
      var Pv = n(30);
      var Dv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Dv.insert = "head";
      Dv.singleton = true;
      var Tv = ik()(Pv["a"], Dv);
      var Bv = Pv["a"].locals || {};
      class Iv extends Xk {
        constructor(t, e) {
          super(t);
          const n = `ck-labeled-field-view-${ns()}`;
          const o = `ck-labeled-field-view-status-${ns()}`;
          this.fieldView = e(this, n, o);
          this.set("label");
          this.set("isEnabled", true);
          this.set("errorText", null);
          this.set("infoText", null);
          this.set("class");
          this.labelView = this._createLabelView(n);
          this.statusView = this._createStatusView(o);
          this.bind("_statusText").to(
            this,
            "errorText",
            this,
            "infoText",
            (t, e) => t || e
          );
          const i = this.bindTemplate;
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-labeled-field-view",
                i.to("class"),
                i.if("isEnabled", "ck-disabled", (t) => !t),
              ],
            },
            children: [this.labelView, this.fieldView, this.statusView],
          });
        }
        _createLabelView(t) {
          const e = new Sv(this.locale);
          e.for = t;
          e.bind("text").to(this, "label");
          return e;
        }
        _createStatusView(t) {
          const e = new Xk(this.locale);
          const n = this.bindTemplate;
          e.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck",
                "ck-labeled-field-view__status",
                n.if("errorText", "ck-labeled-field-view__status_error"),
                n.if("_statusText", "ck-hidden", (t) => !t),
              ],
              id: t,
              role: n.if("errorText", "alert"),
            },
            children: [{ text: n.to("_statusText") }],
          });
          return e;
        }
        focus() {
          this.fieldView.focus();
        }
      }
      var Ov = n(31);
      var Rv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Rv.insert = "head";
      Rv.singleton = true;
      var Fv = ik()(Ov["a"], Rv);
      var Nv = Ov["a"].locals || {};
      class Mv extends Xk {
        constructor(t) {
          super(t);
          this.set("value");
          this.set("id");
          this.set("placeholder");
          this.set("isReadOnly", false);
          this.set("hasError", false);
          this.set("ariaDescribedById");
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "input",
            attributes: {
              type: "text",
              class: [
                "ck",
                "ck-input",
                "ck-input-text",
                e.if("hasError", "ck-error"),
              ],
              id: e.to("id"),
              placeholder: e.to("placeholder"),
              readonly: e.to("isReadOnly"),
              "aria-invalid": e.if("hasError", true),
              "aria-describedby": e.to("ariaDescribedById"),
            },
            on: { input: e.to("input") },
          });
        }
        render() {
          super.render();
          const t = (t) => {
            this.element.value = !t && t !== 0 ? "" : t;
          };
          t(this.value);
          this.on("change:value", (e, n, o) => {
            t(o);
          });
        }
        select() {
          this.element.select();
        }
        focus() {
          this.element.focus();
        }
      }
      function Vv(t, e, n) {
        const o = new Mv(t.locale);
        o.set({ id: e, ariaDescribedById: n });
        o.bind("isReadOnly").to(t, "isEnabled", (t) => !t);
        o.bind("hasError").to(t, "errorText", (t) => !!t);
        o.on("input", () => {
          t.errorText = null;
        });
        return o;
      }
      function Lv(t, e, n) {
        const o = Sw(t.locale);
        o.set({ id: e, ariaDescribedById: n });
        o.bind("isEnabled").to(t);
        return o;
      }
      function zv({ view: t }) {
        t.listenTo(
          t.element,
          "submit",
          (e, n) => {
            n.preventDefault();
            t.fire("submit");
          },
          { useCapture: true }
        );
      }
      var jv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>';
      var Kv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.591 10.177l4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>';
      var qv = n(32);
      var $v = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      $v.insert = "head";
      $v.singleton = true;
      var Wv = ik()(qv["a"], $v);
      var Gv = qv["a"].locals || {};
      var Uv = n(33);
      var Hv = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Hv.insert = "head";
      Hv.singleton = true;
      var Jv = ik()(Uv["a"], Hv);
      var Yv = Uv["a"].locals || {};
      class Qv extends Xk {
        constructor(t) {
          super(t);
          const e = this.locale.t;
          this.focusTracker = new Zm();
          this.keystrokes = new zm();
          this.labeledInput = this._createLabeledInputView();
          this.saveButtonView = this._createButton(
            e("Save"),
            jv,
            "ck-button-save"
          );
          this.saveButtonView.type = "submit";
          this.cancelButtonView = this._createButton(
            e("Cancel"),
            Kv,
            "ck-button-cancel",
            "cancel"
          );
          this._focusables = new wk();
          this._focusCycler = new Tb({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this.setTemplate({
            tag: "form",
            attributes: {
              class: ["ck", "ck-text-alternative-form", "ck-responsive-form"],
              tabindex: "-1",
            },
            children: [
              this.labeledInput,
              this.saveButtonView,
              this.cancelButtonView,
            ],
          });
        }
        render() {
          super.render();
          this.keystrokes.listenTo(this.element);
          zv({ view: this });
          [
            this.labeledInput,
            this.saveButtonView,
            this.cancelButtonView,
          ].forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
        }
        _createButton(t, e, n, o) {
          const i = new ow(this.locale);
          i.set({ label: t, icon: e, tooltip: true });
          i.extendTemplate({ attributes: { class: n } });
          if (o) {
            i.delegate("execute").to(this, o);
          }
          return i;
        }
        _createLabeledInputView() {
          const t = this.locale.t;
          const e = new Iv(this.locale, Vv);
          e.label = t("Text alternative");
          e.fieldView.placeholder = t("Text alternative");
          return e;
        }
      }
      var Xv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
      var Zv =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>';
      var ty = n(34);
      var ey = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      ey.insert = "head";
      ey.singleton = true;
      var ny = ik()(ty["a"], ey);
      var oy = ty["a"].locals || {};
      var iy = n(35);
      var ry = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      ry.insert = "head";
      ry.singleton = true;
      var sy = ik()(iy["a"], ry);
      var ay = iy["a"].locals || {};
      const cy = wb("px");
      class ly extends t_ {
        static get pluginName() {
          return "ContextualBalloon";
        }
        constructor(t) {
          super(t);
          this.positionLimiter = () => {
            const t = this.editor.editing.view;
            const e = t.document;
            const n = e.selection.editableElement;
            if (n) {
              return t.domConverter.mapViewToDom(n.root);
            }
            return null;
          };
          this.set("visibleView", null);
          this.view = new Eb(t.locale);
          t.ui.view.body.add(this.view);
          t.ui.focusTracker.add(this.view.element);
          this._viewToStack = new Map();
          this._idToStack = new Map();
          this.set("_numberOfStacks", 0);
          this.set("_singleViewMode", false);
          this._rotatorView = this._createRotatorView();
          this._fakePanelsView = this._createFakePanelsView();
        }
        hasView(t) {
          return Array.from(this._viewToStack.keys()).includes(t);
        }
        add(t) {
          if (this.hasView(t.view)) {
            throw new ss["a"]("contextualballoon-add-view-exist", [this, t]);
          }
          const e = t.stackId || "main";
          if (!this._idToStack.has(e)) {
            this._idToStack.set(e, new Map([[t.view, t]]));
            this._viewToStack.set(t.view, this._idToStack.get(e));
            this._numberOfStacks = this._idToStack.size;
            if (!this._visibleStack || t.singleViewMode) {
              this.showStack(e);
            }
            return;
          }
          const n = this._idToStack.get(e);
          if (t.singleViewMode) {
            this.showStack(e);
          }
          n.set(t.view, t);
          this._viewToStack.set(t.view, n);
          if (n === this._visibleStack) {
            this._showView(t);
          }
        }
        remove(t) {
          if (!this.hasView(t)) {
            throw new ss["a"]("contextualballoon-remove-view-not-exist", [
              this,
              t,
            ]);
          }
          const e = this._viewToStack.get(t);
          if (this._singleViewMode && this.visibleView === t) {
            this._singleViewMode = false;
          }
          if (this.visibleView === t) {
            if (e.size === 1) {
              if (this._idToStack.size > 1) {
                this._showNextStack();
              } else {
                this.view.hide();
                this.visibleView = null;
                this._rotatorView.hideView();
              }
            } else {
              this._showView(Array.from(e.values())[e.size - 2]);
            }
          }
          if (e.size === 1) {
            this._idToStack.delete(this._getStackId(e));
            this._numberOfStacks = this._idToStack.size;
          } else {
            e.delete(t);
          }
          this._viewToStack.delete(t);
        }
        updatePosition(t) {
          if (t) {
            this._visibleStack.get(this.visibleView).position = t;
          }
          this.view.pin(this._getBalloonPosition());
          this._fakePanelsView.updatePosition();
        }
        showStack(t) {
          this.visibleStack = t;
          const e = this._idToStack.get(t);
          if (!e) {
            throw new ss["a"](
              "contextualballoon-showstack-stack-not-exist",
              this
            );
          }
          if (this._visibleStack === e) {
            return;
          }
          this._showView(Array.from(e.values()).pop());
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView);
        }
        _getStackId(t) {
          const e = Array.from(this._idToStack.entries()).find(
            (e) => e[1] === t
          );
          return e[0];
        }
        _showNextStack() {
          const t = Array.from(this._idToStack.values());
          let e = t.indexOf(this._visibleStack) + 1;
          if (!t[e]) {
            e = 0;
          }
          this.showStack(this._getStackId(t[e]));
        }
        _showPrevStack() {
          const t = Array.from(this._idToStack.values());
          let e = t.indexOf(this._visibleStack) - 1;
          if (!t[e]) {
            e = t.length - 1;
          }
          this.showStack(this._getStackId(t[e]));
        }
        _createRotatorView() {
          const t = new dy(this.editor.locale);
          const e = this.editor.locale.t;
          this.view.content.add(t);
          t.bind("isNavigationVisible").to(
            this,
            "_numberOfStacks",
            this,
            "_singleViewMode",
            (t, e) => !e && t > 1
          );
          t.on("change:isNavigationVisible", () => this.updatePosition(), {
            priority: "low",
          });
          t.bind("counter").to(
            this,
            "visibleView",
            this,
            "_numberOfStacks",
            (t, n) => {
              if (n < 2) {
                return "";
              }
              const o =
                Array.from(this._idToStack.values()).indexOf(
                  this._visibleStack
                ) + 1;
              return e("%0 of %1", [o, n]);
            }
          );
          t.buttonNextView.on("execute", () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus();
            }
            this._showNextStack();
          });
          t.buttonPrevView.on("execute", () => {
            if (t.focusTracker.isFocused) {
              this.editor.editing.view.focus();
            }
            this._showPrevStack();
          });
          return t;
        }
        _createFakePanelsView() {
          const t = new uy(this.editor.locale, this.view);
          t.bind("numberOfPanels").to(
            this,
            "_numberOfStacks",
            this,
            "_singleViewMode",
            (t, e) => {
              const n = !e && t >= 2;
              return n ? Math.min(t - 1, 2) : 0;
            }
          );
          t.listenTo(this.view, "change:top", () => t.updatePosition());
          t.listenTo(this.view, "change:left", () => t.updatePosition());
          this.editor.ui.view.body.add(t);
          return t;
        }
        _showView({
          view: t,
          balloonClassName: e = "",
          withArrow: n = true,
          singleViewMode: o = false,
        }) {
          this.view.class = e;
          this.view.withArrow = n;
          this._rotatorView.showView(t);
          this.visibleView = t;
          this.view.pin(this._getBalloonPosition());
          this._fakePanelsView.updatePosition();
          if (o) {
            this._singleViewMode = true;
          }
        }
        _getBalloonPosition() {
          let t = Array.from(this._visibleStack.values()).pop().position;
          if (t && !t.limiter) {
            t = Object.assign({}, t, { limiter: this.positionLimiter });
          }
          return t;
        }
      }
      class dy extends Xk {
        constructor(t) {
          super(t);
          const e = t.t;
          const n = this.bindTemplate;
          this.set("isNavigationVisible", true);
          this.focusTracker = new Zm();
          this.buttonPrevView = this._createButtonView(e("Previous"), Xv);
          this.buttonNextView = this._createButtonView(e("Next"), Zv);
          this.content = this.createCollection();
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-balloon-rotator"],
              "z-index": "-1",
            },
            children: [
              {
                tag: "div",
                attributes: {
                  class: [
                    "ck-balloon-rotator__navigation",
                    n.to("isNavigationVisible", (t) => (t ? "" : "ck-hidden")),
                  ],
                },
                children: [
                  this.buttonPrevView,
                  {
                    tag: "span",
                    attributes: { class: ["ck-balloon-rotator__counter"] },
                    children: [{ text: n.to("counter") }],
                  },
                  this.buttonNextView,
                ],
              },
              {
                tag: "div",
                attributes: { class: "ck-balloon-rotator__content" },
                children: this.content,
              },
            ],
          });
        }
        render() {
          super.render();
          this.focusTracker.add(this.element);
        }
        showView(t) {
          this.hideView();
          this.content.add(t);
        }
        hideView() {
          this.content.clear();
        }
        _createButtonView(t, e) {
          const n = new ow(this.locale);
          n.set({ label: t, icon: e, tooltip: true });
          return n;
        }
      }
      class uy extends Xk {
        constructor(t, e) {
          super(t);
          const n = this.bindTemplate;
          this.set("top", 0);
          this.set("left", 0);
          this.set("height", 0);
          this.set("width", 0);
          this.set("numberOfPanels", 0);
          this.content = this.createCollection();
          this._balloonPanelView = e;
          this.setTemplate({
            tag: "div",
            attributes: {
              class: [
                "ck-fake-panel",
                n.to("numberOfPanels", (t) => (t ? "" : "ck-hidden")),
              ],
              style: {
                top: n.to("top", cy),
                left: n.to("left", cy),
                width: n.to("width", cy),
                height: n.to("height", cy),
              },
            },
            children: this.content,
          });
          this.on("change:numberOfPanels", (t, e, n, o) => {
            if (n > o) {
              this._addPanels(n - o);
            } else {
              this._removePanels(o - n);
            }
            this.updatePosition();
          });
        }
        _addPanels(t) {
          while (t--) {
            const t = new Xk();
            t.setTemplate({ tag: "div" });
            this.content.add(t);
            this.registerChild(t);
          }
        }
        _removePanels(t) {
          while (t--) {
            const t = this.content.last;
            this.content.remove(t);
            this.deregisterChild(t);
            t.destroy();
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: t, left: e } = this._balloonPanelView;
            const { width: n, height: o } = new Eh(
              this._balloonPanelView.element
            );
            Object.assign(this, { top: t, left: e, width: n, height: o });
          }
        }
      }
      var hy =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22L2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21l-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>';
      function fy(t) {
        const e = t.plugins.get("ContextualBalloon");
        if (OC(t.editing.view.document.selection)) {
          const n = gy(t);
          e.updatePosition(n);
        }
      }
      function gy(t) {
        const e = t.editing.view;
        const n = Eb.defaultPositions;
        return {
          target: e.domConverter.viewToDom(
            e.document.selection.getSelectedElement()
          ),
          positions: [
            n.northArrowSouth,
            n.northArrowSouthWest,
            n.northArrowSouthEast,
            n.southArrowNorth,
            n.southArrowNorthWest,
            n.southArrowNorthEast,
          ],
        };
      }
      class py extends t_ {
        static get requires() {
          return [ly];
        }
        static get pluginName() {
          return "ImageTextAlternativeUI";
        }
        init() {
          this._createButton();
          this._createForm();
        }
        destroy() {
          super.destroy();
          this._form.destroy();
        }
        _createButton() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("imageTextAlternative", (n) => {
            const o = t.commands.get("imageTextAlternative");
            const i = new ow(n);
            i.set({
              label: e("Change image text alternative"),
              icon: hy,
              tooltip: true,
            });
            i.bind("isEnabled").to(o, "isEnabled");
            this.listenTo(i, "execute", () => {
              this._showForm();
            });
            return i;
          });
        }
        _createForm() {
          const t = this.editor;
          const e = t.editing.view;
          const n = e.document;
          this._balloon = this.editor.plugins.get("ContextualBalloon");
          this._form = new Qv(t.locale);
          this._form.render();
          this.listenTo(this._form, "submit", () => {
            t.execute("imageTextAlternative", {
              newValue: this._form.labeledInput.fieldView.element.value,
            });
            this._hideForm(true);
          });
          this.listenTo(this._form, "cancel", () => {
            this._hideForm(true);
          });
          this._form.keystrokes.set("Esc", (t, e) => {
            this._hideForm(true);
            e();
          });
          this.listenTo(t.ui, "update", () => {
            if (!OC(n.selection)) {
              this._hideForm(true);
            } else if (this._isVisible) {
              fy(t);
            }
          });
          bw({
            emitter: this._form,
            activator: () => this._isVisible,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideForm(),
          });
        }
        _showForm() {
          if (this._isVisible) {
            return;
          }
          const t = this.editor;
          const e = t.commands.get("imageTextAlternative");
          const n = this._form.labeledInput;
          if (!this._isInBalloon) {
            this._balloon.add({ view: this._form, position: gy(t) });
          }
          n.fieldView.value = n.fieldView.element.value = e.value || "";
          this._form.labeledInput.fieldView.select();
        }
        _hideForm(t) {
          if (!this._isInBalloon) {
            return;
          }
          if (this._form.focusTracker.isFocused) {
            this._form.saveButtonView.focus();
          }
          this._balloon.remove(this._form);
          if (t) {
            this.editor.editing.view.focus();
          }
        }
        get _isVisible() {
          return this._balloon.visibleView === this._form;
        }
        get _isInBalloon() {
          return this._balloon.hasView(this._form);
        }
      }
      class my extends t_ {
        static get requires() {
          return [Cv, py];
        }
        static get pluginName() {
          return "ImageTextAlternative";
        }
      }
      var ky = n(36);
      var by = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      by.insert = "head";
      by.singleton = true;
      var wy = ik()(ky["a"], by);
      var _y = ky["a"].locals || {};
      class Ay extends t_ {
        static get requires() {
          return [GC, bv, my];
        }
        static get pluginName() {
          return "Image";
        }
      }
      class Cy extends t_ {
        static get requires() {
          return [ly];
        }
        static get pluginName() {
          return "WidgetToolbarRepository";
        }
        init() {
          const t = this.editor;
          if (t.plugins.has("BalloonToolbar")) {
            const e = t.plugins.get("BalloonToolbar");
            this.listenTo(
              e,
              "show",
              (e) => {
                if (xy(t.editing.view.document.selection)) {
                  e.stop();
                }
              },
              { priority: "high" }
            );
          }
          this._toolbarDefinitions = new Map();
          this._balloon = this.editor.plugins.get("ContextualBalloon");
          this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility();
          });
          this.listenTo(t.ui, "update", () => {
            this._updateToolbarsVisibility();
          });
          this.listenTo(
            t.ui.focusTracker,
            "change:isFocused",
            () => {
              this._updateToolbarsVisibility();
            },
            { priority: "low" }
          );
        }
        destroy() {
          super.destroy();
          for (const t of this._toolbarDefinitions.values()) {
            t.view.destroy();
          }
        }
        register(
          t,
          {
            ariaLabel: e,
            items: n,
            getRelatedElement: o,
            balloonClassName: i = "ck-toolbar-container",
          }
        ) {
          if (!n.length) {
            Object(ss["c"])("widget-toolbar-no-items", { toolbarId: t });
            return;
          }
          const r = this.editor;
          const s = r.t;
          const a = new Lw(r.locale);
          a.ariaLabel = e || s("Widget toolbar");
          if (this._toolbarDefinitions.has(t)) {
            throw new ss["a"]("widget-toolbar-duplicated", this, {
              toolbarId: t,
            });
          }
          a.fillFromConfig(n, r.ui.componentFactory);
          this._toolbarDefinitions.set(t, {
            view: a,
            getRelatedElement: o,
            balloonClassName: i,
          });
        }
        _updateToolbarsVisibility() {
          let t = 0;
          let e = null;
          let n = null;
          for (const o of this._toolbarDefinitions.values()) {
            const i = o.getRelatedElement(
              this.editor.editing.view.document.selection
            );
            if (!this.isEnabled || !i) {
              if (this._isToolbarInBalloon(o)) {
                this._hideToolbar(o);
              }
            } else if (!this.editor.ui.focusTracker.isFocused) {
              if (this._isToolbarVisible(o)) {
                this._hideToolbar(o);
              }
            } else {
              const r = i.getAncestors().length;
              if (r > t) {
                t = r;
                e = i;
                n = o;
              }
            }
          }
          if (n) {
            this._showToolbar(n, e);
          }
        }
        _hideToolbar(t) {
          this._balloon.remove(t.view);
          this.stopListening(this._balloon, "change:visibleView");
        }
        _showToolbar(t, e) {
          if (this._isToolbarVisible(t)) {
            vy(this.editor, e);
          } else if (!this._isToolbarInBalloon(t)) {
            this._balloon.add({
              view: t.view,
              position: yy(this.editor, e),
              balloonClassName: t.balloonClassName,
            });
            this.listenTo(this._balloon, "change:visibleView", () => {
              for (const t of this._toolbarDefinitions.values()) {
                if (this._isToolbarVisible(t)) {
                  const e = t.getRelatedElement(
                    this.editor.editing.view.document.selection
                  );
                  vy(this.editor, e);
                }
              }
            });
          }
        }
        _isToolbarVisible(t) {
          return this._balloon.visibleView === t.view;
        }
        _isToolbarInBalloon(t) {
          return this._balloon.hasView(t.view);
        }
      }
      function vy(t, e) {
        const n = t.plugins.get("ContextualBalloon");
        const o = yy(t, e);
        n.updatePosition(o);
      }
      function yy(t, e) {
        const n = t.editing.view;
        const o = Eb.defaultPositions;
        return {
          target: n.domConverter.mapViewToDom(e),
          positions: [
            o.northArrowSouth,
            o.northArrowSouthWest,
            o.northArrowSouthEast,
            o.southArrowNorth,
            o.southArrowNorthWest,
            o.southArrowNorthEast,
            PC,
          ],
        };
      }
      function xy(t) {
        const e = t.getSelectedElement();
        return !!(e && _C(e));
      }
      class Ey extends t_ {
        static get requires() {
          return [Cy];
        }
        static get pluginName() {
          return "ImageToolbar";
        }
        afterInit() {
          const t = this.editor;
          const e = t.t;
          const n = t.plugins.get(Cy);
          n.register("image", {
            ariaLabel: e("Image toolbar"),
            items: t.config.get("image.toolbar") || [],
            getRelatedElement: OC,
          });
        }
      }
      class Sy extends Xk {
        constructor(t) {
          super(t);
          this.buttonView = new ow(t);
          this._fileInputView = new Py(t);
          this._fileInputView.bind("acceptedType").to(this);
          this._fileInputView.bind("allowMultipleFiles").to(this);
          this._fileInputView.delegate("done").to(this);
          this.setTemplate({
            tag: "span",
            attributes: { class: "ck-file-dialog-button" },
            children: [this.buttonView, this._fileInputView],
          });
          this.buttonView.on("execute", () => {
            this._fileInputView.open();
          });
        }
        focus() {
          this.buttonView.focus();
        }
      }
      class Py extends Xk {
        constructor(t) {
          super(t);
          this.set("acceptedType");
          this.set("allowMultipleFiles", false);
          const e = this.bindTemplate;
          this.setTemplate({
            tag: "input",
            attributes: {
              class: ["ck-hidden"],
              type: "file",
              tabindex: "-1",
              accept: e.to("acceptedType"),
              multiple: e.to("allowMultipleFiles"),
            },
            on: {
              change: e.to(() => {
                if (
                  this.element &&
                  this.element.files &&
                  this.element.files.length
                ) {
                  this.fire("done", this.element.files);
                }
                this.element.value = "";
              }),
            },
          });
        }
        open() {
          this.element.click();
        }
      }
      function Dy(t) {
        const e = t.map((t) => t.replace("+", "\\+"));
        return new RegExp(`^image\\/(${e.join("|")})$`);
      }
      function Ty(t) {
        return new Promise((e, n) => {
          const o = t.getAttribute("src");
          fetch(o)
            .then((t) => t.blob())
            .then((t) => {
              const n = Iy(t, o);
              const i = n.replace("image/", "");
              const r = `image.${i}`;
              const s = new File([t], r, { type: n });
              e(s);
            })
            .catch(n);
        });
      }
      function By(t) {
        if (!t.is("element", "img") || !t.getAttribute("src")) {
          return false;
        }
        return (
          t.getAttribute("src").match(/^data:image\/\w+;base64,/g) ||
          t.getAttribute("src").match(/^blob:/g)
        );
      }
      function Iy(t, e) {
        if (t.type) {
          return t.type;
        } else if (e.match(/data:(image\/\w+);base64/)) {
          return e.match(/data:(image\/\w+);base64/)[1].toLowerCase();
        } else {
          return "image/jpeg";
        }
      }
      var Oy =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>';
      class Ry extends t_ {
        static get pluginName() {
          return "ImageUploadUI";
        }
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add("imageUpload", (n) => {
            const o = new Sy(n);
            const i = t.commands.get("imageUpload");
            const r = t.config.get("image.upload.types");
            const s = Dy(r);
            o.set({
              acceptedType: r.map((t) => `image/${t}`).join(","),
              allowMultipleFiles: true,
            });
            o.buttonView.set({
              label: e("Insert image"),
              icon: Oy,
              tooltip: true,
            });
            o.buttonView.bind("isEnabled").to(i);
            o.on("done", (e, n) => {
              const o = Array.from(n).filter((t) => s.test(t.type));
              if (o.length) {
                t.execute("imageUpload", { file: o });
              }
            });
            return o;
          });
        }
      }
      class Fy {
        constructor(t) {
          this.context = t;
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return true;
        }
      }
      Cs(Fy, Yc);
      class Ny extends Fy {
        static get pluginName() {
          return "PendingActions";
        }
        init() {
          this.set("hasAny", false);
          this._actions = new vs({ idProperty: "_id" });
          this._actions.delegate("add", "remove").to(this);
        }
        add(t) {
          if (typeof t !== "string") {
            throw new ss["a"]("pendingactions-add-invalid-message", this);
          }
          const e = Object.create(Yc);
          e.set("message", t);
          this._actions.add(e);
          this.hasAny = true;
          return e;
        }
        remove(t) {
          this._actions.remove(t);
          this.hasAny = !!this._actions.length;
        }
        get first() {
          return this._actions.get(0);
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]();
        }
      }
      class My {
        constructor() {
          const t = new window.FileReader();
          this._reader = t;
          this._data = undefined;
          this.set("loaded", 0);
          t.onprogress = (t) => {
            this.loaded = t.loaded;
          };
        }
        get error() {
          return this._reader.error;
        }
        get data() {
          return this._data;
        }
        read(t) {
          const e = this._reader;
          this.total = t.size;
          return new Promise((n, o) => {
            e.onload = () => {
              const t = e.result;
              this._data = t;
              n(t);
            };
            e.onerror = () => {
              o("error");
            };
            e.onabort = () => {
              o("aborted");
            };
            this._reader.readAsDataURL(t);
          });
        }
        abort() {
          this._reader.abort();
        }
      }
      Cs(My, Yc);
      class Vy extends t_ {
        static get pluginName() {
          return "FileRepository";
        }
        static get requires() {
          return [Ny];
        }
        init() {
          this.loaders = new vs();
          this.loaders.on("add", () => this._updatePendingAction());
          this.loaders.on("remove", () => this._updatePendingAction());
          this._loadersMap = new Map();
          this._pendingAction = null;
          this.set("uploaded", 0);
          this.set("uploadTotal", null);
          this.bind("uploadedPercent").to(
            this,
            "uploaded",
            this,
            "uploadTotal",
            (t, e) => (e ? (t / e) * 100 : 0)
          );
        }
        getLoader(t) {
          return this._loadersMap.get(t) || null;
        }
        createLoader(t) {
          if (!this.createUploadAdapter) {
            Object(ss["c"])("filerepository-no-upload-adapter");
            return null;
          }
          const e = new Ly(Promise.resolve(t), this.createUploadAdapter);
          this.loaders.add(e);
          this._loadersMap.set(t, e);
          if (t instanceof Promise) {
            e.file
              .then((t) => {
                this._loadersMap.set(t, e);
              })
              .catch(() => {});
          }
          e.on("change:uploaded", () => {
            let t = 0;
            for (const e of this.loaders) {
              t += e.uploaded;
            }
            this.uploaded = t;
          });
          e.on("change:uploadTotal", () => {
            let t = 0;
            for (const e of this.loaders) {
              if (e.uploadTotal) {
                t += e.uploadTotal;
              }
            }
            this.uploadTotal = t;
          });
          return e;
        }
        destroyLoader(t) {
          const e = t instanceof Ly ? t : this.getLoader(t);
          e._destroy();
          this.loaders.remove(e);
          this._loadersMap.forEach((t, n) => {
            if (t === e) {
              this._loadersMap.delete(n);
            }
          });
        }
        _updatePendingAction() {
          const t = this.editor.plugins.get(Ny);
          if (this.loaders.length) {
            if (!this._pendingAction) {
              const e = this.editor.t;
              const n = (t) => `${e("Upload in progress")} ${parseInt(t)}%.`;
              this._pendingAction = t.add(n(this.uploadedPercent));
              this._pendingAction
                .bind("message")
                .to(this, "uploadedPercent", n);
            }
          } else {
            t.remove(this._pendingAction);
            this._pendingAction = null;
          }
        }
      }
      Cs(Vy, Yc);
      class Ly {
        constructor(t, e) {
          this.id = ns();
          this._filePromiseWrapper = this._createFilePromiseWrapper(t);
          this._adapter = e(this);
          this._reader = new My();
          this.set("status", "idle");
          this.set("uploaded", 0);
          this.set("uploadTotal", null);
          this.bind("uploadedPercent").to(
            this,
            "uploaded",
            this,
            "uploadTotal",
            (t, e) => (e ? (t / e) * 100 : 0)
          );
          this.set("uploadResponse", null);
        }
        get file() {
          if (!this._filePromiseWrapper) {
            return Promise.resolve(null);
          } else {
            return this._filePromiseWrapper.promise.then((t) =>
              this._filePromiseWrapper ? t : null
            );
          }
        }
        get data() {
          return this._reader.data;
        }
        read() {
          if (this.status != "idle") {
            throw new ss["a"]("filerepository-read-wrong-status", this);
          }
          this.status = "reading";
          return this.file
            .then((t) => this._reader.read(t))
            .then((t) => {
              if (this.status !== "reading") {
                throw this.status;
              }
              this.status = "idle";
              return t;
            })
            .catch((t) => {
              if (t === "aborted") {
                this.status = "aborted";
                throw "aborted";
              }
              this.status = "error";
              throw this._reader.error ? this._reader.error : t;
            });
        }
        upload() {
          if (this.status != "idle") {
            throw new ss["a"]("filerepository-upload-wrong-status", this);
          }
          this.status = "uploading";
          return this.file
            .then(() => this._adapter.upload())
            .then((t) => {
              this.uploadResponse = t;
              this.status = "idle";
              return t;
            })
            .catch((t) => {
              if (this.status === "aborted") {
                throw "aborted";
              }
              this.status = "error";
              throw t;
            });
        }
        abort() {
          const t = this.status;
          this.status = "aborted";
          if (!this._filePromiseWrapper.isFulfilled) {
            this._filePromiseWrapper.promise.catch(() => {});
            this._filePromiseWrapper.rejecter("aborted");
          } else if (t == "reading") {
            this._reader.abort();
          } else if (t == "uploading" && this._adapter.abort) {
            this._adapter.abort();
          }
          this._destroy();
        }
        _destroy() {
          this._filePromiseWrapper = undefined;
          this._reader = undefined;
          this._adapter = undefined;
          this.uploadResponse = undefined;
        }
        _createFilePromiseWrapper(t) {
          const e = {};
          e.promise = new Promise((n, o) => {
            e.rejecter = o;
            e.isFulfilled = false;
            t.then((t) => {
              e.isFulfilled = true;
              n(t);
            }).catch((t) => {
              e.isFulfilled = true;
              o(t);
            });
          });
          return e;
        }
      }
      Cs(Ly, Yc);
      var zy =
        '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 700 250"><rect rx="4"/></svg>';
      var jy = n(37);
      var Ky = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Ky.insert = "head";
      Ky.singleton = true;
      var qy = ik()(jy["a"], Ky);
      var $y = jy["a"].locals || {};
      var Wy = n(38);
      var Gy = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Gy.insert = "head";
      Gy.singleton = true;
      var Uy = ik()(Wy["a"], Gy);
      var Hy = Wy["a"].locals || {};
      var Jy = n(39);
      var Yy = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      Yy.insert = "head";
      Yy.singleton = true;
      var Qy = ik()(Jy["a"], Yy);
      var Xy = Jy["a"].locals || {};
      class Zy extends t_ {
        constructor(t) {
          super(t);
          this.placeholder =
            "data:image/svg+xml;utf8," + encodeURIComponent(zy);
        }
        init() {
          const t = this.editor;
          t.editing.downcastDispatcher.on(
            "attribute:uploadStatus:image",
            (...t) => this.uploadStatusChange(...t)
          );
        }
        uploadStatusChange(t, e, n) {
          const o = this.editor;
          const i = e.item;
          const r = i.getAttribute("uploadId");
          if (!n.consumable.consume(e.item, t.name)) {
            return;
          }
          const s = o.plugins.get(Vy);
          const a = r ? e.attributeNewValue : null;
          const c = this.placeholder;
          const l = o.editing.mapper.toViewElement(i);
          const d = n.writer;
          if (a == "reading") {
            tx(l, d);
            nx(c, l, d);
            return;
          }
          if (a == "uploading") {
            const t = s.loaders.get(r);
            tx(l, d);
            if (!t) {
              nx(c, l, d);
            } else {
              ox(l, d);
              ix(l, d, t, o.editing.view);
              ux(l, d, t);
            }
            return;
          }
          if (a == "complete" && s.loaders.get(r)) {
            sx(l, d, o.editing.view);
          }
          rx(l, d);
          ox(l, d);
          ex(l, d);
        }
      }
      function tx(t, e) {
        if (!t.hasClass("ck-appear")) {
          e.addClass("ck-appear", t);
        }
      }
      function ex(t, e) {
        e.removeClass("ck-appear", t);
      }
      function nx(t, e, n) {
        if (!e.hasClass("ck-image-upload-placeholder")) {
          n.addClass("ck-image-upload-placeholder", e);
        }
        const o = MC(e);
        if (o.getAttribute("src") !== t) {
          n.setAttribute("src", t, o);
        }
        if (!lx(e, "placeholder")) {
          n.insert(n.createPositionAfter(o), cx(n));
        }
      }
      function ox(t, e) {
        if (t.hasClass("ck-image-upload-placeholder")) {
          e.removeClass("ck-image-upload-placeholder", t);
        }
        dx(t, e, "placeholder");
      }
      function ix(t, e, n, o) {
        const i = ax(e);
        e.insert(e.createPositionAt(t, "end"), i);
        n.on("change:uploadedPercent", (t, e, n) => {
          o.change((t) => {
            t.setStyle("width", n + "%", i);
          });
        });
      }
      function rx(t, e) {
        dx(t, e, "progressBar");
      }
      function sx(t, e, n) {
        const o = e.createUIElement("div", {
          class: "ck-image-upload-complete-icon",
        });
        e.insert(e.createPositionAt(t, "end"), o);
        setTimeout(() => {
          n.change((t) => t.remove(t.createRangeOn(o)));
        }, 3e3);
      }
      function ax(t) {
        const e = t.createUIElement("div", { class: "ck-progress-bar" });
        t.setCustomProperty("progressBar", true, e);
        return e;
      }
      function cx(t) {
        const e = t.createUIElement("div", {
          class: "ck-upload-placeholder-loader",
        });
        t.setCustomProperty("placeholder", true, e);
        return e;
      }
      function lx(t, e) {
        for (const n of t.getChildren()) {
          if (n.getCustomProperty(e)) {
            return n;
          }
        }
      }
      function dx(t, e, n) {
        const o = lx(t, n);
        if (o) {
          e.remove(e.createRangeOn(o));
        }
      }
      function ux(t, e, n) {
        if (n.data) {
          const o = MC(t);
          e.setAttribute("src", n.data, o);
        }
      }
      class hx extends Fy {
        static get pluginName() {
          return "Notification";
        }
        init() {
          this.on(
            "show:warning",
            (t, e) => {
              window.alert(e.message);
            },
            { priority: "lowest" }
          );
        }
        showSuccess(t, e = {}) {
          this._showNotification({
            message: t,
            type: "success",
            namespace: e.namespace,
            title: e.title,
          });
        }
        showInfo(t, e = {}) {
          this._showNotification({
            message: t,
            type: "info",
            namespace: e.namespace,
            title: e.title,
          });
        }
        showWarning(t, e = {}) {
          this._showNotification({
            message: t,
            type: "warning",
            namespace: e.namespace,
            title: e.title,
          });
        }
        _showNotification(t) {
          const e = `show:${t.type}` + (t.namespace ? `:${t.namespace}` : "");
          this.fire(e, {
            message: t.message,
            type: t.type,
            title: t.title || "",
          });
        }
      }
      class fx {
        constructor(t) {
          this.document = t;
        }
        createDocumentFragment(t) {
          return new Yl(this.document, t);
        }
        createElement(t, e, n) {
          return new Vc(this.document, t, e, n);
        }
        createText(t) {
          return new zs(this.document, t);
        }
        clone(t, e = false) {
          return t._clone(e);
        }
        appendChild(t, e) {
          return e._appendChild(t);
        }
        insertChild(t, e, n) {
          return n._insertChild(t, e);
        }
        removeChildren(t, e, n) {
          return n._removeChildren(t, e);
        }
        remove(t) {
          const e = t.parent;
          if (e) {
            return this.removeChildren(e.getChildIndex(t), 1, e);
          }
          return [];
        }
        replace(t, e) {
          const n = t.parent;
          if (n) {
            const o = n.getChildIndex(t);
            this.removeChildren(o, 1, n);
            this.insertChild(o, e, n);
            return true;
          }
          return false;
        }
        unwrapElement(t) {
          const e = t.parent;
          if (e) {
            const n = e.getChildIndex(t);
            this.remove(t);
            this.insertChild(n, t.getChildren(), e);
          }
        }
        rename(t, e) {
          const n = new Vc(
            this.document,
            t,
            e.getAttributes(),
            e.getChildren()
          );
          return this.replace(e, n) ? n : null;
        }
        setAttribute(t, e, n) {
          n._setAttribute(t, e);
        }
        removeAttribute(t, e) {
          e._removeAttribute(t);
        }
        addClass(t, e) {
          e._addClass(t);
        }
        removeClass(t, e) {
          e._removeClass(t);
        }
        setStyle(t, e, n) {
          if (R(t) && n === undefined) {
            n = e;
          }
          n._setStyle(t, e);
        }
        removeStyle(t, e) {
          e._removeStyle(t);
        }
        setCustomProperty(t, e, n) {
          n._setCustomProperty(t, e);
        }
        removeCustomProperty(t, e) {
          return e._removeCustomProperty(t);
        }
        createPositionAt(t, e) {
          return ul._createAt(t, e);
        }
        createPositionAfter(t) {
          return ul._createAfter(t);
        }
        createPositionBefore(t) {
          return ul._createBefore(t);
        }
        createRange(t, e) {
          return new hl(t, e);
        }
        createRangeOn(t) {
          return hl._createOn(t);
        }
        createRangeIn(t) {
          return hl._createIn(t);
        }
        createSelection(t, e, n) {
          return new pl(t, e, n);
        }
      }
      class gx extends i_ {
        refresh() {
          const t = this.editor.model.document.selection.getSelectedElement();
          const e = (t && t.name === "image") || false;
          this.isEnabled = NC(this.editor.model) || e;
        }
        execute(t) {
          const e = this.editor;
          const n = e.model;
          const o = e.plugins.get(Vy);
          n.change((e) => {
            const i = Array.isArray(t.file) ? t.file : [t.file];
            for (const t of i) {
              px(e, n, o, t);
            }
          });
        }
      }
      function px(t, e, n, o) {
        const i = n.createLoader(o);
        if (!i) {
          return;
        }
        FC(t, e, { uploadId: i.id });
      }
      class mx extends t_ {
        static get requires() {
          return [Vy, hx, R_];
        }
        static get pluginName() {
          return "ImageUploadEditing";
        }
        constructor(t) {
          super(t);
          t.config.define("image", {
            upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] },
          });
        }
        init() {
          const t = this.editor;
          const e = t.model.document;
          const n = t.model.schema;
          const o = t.conversion;
          const i = t.plugins.get(Vy);
          const r = Dy(t.config.get("image.upload.types"));
          n.extend("image", { allowAttributes: ["uploadId", "uploadStatus"] });
          t.commands.add("imageUpload", new gx(t));
          o.for("upcast").attributeToAttribute({
            view: { name: "img", key: "uploadId" },
            model: "uploadId",
          });
          this.listenTo(t.editing.view.document, "clipboardInput", (e, n) => {
            if (kx(n.dataTransfer)) {
              return;
            }
            const o = Array.from(n.dataTransfer.files).filter((t) => {
              if (!t) {
                return false;
              }
              return r.test(t.type);
            });
            const i = n.targetRanges.map((e) =>
              t.editing.mapper.toModelRange(e)
            );
            t.model.change((n) => {
              n.setSelection(i);
              if (o.length) {
                e.stop();
                t.model.enqueueChange("default", () => {
                  t.execute("imageUpload", { file: o });
                });
              }
            });
          });
          this.listenTo(t.plugins.get(R_), "inputTransformation", (e, n) => {
            const o = Array.from(t.editing.view.createRangeIn(n.content))
              .filter(
                (t) => By(t.item) && !t.item.getAttribute("uploadProcessed")
              )
              .map((t) => ({ promise: Ty(t.item), imageElement: t.item }));
            if (!o.length) {
              return;
            }
            const r = new fx(t.editing.view.document);
            for (const t of o) {
              r.setAttribute("uploadProcessed", true, t.imageElement);
              const e = i.createLoader(t.promise);
              if (e) {
                r.setAttribute("src", "", t.imageElement);
                r.setAttribute("uploadId", e.id, t.imageElement);
              }
            }
          });
          t.editing.view.document.on("dragover", (t, e) => {
            e.preventDefault();
          });
          e.on("change", () => {
            const n = e.differ.getChanges({ includeChangesInGraveyard: true });
            for (const e of n) {
              if (e.type == "insert" && e.name != "$text") {
                const n = e.position.nodeAfter;
                const o = e.position.root.rootName == "$graveyard";
                for (const e of bx(t, n)) {
                  const t = e.getAttribute("uploadId");
                  if (!t) {
                    continue;
                  }
                  const n = i.loaders.get(t);
                  if (!n) {
                    continue;
                  }
                  if (o) {
                    n.abort();
                  } else if (n.status == "idle") {
                    this._readAndUpload(n, e);
                  }
                }
              }
            }
          });
        }
        _readAndUpload(t, e) {
          const n = this.editor;
          const o = n.model;
          const i = n.locale.t;
          const r = n.plugins.get(Vy);
          const s = n.plugins.get(hx);
          o.enqueueChange("transparent", (t) => {
            t.setAttribute("uploadStatus", "reading", e);
          });
          return t
            .read()
            .then(() => {
              const i = t.upload();
              if (El.isSafari) {
                const t = n.editing.mapper.toViewElement(e);
                const o = MC(t);
                n.editing.view.once("render", () => {
                  if (!o.parent) {
                    return;
                  }
                  const t = n.editing.view.domConverter.mapViewToDom(o.parent);
                  if (!t) {
                    return;
                  }
                  const e = t.style.display;
                  t.style.display = "none";
                  t._ckHack = t.offsetHeight;
                  t.style.display = e;
                });
              }
              o.enqueueChange("transparent", (t) => {
                t.setAttribute("uploadStatus", "uploading", e);
              });
              return i;
            })
            .then((t) => {
              o.enqueueChange("transparent", (n) => {
                n.setAttributes(
                  { uploadStatus: "complete", src: t.default },
                  e
                );
                this._parseAndSetSrcsetAttributeOnImage(t, e, n);
              });
              a();
            })
            .catch((n) => {
              if (t.status !== "error" && t.status !== "aborted") {
                throw n;
              }
              if (t.status == "error" && n) {
                s.showWarning(n, {
                  title: i("Upload failed"),
                  namespace: "upload",
                });
              }
              a();
              o.enqueueChange("transparent", (t) => {
                t.remove(e);
              });
            });
          function a() {
            o.enqueueChange("transparent", (t) => {
              t.removeAttribute("uploadId", e);
              t.removeAttribute("uploadStatus", e);
            });
            r.destroyLoader(t);
          }
        }
        _parseAndSetSrcsetAttributeOnImage(t, e, n) {
          let o = 0;
          const i = Object.keys(t)
            .filter((t) => {
              const e = parseInt(t, 10);
              if (!isNaN(e)) {
                o = Math.max(o, e);
                return true;
              }
            })
            .map((e) => `${t[e]} ${e}w`)
            .join(", ");
          if (i != "") {
            n.setAttribute("srcset", { data: i, width: o }, e);
          }
        }
      }
      function kx(t) {
        return (
          Array.from(t.types).includes("text/html") &&
          t.getData("text/html") !== ""
        );
      }
      function bx(t, e) {
        return Array.from(t.model.createRangeOn(e))
          .filter((t) => t.item.is("element", "image"))
          .map((t) => t.item);
      }
      class wx extends t_ {
        static get pluginName() {
          return "ImageUpload";
        }
        static get requires() {
          return [mx, Ry, Zy];
        }
      }
      class _x extends i_ {
        constructor(t) {
          super(t);
          this._childCommands = [];
        }
        refresh() {}
        execute(...t) {
          const e = this._getFirstEnabledCommand();
          return e.execute(t);
        }
        registerChildCommand(t) {
          this._childCommands.push(t);
          t.on("change:isEnabled", () => this._checkEnabled());
          this._checkEnabled();
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand();
        }
        _getFirstEnabledCommand() {
          return this._childCommands.find((t) => t.isEnabled);
        }
      }
      class Ax extends t_ {
        static get pluginName() {
          return "IndentEditing";
        }
        init() {
          const t = this.editor;
          t.commands.add("indent", new _x(t));
          t.commands.add("outdent", new _x(t));
        }
      }
      var Cx =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95L5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>';
      var vx =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
      class yx extends t_ {
        static get pluginName() {
          return "IndentUI";
        }
        init() {
          const t = this.editor;
          const e = t.locale;
          const n = t.t;
          const o = e.uiLanguageDirection == "ltr" ? Cx : vx;
          const i = e.uiLanguageDirection == "ltr" ? vx : Cx;
          this._defineButton("indent", n("Increase indent"), o);
          this._defineButton("outdent", n("Decrease indent"), i);
        }
        _defineButton(t, e, n) {
          const o = this.editor;
          o.ui.componentFactory.add(t, (i) => {
            const r = o.commands.get(t);
            const s = new ow(i);
            s.set({ label: e, icon: n, tooltip: true });
            s.bind("isOn", "isEnabled").to(r, "value", "isEnabled");
            this.listenTo(s, "execute", () => {
              o.execute(t);
              o.editing.view.focus();
            });
            return s;
          });
        }
      }
      class xx extends t_ {
        static get pluginName() {
          return "Indent";
        }
        static get requires() {
          return [Ax, yx];
        }
      }
      class Ex extends t_ {
        static get pluginName() {
          return "TwoStepCaretMovement";
        }
        constructor(t) {
          super(t);
          this.attributes = new Set();
          this._overrideUid = null;
        }
        init() {
          const t = this.editor;
          const e = t.model;
          const n = t.editing.view;
          const o = t.locale;
          const i = e.document.selection;
          this.listenTo(
            n.document,
            "keydown",
            (t, e) => {
              if (!i.isCollapsed) {
                return;
              }
              if (e.shiftKey || e.altKey || e.ctrlKey) {
                return;
              }
              const n = e.keyCode == Fl.arrowright;
              const r = e.keyCode == Fl.arrowleft;
              if (!n && !r) {
                return;
              }
              const s = o.contentLanguageDirection;
              let a = false;
              if ((s === "ltr" && n) || (s === "rtl" && r)) {
                a = this._handleForwardMovement(e);
              } else {
                a = this._handleBackwardMovement(e);
              }
              if (a === true) {
                t.stop();
              }
            },
            { priority: is.get("high") + 1 }
          );
          this._isNextGravityRestorationSkipped = false;
          this.listenTo(i, "change:range", (t, e) => {
            if (this._isNextGravityRestorationSkipped) {
              this._isNextGravityRestorationSkipped = false;
              return;
            }
            if (!this._isGravityOverridden) {
              return;
            }
            if (!e.directChange && Bx(i.getFirstPosition(), this.attributes)) {
              return;
            }
            this._restoreGravity();
          });
        }
        registerAttribute(t) {
          this.attributes.add(t);
        }
        _handleForwardMovement(t) {
          const e = this.attributes;
          const n = this.editor.model;
          const o = n.document.selection;
          const i = o.getFirstPosition();
          if (this._isGravityOverridden) {
            return false;
          }
          if (i.isAtStart && Sx(o, e)) {
            return false;
          }
          if (Bx(i, e)) {
            Dx(t);
            this._overrideGravity();
            return true;
          }
        }
        _handleBackwardMovement(t) {
          const e = this.attributes;
          const n = this.editor.model;
          const o = n.document.selection;
          const i = o.getFirstPosition();
          if (this._isGravityOverridden) {
            Dx(t);
            this._restoreGravity();
            Px(n, e, i);
            return true;
          } else {
            if (i.isAtStart) {
              if (Sx(o, e)) {
                Dx(t);
                Px(n, e, i);
                return true;
              }
              return false;
            }
            if (Tx(i, e)) {
              if (i.isAtEnd && !Sx(o, e) && Bx(i, e)) {
                Dx(t);
                Px(n, e, i);
                return true;
              }
              this._isNextGravityRestorationSkipped = true;
              this._overrideGravity();
              return false;
            }
          }
        }
        get _isGravityOverridden() {
          return !!this._overrideUid;
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((t) =>
            t.overrideSelectionGravity()
          );
        }
        _restoreGravity() {
          this.editor.model.change((t) => {
            t.restoreSelectionGravity(this._overrideUid);
            this._overrideUid = null;
          });
        }
      }
      function Sx(t, e) {
        for (const n of e) {
          if (t.hasAttribute(n)) {
            return true;
          }
        }
        return false;
      }
      function Px(t, e, n) {
        const o = n.nodeBefore;
        t.change((t) => {
          if (o) {
            t.setSelectionAttribute(o.getAttributes());
          } else {
            t.removeSelectionAttribute(e);
          }
        });
      }
      function Dx(t) {
        t.preventDefault();
      }
      function Tx(t, e) {
        const n = t.getShiftedBy(-1);
        return Bx(n, e);
      }
      function Bx(t, e) {
        const { nodeBefore: n, nodeAfter: o } = t;
        for (const t of e) {
          const e = n ? n.getAttribute(t) : undefined;
          const i = o ? o.getAttribute(t) : undefined;
          if (i !== e) {
            return true;
          }
        }
        return false;
      }
      function Ix(t, e, n, o) {
        return o.createRange(Ox(t, e, n, true, o), Ox(t, e, n, false, o));
      }
      function Ox(t, e, n, o, i) {
        let r = t.textNode || (o ? t.nodeBefore : t.nodeAfter);
        let s = null;
        while (r && r.getAttribute(e) == n) {
          s = r;
          r = o ? r.previousSibling : r.nextSibling;
        }
        return s ? i.createPositionAt(s, o ? "before" : "after") : t;
      }
      function Rx(t, e, n, o) {
        const i = t.editing.view;
        const r = new Set();
        i.document.registerPostFixer((i) => {
          const s = t.model.document.selection;
          let a = false;
          if (s.hasAttribute(e)) {
            const c = Ix(s.getFirstPosition(), e, s.getAttribute(e), t.model);
            const l = t.editing.mapper.toViewRange(c);
            for (const t of l.getItems()) {
              if (t.is("element", n) && !t.hasClass(o)) {
                i.addClass(o, t);
                r.add(t);
                a = true;
              }
            }
          }
          return a;
        });
        t.conversion.for("editingDowncast").add((t) => {
          t.on("insert", e, { priority: "highest" });
          t.on("remove", e, { priority: "highest" });
          t.on("attribute", e, { priority: "highest" });
          t.on("selection", e, { priority: "highest" });
          function e() {
            i.change((t) => {
              for (const e of r.values()) {
                t.removeClass(o, e);
                r.delete(e);
              }
            });
          }
        });
      }
      class Fx {
        constructor() {
          this._definitions = new Set();
        }
        get length() {
          return this._definitions.size;
        }
        add(t) {
          if (Array.isArray(t)) {
            t.forEach((t) => this._definitions.add(t));
          } else {
            this._definitions.add(t);
          }
        }
        getDispatcher() {
          return (t) => {
            t.on(
              "attribute:linkHref",
              (t, e, n) => {
                if (!n.consumable.test(e.item, "attribute:linkHref")) {
                  return;
                }
                const o = n.writer;
                const i = o.document.selection;
                for (const t of this._definitions) {
                  const r = o.createAttributeElement("a", t.attributes, {
                    priority: 5,
                  });
                  o.setCustomProperty("link", true, r);
                  if (t.callback(e.attributeNewValue)) {
                    if (e.item.is("selection")) {
                      o.wrap(i.getFirstRange(), r);
                    } else {
                      o.wrap(n.mapper.toViewRange(e.range), r);
                    }
                  } else {
                    o.unwrap(n.mapper.toViewRange(e.range), r);
                  }
                }
              },
              { priority: "high" }
            );
          };
        }
        getDispatcherForLinkedImage() {
          return (t) => {
            t.on("attribute:linkHref:image", (t, e, n) => {
              const o = n.mapper.toViewElement(e.item);
              const i = Array.from(o.getChildren()).find((t) => t.name === "a");
              for (const t of this._definitions) {
                const o = qs(t.attributes);
                if (t.callback(e.attributeNewValue)) {
                  for (const [t, e] of o) {
                    if (t === "class") {
                      n.writer.addClass(e, i);
                    } else {
                      n.writer.setAttribute(t, e, i);
                    }
                  }
                } else {
                  for (const [t, e] of o) {
                    if (t === "class") {
                      n.writer.removeClass(e, i);
                    } else {
                      n.writer.removeAttribute(t, i);
                    }
                  }
                }
              }
            });
          };
        }
      }
      function Nx(t, e, n) {
        var o = t.length;
        n = n === undefined ? o : n;
        return !e && n >= o ? t : Ia(t, e, n);
      }
      var Mx = Nx;
      var Vx = "\\ud800-\\udfff",
        Lx = "\\u0300-\\u036f",
        zx = "\\ufe20-\\ufe2f",
        jx = "\\u20d0-\\u20ff",
        Kx = Lx + zx + jx,
        qx = "\\ufe0e\\ufe0f";
      var $x = "\\u200d";
      var Wx = RegExp("[" + $x + Vx + Kx + qx + "]");
      function Gx(t) {
        return Wx.test(t);
      }
      var Ux = Gx;
      function Hx(t) {
        return t.split("");
      }
      var Jx = Hx;
      var Yx = "\\ud800-\\udfff",
        Qx = "\\u0300-\\u036f",
        Xx = "\\ufe20-\\ufe2f",
        Zx = "\\u20d0-\\u20ff",
        tE = Qx + Xx + Zx,
        eE = "\\ufe0e\\ufe0f";
      var nE = "[" + Yx + "]",
        oE = "[" + tE + "]",
        iE = "\\ud83c[\\udffb-\\udfff]",
        rE = "(?:" + oE + "|" + iE + ")",
        sE = "[^" + Yx + "]",
        aE = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        cE = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        lE = "\\u200d";
      var dE = rE + "?",
        uE = "[" + eE + "]?",
        hE = "(?:" + lE + "(?:" + [sE, aE, cE].join("|") + ")" + uE + dE + ")*",
        fE = uE + dE + hE,
        gE = "(?:" + [sE + oE + "?", oE, aE, cE, nE].join("|") + ")";
      var pE = RegExp(iE + "(?=" + iE + ")|" + gE + fE, "g");
      function mE(t) {
        return t.match(pE) || [];
      }
      var kE = mE;
      function bE(t) {
        return Ux(t) ? kE(t) : Jx(t);
      }
      var wE = bE;
      function _E(t) {
        return function (e) {
          e = Aa(e);
          var n = Ux(e) ? wE(e) : undefined;
          var o = n ? n[0] : e.charAt(0);
          var i = n ? Mx(n, 1).join("") : e.slice(1);
          return o[t]() + i;
        };
      }
      var AE = _E;
      var CE = AE("toUpperCase");
      var vE = CE;
      const yE = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g;
      const xE = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
      const EE = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i;
      const SE = /^((\w+:(\/{2,})?)|(\W))/i;
      const PE = "Ctrl+K";
      function DE(t) {
        return t.is("attributeElement") && !!t.getCustomProperty("link");
      }
      function TE(t, { writer: e }) {
        const n = e.createAttributeElement("a", { href: t }, { priority: 5 });
        e.setCustomProperty("link", true, n);
        return n;
      }
      function BE(t) {
        t = String(t);
        return IE(t) ? t : "#";
      }
      function IE(t) {
        const e = t.replace(yE, "");
        return e.match(xE);
      }
      function OE(t, e) {
        const n = {
          "Open in a new tab": t("Open in a new tab"),
          Downloadable: t("Downloadable"),
        };
        e.forEach((t) => {
          if (t.label && n[t.label]) {
            t.label = n[t.label];
          }
          return t;
        });
        return e;
      }
      function RE(t) {
        const e = [];
        if (t) {
          for (const [n, o] of Object.entries(t)) {
            const t = Object.assign({}, o, { id: `link${vE(n)}` });
            e.push(t);
          }
        }
        return e;
      }
      function FE(t, e) {
        if (!t) {
          return false;
        }
        return (
          t.is("element", "image") && e.checkAttribute("image", "linkHref")
        );
      }
      function NE(t) {
        return EE.test(t);
      }
      function ME(t, e) {
        const n = NE(t) ? "mailto:" : e;
        const o = !!n && !SE.test(t);
        return t && o ? n + t : t;
      }
      class VE extends i_ {
        constructor(t) {
          super(t);
          this.manualDecorators = new vs();
          this.automaticDecorators = new Fx();
        }
        restoreManualDecoratorStates() {
          for (const t of this.manualDecorators) {
            t.value = this._getDecoratorStateFromModel(t.id);
          }
        }
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          const n = Jw(e.selection.getSelectedBlocks());
          if (FE(n, t.schema)) {
            this.value = n.getAttribute("linkHref");
            this.isEnabled = t.schema.checkAttribute(n, "linkHref");
          } else {
            this.value = e.selection.getAttribute("linkHref");
            this.isEnabled = t.schema.checkAttributeInSelection(
              e.selection,
              "linkHref"
            );
          }
          for (const t of this.manualDecorators) {
            t.value = this._getDecoratorStateFromModel(t.id);
          }
        }
        execute(t, e = {}) {
          const n = this.editor.model;
          const o = n.document.selection;
          const i = [];
          const r = [];
          for (const t in e) {
            if (e[t]) {
              i.push(t);
            } else {
              r.push(t);
            }
          }
          n.change((e) => {
            if (o.isCollapsed) {
              const s = o.getFirstPosition();
              if (o.hasAttribute("linkHref")) {
                const a = Ix(s, "linkHref", o.getAttribute("linkHref"), n);
                e.setAttribute("linkHref", t, a);
                i.forEach((t) => {
                  e.setAttribute(t, true, a);
                });
                r.forEach((t) => {
                  e.removeAttribute(t, a);
                });
                e.setSelection(e.createPositionAfter(a.end.nodeBefore));
              } else if (t !== "") {
                const r = qs(o.getAttributes());
                r.set("linkHref", t);
                i.forEach((t) => {
                  r.set(t, true);
                });
                const a = e.createText(t, r);
                n.insertContent(a, s);
                e.setSelection(e.createPositionAfter(a));
              }
              ["linkHref", ...i, ...r].forEach((t) => {
                e.removeSelectionAttribute(t);
              });
            } else {
              const s = n.schema.getValidRanges(o.getRanges(), "linkHref");
              const a = [];
              for (const t of o.getSelectedBlocks()) {
                if (n.schema.checkAttribute(t, "linkHref")) {
                  a.push(e.createRangeOn(t));
                }
              }
              const c = a.slice();
              for (const t of s) {
                if (this._isRangeToUpdate(t, a)) {
                  c.push(t);
                }
              }
              for (const n of c) {
                e.setAttribute("linkHref", t, n);
                i.forEach((t) => {
                  e.setAttribute(t, true, n);
                });
                r.forEach((t) => {
                  e.removeAttribute(t, n);
                });
              }
            }
          });
        }
        _getDecoratorStateFromModel(t) {
          const e = this.editor.model;
          const n = e.document;
          const o = Jw(n.selection.getSelectedBlocks());
          if (FE(o, e.schema)) {
            return o.getAttribute(t);
          }
          return n.selection.getAttribute(t);
        }
        _isRangeToUpdate(t, e) {
          for (const n of e) {
            if (n.containsRange(t)) {
              return false;
            }
          }
          return true;
        }
      }
      class LE extends i_ {
        refresh() {
          const t = this.editor.model;
          const e = t.document;
          const n = Jw(e.selection.getSelectedBlocks());
          if (FE(n, t.schema)) {
            this.isEnabled = t.schema.checkAttribute(n, "linkHref");
          } else {
            this.isEnabled = t.schema.checkAttributeInSelection(
              e.selection,
              "linkHref"
            );
          }
        }
        execute() {
          const t = this.editor;
          const e = this.editor.model;
          const n = e.document.selection;
          const o = t.commands.get("link");
          e.change((t) => {
            const i = n.isCollapsed
              ? [
                  Ix(
                    n.getFirstPosition(),
                    "linkHref",
                    n.getAttribute("linkHref"),
                    e
                  ),
                ]
              : n.getRanges();
            for (const e of i) {
              t.removeAttribute("linkHref", e);
              if (o) {
                for (const n of o.manualDecorators) {
                  t.removeAttribute(n.id, e);
                }
              }
            }
          });
        }
      }
      class zE {
        constructor({ id: t, label: e, attributes: n, defaultValue: o }) {
          this.id = t;
          this.set("value");
          this.defaultValue = o;
          this.label = e;
          this.attributes = n;
        }
      }
      Cs(zE, Yc);
      var jE = n(40);
      var KE = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      KE.insert = "head";
      KE.singleton = true;
      var qE = ik()(jE["a"], KE);
      var $E = jE["a"].locals || {};
      const WE = "ck-link_selected";
      const GE = "automatic";
      const UE = "manual";
      const HE = /^(https?:)?\/\//;
      class JE extends t_ {
        static get pluginName() {
          return "LinkEditing";
        }
        static get requires() {
          return [Ex, pA, R_];
        }
        constructor(t) {
          super(t);
          t.config.define("link", { addTargetToExternalLinks: false });
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: "linkHref" });
          t.conversion
            .for("dataDowncast")
            .attributeToElement({ model: "linkHref", view: TE });
          t.conversion.for("editingDowncast").attributeToElement({
            model: "linkHref",
            view: (t, e) => TE(BE(t), e),
          });
          t.conversion.for("upcast").elementToAttribute({
            view: { name: "a", attributes: { href: true } },
            model: { key: "linkHref", value: (t) => t.getAttribute("href") },
          });
          t.commands.add("link", new VE(t));
          t.commands.add("unlink", new LE(t));
          const e = OE(t.t, RE(t.config.get("link.decorators")));
          this._enableAutomaticDecorators(e.filter((t) => t.mode === GE));
          this._enableManualDecorators(e.filter((t) => t.mode === UE));
          const n = t.plugins.get(Ex);
          n.registerAttribute("linkHref");
          Rx(t, "linkHref", "a", WE);
          this._enableInsertContentSelectionAttributesFixer();
          this._enableClickingAfterLink();
          this._enableTypingOverLink();
          this._handleDeleteContentAfterLink();
        }
        _enableAutomaticDecorators(t) {
          const e = this.editor;
          const n = e.commands.get("link");
          const o = n.automaticDecorators;
          if (e.config.get("link.addTargetToExternalLinks")) {
            o.add({
              id: "linkIsExternal",
              mode: GE,
              callback: (t) => HE.test(t),
              attributes: { target: "_blank", rel: "noopener noreferrer" },
            });
          }
          o.add(t);
          if (o.length) {
            e.conversion.for("downcast").add(o.getDispatcher());
          }
        }
        _enableManualDecorators(t) {
          if (!t.length) {
            return;
          }
          const e = this.editor;
          const n = e.commands.get("link");
          const o = n.manualDecorators;
          t.forEach((t) => {
            e.model.schema.extend("$text", { allowAttributes: t.id });
            o.add(new zE(t));
            e.conversion.for("downcast").attributeToElement({
              model: t.id,
              view: (e, { writer: n }) => {
                if (e) {
                  const e = o.get(t.id).attributes;
                  const i = n.createAttributeElement("a", e, { priority: 5 });
                  n.setCustomProperty("link", true, i);
                  return i;
                }
              },
            });
            e.conversion.for("upcast").elementToAttribute({
              view: { name: "a", attributes: o.get(t.id).attributes },
              model: { key: t.id },
            });
          });
        }
        _enableInsertContentSelectionAttributesFixer() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const o = t.commands.get("link");
          this.listenTo(
            e,
            "insertContent",
            () => {
              const t = n.anchor.nodeBefore;
              const i = n.anchor.nodeAfter;
              if (!n.hasAttribute("linkHref")) {
                return;
              }
              if (!t) {
                return;
              }
              if (!t.hasAttribute("linkHref")) {
                return;
              }
              if (i && i.hasAttribute("linkHref")) {
                return;
              }
              e.change((t) => {
                YE(t, o.manualDecorators);
              });
            },
            { priority: "low" }
          );
        }
        _enableClickingAfterLink() {
          const t = this.editor;
          const e = t.commands.get("link");
          t.editing.view.addObserver(HC);
          let n = false;
          this.listenTo(t.editing.view.document, "mousedown", () => {
            n = true;
          });
          this.listenTo(t.editing.view.document, "selectionChange", () => {
            if (!n) {
              return;
            }
            n = false;
            const o = t.model.document.selection;
            if (!o.isCollapsed) {
              return;
            }
            if (!o.hasAttribute("linkHref")) {
              return;
            }
            const i = o.getFirstPosition();
            const r = Ix(i, "linkHref", o.getAttribute("linkHref"), t.model);
            if (i.isTouching(r.start) || i.isTouching(r.end)) {
              t.model.change((t) => {
                YE(t, e.manualDecorators);
              });
            }
          });
        }
        _enableTypingOverLink() {
          const t = this.editor;
          const e = t.editing.view;
          let n;
          let o;
          this.listenTo(
            e.document,
            "delete",
            () => {
              o = true;
            },
            { priority: "high" }
          );
          this.listenTo(
            t.model,
            "deleteContent",
            () => {
              const e = t.model.document.selection;
              if (e.isCollapsed) {
                return;
              }
              if (o) {
                o = false;
                return;
              }
              if (!XE(t)) {
                return;
              }
              if (QE(t.model)) {
                n = e.getAttributes();
              }
            },
            { priority: "high" }
          );
          this.listenTo(
            t.model,
            "insertContent",
            (e, [i]) => {
              o = false;
              if (!XE(t)) {
                return;
              }
              if (!n) {
                return;
              }
              t.model.change((t) => {
                for (const [e, o] of n) {
                  t.setAttribute(e, o, i);
                }
              });
              n = null;
            },
            { priority: "high" }
          );
        }
        _handleDeleteContentAfterLink() {
          const t = this.editor;
          const e = t.model;
          const n = e.document.selection;
          const o = t.editing.view;
          const i = t.commands.get("link");
          let r = false;
          let s = false;
          this.listenTo(
            o.document,
            "delete",
            (t, e) => {
              s = e.domEvent.keyCode === Fl.backspace;
            },
            { priority: "high" }
          );
          this.listenTo(
            e,
            "deleteContent",
            () => {
              r = false;
              const t = n.getFirstPosition();
              const o = n.getAttribute("linkHref");
              if (!o) {
                return;
              }
              const i = Ix(t, "linkHref", o, e);
              r = i.containsPosition(t) || i.end.isEqual(t);
            },
            { priority: "high" }
          );
          this.listenTo(
            e,
            "deleteContent",
            () => {
              if (!s) {
                return;
              }
              s = false;
              if (r) {
                return;
              }
              t.model.enqueueChange((t) => {
                YE(t, i.manualDecorators);
              });
            },
            { priority: "low" }
          );
        }
      }
      function YE(t, e) {
        t.removeSelectionAttribute("linkHref");
        for (const n of e) {
          t.removeSelectionAttribute(n.id);
        }
      }
      function QE(t) {
        const e = t.document.selection;
        const n = e.getFirstPosition();
        const o = e.getLastPosition();
        const i = n.nodeAfter;
        if (!i) {
          return false;
        }
        if (!i.is("$text")) {
          return false;
        }
        if (!i.hasAttribute("linkHref")) {
          return false;
        }
        const r = o.textNode || o.nodeBefore;
        if (i === r) {
          return true;
        }
        const s = Ix(n, "linkHref", i.getAttribute("linkHref"), t);
        return s.containsRange(t.createRange(n, o), true);
      }
      function XE(t) {
        const e = t.plugins.get("Input");
        return e.isInput(t.model.change((t) => t.batch));
      }
      class ZE extends eh {
        constructor(t) {
          super(t);
          this.domEventType = "click";
        }
        onDomEvent(t) {
          this.fire(t.type, t);
        }
      }
      var tS = n(41);
      var eS = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      eS.insert = "head";
      eS.singleton = true;
      var nS = ik()(tS["a"], eS);
      var oS = tS["a"].locals || {};
      class iS extends Xk {
        constructor(t, e, n) {
          super(t);
          const o = t.t;
          this.focusTracker = new Zm();
          this.keystrokes = new zm();
          this.urlInputView = this._createUrlInput(n);
          this.saveButtonView = this._createButton(
            o("Save"),
            jv,
            "ck-button-save"
          );
          this.saveButtonView.type = "submit";
          this.cancelButtonView = this._createButton(
            o("Cancel"),
            Kv,
            "ck-button-cancel",
            "cancel"
          );
          this._manualDecoratorSwitches = this._createManualDecoratorSwitches(
            e
          );
          this.children = this._createFormChildren(e.manualDecorators);
          this._focusables = new wk();
          this._focusCycler = new Tb({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          const i = ["ck", "ck-link-form", "ck-responsive-form"];
          if (e.manualDecorators.length) {
            i.push("ck-link-form_layout-vertical", "ck-vertical-form");
          }
          this.setTemplate({
            tag: "form",
            attributes: { class: i, tabindex: "-1" },
            children: this.children,
          });
        }
        getDecoratorSwitchesState() {
          return Array.from(this._manualDecoratorSwitches).reduce((t, e) => {
            t[e.name] = e.isOn;
            return t;
          }, {});
        }
        render() {
          super.render();
          zv({ view: this });
          const t = [
            this.urlInputView,
            ...this._manualDecoratorSwitches,
            this.saveButtonView,
            this.cancelButtonView,
          ];
          t.forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
          this.keystrokes.listenTo(this.element);
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createUrlInput(t = "https://") {
          const e = this.locale.t;
          const n = new Iv(this.locale, Vv);
          n.label = e("Link URL");
          n.fieldView.placeholder = t + "example.com";
          return n;
        }
        _createButton(t, e, n, o) {
          const i = new ow(this.locale);
          i.set({ label: t, icon: e, tooltip: true });
          i.extendTemplate({ attributes: { class: n } });
          if (o) {
            i.delegate("execute").to(this, o);
          }
          return i;
        }
        _createManualDecoratorSwitches(t) {
          const e = this.createCollection();
          for (const n of t.manualDecorators) {
            const o = new kw(this.locale);
            o.set({ name: n.id, label: n.label, withText: true });
            o.bind("isOn").toMany([n, t], "value", (t, e) =>
              e === undefined && t === undefined ? n.defaultValue : t
            );
            o.on("execute", () => {
              n.set("value", !o.isOn);
            });
            e.add(o);
          }
          return e;
        }
        _createFormChildren(t) {
          const e = this.createCollection();
          e.add(this.urlInputView);
          if (t.length) {
            const t = new Xk();
            t.setTemplate({
              tag: "ul",
              children: this._manualDecoratorSwitches.map((t) => ({
                tag: "li",
                children: [t],
                attributes: { class: ["ck", "ck-list__item"] },
              })),
              attributes: { class: ["ck", "ck-reset", "ck-list"] },
            });
            e.add(t);
          }
          e.add(this.saveButtonView);
          e.add(this.cancelButtonView);
          return e;
        }
      }
      var rS =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562l-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>';
      var sS =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7.3 17.37l-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506L13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5L9.375 17H19v1.5H8z"/></svg>';
      var aS = n(42);
      var cS = {
        injectType: "singletonStyleTag",
        attributes: { "data-cke": true },
      };
      cS.insert = "head";
      cS.singleton = true;
      var lS = ik()(aS["a"], cS);
      var dS = aS["a"].locals || {};
      class uS extends Xk {
        constructor(t) {
          super(t);
          const e = t.t;
          this.focusTracker = new Zm();
          this.keystrokes = new zm();
          this.previewButtonView = this._createPreviewButton();
          this.unlinkButtonView = this._createButton(e("Unlink"), rS, "unlink");
          this.editButtonView = this._createButton(e("Edit link"), sS, "edit");
          this.set("href");
          this._focusables = new wk();
          this._focusCycler = new Tb({
            focusables: this._focusables,
            focusTracker: this.focusTracker,
            keystrokeHandler: this.keystrokes,
            actions: { focusPrevious: "shift + tab", focusNext: "tab" },
          });
          this.setTemplate({
            tag: "div",
            attributes: {
              class: ["ck", "ck-link-actions", "ck-responsive-form"],
              tabindex: "-1",
            },
            children: [
              this.previewButtonView,
              this.editButtonView,
              this.unlinkButtonView,
            ],
          });
        }
        render() {
          super.render();
          const t = [
            this.previewButtonView,
            this.editButtonView,
            this.unlinkButtonView,
          ];
          t.forEach((t) => {
            this._focusables.add(t);
            this.focusTracker.add(t.element);
          });
          this.keystrokes.listenTo(this.element);
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createButton(t, e, n) {
          const o = new ow(this.locale);
          o.set({ label: t, icon: e, tooltip: true });
          o.delegate("execute").to(this, n);
          return o;
        }
        _createPreviewButton() {
          const t = new ow(this.locale);
          const e = this.bindTemplate;
          const n = this.t;
          t.set({ withText: true, tooltip: n("Open link in new tab") });
          t.extendTemplate({
            attributes: {
              class: ["ck", "ck-link-actions__preview"],
              href: e.to("href", (t) => t && BE(t)),
              target: "_blank",
              rel: "noopener noreferrer",
            },
          });
          t.bind("label").to(
            this,
            "href",
            (t) => t || n("This link has no URL")
          );
          t.bind("isEnabled").to(this, "href", (t) => !!t);
          t.template.tag = "a";
          t.template.eventListeners = {};
          return t;
        }
      }
      var hS =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>';
      const fS = "link-ui";
      class gS extends t_ {
        static get requires() {
          return [ly];
        }
        static get pluginName() {
          return "LinkUI";
        }
        init() {
          const t = this.editor;
          t.editing.view.addObserver(ZE);
          this.actionsView = this._createActionsView();
          this.formView = this._createFormView();
          this._balloon = t.plugins.get(ly);
          this._createToolbarLinkButton();
          this._enableUserBalloonInteractions();
          t.conversion.for("editingDowncast").markerToHighlight({
            model: fS,
            view: { classes: ["ck-fake-link-selection"] },
          });
          t.conversion.for("editingDowncast").markerToElement({
            model: fS,
            view: {
              name: "span",
              classes: [
                "ck-fake-link-selection",
                "ck-fake-link-selection_collapsed",
              ],
            },
          });
        }
        destroy() {
          super.destroy();
          this.formView.destroy();
        }
        _createActionsView() {
          const t = this.editor;
          const e = new uS(t.locale);
          const n = t.commands.get("link");
          const o = t.commands.get("unlink");
          e.bind("href").to(n, "value");
          e.editButtonView.bind("isEnabled").to(n);
          e.unlinkButtonView.bind("isEnabled").to(o);
          this.listenTo(e, "edit", () => {
            this._addFormView();
          });
          this.listenTo(e, "unlink", () => {
            t.execute("unlink");
            this._hideUI();
          });
          e.keystrokes.set("Esc", (t, e) => {
            this._hideUI();
            e();
          });
          e.keystrokes.set(PE, (t, e) => {
            this._addFormView();
            e();
          });
          return e;
        }
        _createFormView() {
          const t = this.editor;
          const e = t.commands.get("link");
          const n = t.config.get("link.defaultProtocol");
          const o = new iS(t.locale, e, n);
          o.urlInputView.fieldView.bind("value").to(e, "value");
          o.urlInputView.bind("isReadOnly").to(e, "isEnabled", (t) => !t);
          o.saveButtonView.bind("isEnabled").to(e);
          this.listenTo(o, "submit", () => {
            const { value: e } = o.urlInputView.fieldView.element;
            const i = ME(e, n);
            t.execute("link", i, o.getDecoratorSwitchesState());
            this._closeFormView();
          });
          this.listenTo(o, "cancel", () => {
            this._closeFormView();
          });
          o.keystrokes.set("Esc", (t, e) => {
            this._closeFormView();
            e();
          });
          return o;
        }
        _createToolbarLinkButton() {
          const t = this.editor;
          const e = t.commands.get("link");
          const n = t.t;
          t.keystrokes.set(PE, (t, n) => {
            n();
            if (e.isEnabled) {
              this._showUI(true);
            }
          });
          t.ui.componentFactory.add("link", (t) => {
            const o = new ow(t);
            o.isEnabled = true;
            o.label = n("Link");
            o.icon = hS;
            o.keystroke = PE;
            o.tooltip = true;
            o.isToggleable = true;
            o.bind("isEnabled").to(e, "isEnabled");
            o.bind("isOn").to(e, "value", (t) => !!t);
            this.listenTo(o, "execute", () => this._showUI(true));
            return o;
          });
        }
        _enableUserBalloonInteractions() {
          const t = this.editor.editing.view.document;
          this.listenTo(t, "click", () => {
            const t = this._getSelectedLinkElement();
            if (t) {
              this._showUI();
            }
          });
          this.editor.keystrokes.set(
            "Tab",
            (t, e) => {
              if (
                this._areActionsVisible &&
                !this.actionsView.focusTracker.isFocused
              ) {
                this.actionsView.focus();
                e();
              }
            },
            { priority: "high" }
          );
          this.editor.keystrokes.set("Esc", (t, e) => {
            if (this._isUIVisible) {
              this._hideUI();
              e();
            }
          });
          bw({
            emitter: this.formView,
            activator: () => this._isUIInPanel,
            contextElements: [this._balloon.view.element],
            callback: () => this._hideUI(),
          });
        }
        _addActionsView() {
          if (this._areActionsInPanel) {
            return;
          }
          this._balloon.add({
            view: this.actionsView,
            position: this._getBalloonPositionData(),
          });
        }
        _addFormView() {
          if (this._isFormInPanel) {
            return;
          }
          const t = this.editor;
          const e = t.commands.get("link");
          this._balloon.add({
            view: this.formView,
            position: this._getBalloonPositionData(),
          });
          if (this._balloon.visibleView === this.formView) {
            this.formView.urlInputView.fieldView.select();
          }
          this.formView.urlInputView.fieldView.element.value = e.value || "";
        }
        _closeFormView() {
          const t = this.editor.commands.get("link");
          t.restoreManualDecoratorStates();
          if (t.value !== undefined) {
            this._removeFormView();
          } else {
            this._hideUI();
          }
        }
        _removeFormView() {
          if (this._isFormInPanel) {
            this.formView.saveButtonView.focus();
            this._balloon.remove(this.formView);
            this.editor.editing.view.focus();
            this._hideFakeVisualSelection();
          }
        }
        _showUI(t = false) {
          if (!this._getSelectedLinkElement()) {
            this._showFakeVisualSelection();
            this._addActionsView();
            if (t) {
              this._balloon.showStack("main");
            }
            this._addFormView();
          } else {
            if (this._areActionsVisible) {
              this._addFormView();
            } else {
              this._addActionsView();
            }
            if (t) {
              this._balloon.showStack("main");
            }
          }
          this._startUpdatingUI();
        }
        _hideUI() {
          if (!this._isUIInPanel) {
            return;
          }
          const t = this.editor;
          this.stopListening(t.ui, "update");
          this.stopListening(this._balloon, "change:visibleView");
          t.editing.view.focus();
          this._removeFormView();
          this._balloon.remove(this.actionsView);
          this._hideFakeVisualSelection();
        }
        _startUpdatingUI() {
          const t = this.editor;
          const e = t.editing.view.document;
          let n = this._getSelectedLinkElement();
          let o = r();
          const i = () => {
            const t = this._getSelectedLinkElement();
            const e = r();
            if ((n && !t) || (!n && e !== o)) {
              this._hideUI();
            } else if (this._isUIVisible) {
              this._balloon.updatePosition(this._getBalloonPositionData());
            }
            n = t;
            o = e;
          };
          function r() {
            return e.selection.focus
              .getAncestors()
              .reverse()
              .find((t) => t.is("element"));
          }
          this.listenTo(t.ui, "update", i);
          this.listenTo(this._balloon, "change:visibleView", i);
        }
        get _isFormInPanel() {
          return this._balloon.hasView(this.formView);
        }
        get _areActionsInPanel() {
          return this._balloon.hasView(this.actionsView);
        }
        get _areActionsVisible() {
          return this._balloon.visibleView === this.actionsView;
        }
        get _isUIInPanel() {
          return this._isFormInPanel || this._areActionsInPanel;
        }
        get _isUIVisible() {
          const t = this._balloon.visibleView;
          return t == this.formView || this._areActionsVisible;
        }
        _getBalloonPositionData() {
          const t = this.editor.editing.view;
          const e = this.editor.model;
          const n = t.document;
          let o = null;
          if (e.markers.has(fS)) {
            const e = Array.from(
              this.editor.editing.mapper.markerNameToElements(fS)
            );
            const n = t.createRange(
              t.createPositionBefore(e[0]),
              t.createPositionAfter(e[e.length - 1])
            );
            o = t.domConverter.viewRangeToDom(n);
          } else {
            const e = this._getSelectedLinkElement();
            const i = n.selection.getFirstRange();
            o = e
              ? t.domConverter.mapViewToDom(e)
              : t.domConverter.viewRangeToDom(i);
          }
          return { target: o };
        }
        _getSelectedLinkElement() {
          const t = this.editor.editing.view;
          const e = t.document.selection;
          if (e.isCollapsed) {
            return pS(e.getFirstPosition());
          } else {
            const n = e.getFirstRange().getTrimmed();
            const o = pS(n.start);
            const i = pS(n.end);
            if (!o || o != i) {
              return null;
            }
            if (t.createRangeIn(o).getTrimmed().isEqual(n)) {
              return o;
            } else {
              return null;
            }
          }
        }
        _showFakeVisualSelection() {
          const t = this.editor.model;
          t.change((e) => {
            const n = t.document.selection.getFirstRange();
            if (t.markers.has(fS)) {
              e.updateMarker(fS, { range: n });
            } else {
              if (n.start.isAtEnd) {
                const o = t.document.selection.focus;
                const i = mS(n, o, e);
                e.addMarker(fS, {
                  usingOperation: false,
                  affectsData: false,
                  range: i,
                });
              } else {
                e.addMarker(fS, {
                  usingOperation: false,
                  affectsData: false,
                  range: n,
                });
              }
            }
          });
        }
        _hideFakeVisualSelection() {
          const t = this.editor.model;
          if (t.markers.has(fS)) {
            t.change((t) => {
              t.removeMarker(fS);
            });
          }
        }
      }
      function pS(t) {
        return t.getAncestors().find((t) => DE(t));
      }
      function mS(t, e, n) {
        const o = [t.start.path[0] + 1, 0];
        const i = n.createPositionFromPath(t.start.root, o, "toNext");
        const r = n.createRange(i, t.end);
        if (r.start.path[0] > t.end.path[0]) {
          return n.createRange(e);
        }
        if (i.isAtStart && i.isAtEnd) {
          return mS(r, e, n);
        }
        return r;
      }
      function kS(t, e) {
        let n = t.start;
        const o = Array.from(t.getItems()).reduce((t, o) => {
          if (!(o.is("$text") || o.is("$textProxy"))) {
            n = e.createPositionAfter(o);
            return "";
          }
          return t + o.data;
        }, "");
        return { text: o, range: e.createRange(n, t.end) };
      }
      class bS {
        constructor(t, e) {
          this.model = t;
          this.testCallback = e;
          this.hasMatch = false;
          this.set("isEnabled", true);
          this.on("change:isEnabled", () => {
            if (this.isEnabled) {
              this._startListening();
            } else {
              this.stopListening(t.document.selection);
              this.stopListening(t.document);
            }
          });
          this._startListening();
        }
        _startListening() {
          const t = this.model;
          const e = t.document;
          this.listenTo(
            e.selection,
            "change:range",
            (t, { directChange: n }) => {
              if (!n) {
                return;
              }
              if (!e.selection.isCollapsed) {
                if (this.hasMatch) {
                  this.fire("unmatched");
                  this.hasMatch = false;
                }
                return;
              }
              this._evaluateTextBeforeSelection("selection");
            }
          );
          this.listenTo(e, "change:data", (t, e) => {
            if (e.type == "transparent") {
              return;
            }
            this._evaluateTextBeforeSelection("data", { batch: e });
          });
        }
        _evaluateTextBeforeSelection(t, e = {}) {
          const n = this.model;
          const o = n.document;
          const i = o.selection;
          const r = n.createRange(
            n.createPositionAt(i.focus.parent, 0),
            i.focus
          );
          const { text: s, range: a } = kS(r, n);
          const c = this.testCallback(s);
          if (!c && this.hasMatch) {
            this.fire("unmatched");
          }
          this.hasMatch = !!c;
          if (c) {
            const n = Object.assign(e, { text: s, range: a });
            if (typeof c == "object") {
              Object.assign(n, c);
            }
            this.fire(`matched:${t}`, n);
          }
        }
      }
      Cs(bS, Yc);
      const wS = 4;
      const _S = new RegExp(
        "(^|\\s)" +
          "(" +
          "(" +
          "(?:(?:(?:https?|ftp):)?\\/\\/)" +
          "(?:\\S+(?::\\S*)?@)?" +
          "(?:" +
          "(?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.)+" +
          "(?:[a-z\\u00a1-\\uffff]{2,})" +
          ")" +
          "(?::\\d{2,5})?" +
          "(?:[/?#]\\S*)?" +
          ")" +
          "|" +
          "(" +
          "(www.|(\\S+@))" +
          "((?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.))+" +
          "(?:[a-z\\u00a1-\\uffff]{2,})" +
          ")" +
          ")$",
        "i"
      );
      const AS = 2;
      class CS extends t_ {
        static get pluginName() {
          return "AutoLink";
        }
        init() {
          const t = this.editor;
          const e = t.model.document.selection;
          e.on("change:range", () => {
            this.isEnabled = !e.anchor.parent.is("element", "codeBlock");
          });
          this._enableTypingHandling();
        }
        afterInit() {
          this._enableEnterHandling();
          this._enableShiftEnterHandling();
        }
        _enableTypingHandling() {
          const t = this.editor;
          const e = new bS(t.model, (t) => {
            if (!vS(t)) {
              return;
            }
            const e = yS(t.substr(0, t.length - 1));
            if (e) {
              return { url: e };
            }
          });
          const n = t.plugins.get("Input");
          e.on("matched:data", (e, o) => {
            const { batch: i, range: r, url: s } = o;
            if (!n.isInput(i)) {
              return;
            }
            const a = r.end.getShiftedBy(-1);
            const c = a.getShiftedBy(-s.length);
            const l = t.model.createRange(c, a);
            this._applyAutoLink(s, l);
          });
          e.bind("isEnabled").to(this);
        }
        _enableEnterHandling() {
          const t = this.editor;
          const e = t.model;
          const n = t.commands.get("enter");
          if (!n) {
            return;
          }
          n.on("execute", () => {
            const t = e.document.selection.getFirstPosition();
            if (!t.parent.previousSibling) {
              return;
            }
            const n = e.createRangeIn(t.parent.previousSibling);
            this._checkAndApplyAutoLinkOnRange(n);
          });
        }
        _enableShiftEnterHandling() {
          const t = this.editor;
          const e = t.model;
          const n = t.commands.get("shiftEnter");
          if (!n) {
            return;
          }
          n.on("execute", () => {
            const t = e.document.selection.getFirstPosition();
            const n = e.createRange(
              e.createPositionAt(t.parent, 0),
              t.getShiftedBy(-1)
            );
            this._checkAndApplyAutoLinkOnRange(n);
          });
        }
        _checkAndApplyAutoLinkOnRange(t) {
          const e = this.editor.model;
          const { text: n, range: o } = kS(t, e);
          const i = yS(n);
          if (i) {
            const t = e.createRange(o.end.getShiftedBy(-i.length), o.end);
            this._applyAutoLink(i, t);
          }
        }
        _applyAutoLink(t, e) {
          const n = this.editor.model;
          if (!this.isEnabled || !xS(e, n)) {
            return;
          }
          n.enqueueChange((n) => {
            const o = this.editor.config.get("link.defaultProtocol");
            const i = ME(t, o);
            n.setAttribute("linkHref", i, e);
          });
        }
      }
      function vS(t) {
        return (
          t.length > wS && t[t.length - 1] === " " && t[t.length - 2] !== " "
        );
      }
      function yS(t) {
        const e = _S.exec(t);
        return e ? e[AS] : null;
      }
      function xS(t, e) {
        return e.schema.checkAttributeInSelection(
          e.createSelection(t),
          "linkHref"
        );
      }
      class ES extends t_ {
        static get requires() {
          return [JE, gS, CS];
        }
        static get pluginName() {
          return "Link";
        }
      }
      class SS extends i_ {
        constructor(t, e) {
          super(t);
          this.type = e;
        }
        refresh() {
          this.value = this._getValue();
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const t = this.editor.model;
          const e = t.document;
          const n = Array.from(e.selection.getSelectedBlocks()).filter((e) =>
            DS(e, t.schema)
          );
          const o = this.value === true;
          t.change((t) => {
            if (o) {
              let e = n[n.length - 1].nextSibling;
              let o = Number.POSITIVE_INFINITY;
              let i = [];
              while (
                e &&
                e.name == "listItem" &&
                e.getAttribute("listIndent") !== 0
              ) {
                const t = e.getAttribute("listIndent");
                if (t < o) {
                  o = t;
                }
                const n = t - o;
                i.push({ element: e, listIndent: n });
                e = e.nextSibling;
              }
              i = i.reverse();
              for (const e of i) {
                t.setAttribute("listIndent", e.listIndent, e.element);
              }
            }
            if (!o) {
              let t = Number.POSITIVE_INFINITY;
              for (const e of n) {
                if (
                  e.is("element", "listItem") &&
                  e.getAttribute("listIndent") < t
                ) {
                  t = e.getAttribute("listIndent");
                }
              }
              t = t === 0 ? 1 : t;
              PS(n, true, t);
              PS(n, false, t);
            }
            for (const e of n.reverse()) {
              if (o && e.name == "listItem") {
                t.rename(e, "paragraph");
              } else if (!o && e.name != "listItem") {
                t.setAttributes({ listType: this.type, listIndent: 0 }, e);
                t.rename(e, "listItem");
              } else if (
                !o &&
                e.name == "listItem" &&
                e.getAttribute("listType") != this.type
              ) {
                t.setAttribute("listType", this.type, e);
              }
            }
            this.fire("_executeCleanup", n);
          });
        }
        _getValue() {
          const t = Jw(
            this.editor.model.document.selection.getSelectedBlocks()
          );
          return (
            !!t &&
            t.is("element", "listItem") &&
            t.getAttribute("listType") == this.type
          );
        }
        _checkEnabled() {
          if (this.value) {
            return true;
          }
          const t = this.editor.model.document.selection;
          const e = this.editor.model.schema;
          const n = Jw(t.getSelectedBlocks());
          if (!n) {
            return false;
          }
          return DS(n, e);
        }
      }
      function PS(t, e, n) {
        const o = e ? t[0] : t[t.length - 1];
        if (o.is("element", "listItem")) {
          let i = o[e ? "previousSibling" : "nextSibling"];
          let r = o.getAttribute("listIndent");
          while (
            i &&
            i.is("element", "listItem") &&
            i.getAttribute("listIndent") >= n
          ) {
            if (r > i.getAttribute("listIndent")) {
              r = i.getAttribute("listIndent");
            }
            if (i.getAttribute("listIndent") == r) {
              t[e ? "unshift" : "push"](i);
            }
            i = i[e ? "previousSibling" : "nextSibling"];
          }
        }
      }
      function DS(t, e) {
        return e.checkChild(t.parent, "listItem") && !e.isObject(t);
      }
      class TS extends i_ {
        constructor(t, e) {
          super(t);
          this._indentBy = e == "forward" ? 1 : -1;
        }
        refresh() {
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const t = this.editor.model;
          const e = t.document;
          let n = Array.from(e.selection.getSelectedBlocks());
          t.change((t) => {
            const e = n[n.length - 1];
            let o = e.nextSibling;
            while (
              o &&
              o.name == "listItem" &&
              o.getAttribute("listIndent") > e.getAttribute("listIndent")
            ) {
              n.push(o);
              o = o.nextSibling;
            }
            if (this._indentBy < 0) {
              n = n.reverse();
            }
            for (const e of n) {
              const n = e.getAttribute("listIndent") + this._indentBy;
              if (n < 0) {
                t.rename(e, "paragraph");
              } else {
                t.setAttribute("listIndent", n, e);
              }
            }
            this.fire("_executeCleanup", n);
          });
        }
        _checkEnabled() {
          const t = Jw(
            this.editor.model.document.selection.getSelectedBlocks()
          );
          if (!t || !t.is("element", "listItem")) {
            return false;
          }
          if (this._indentBy > 0) {
            const e = t.getAttribute("listIndent");
            const n = t.getAttribute("listType");
            let o = t.previousSibling;
            while (
              o &&
              o.is("element", "listItem") &&
              o.getAttribute("listIndent") >= e
            ) {
              if (o.getAttribute("listIndent") == e) {
                return o.getAttribute("listType") == n;
              }
              o = o.previousSibling;
            }
            return false;
          }
          return true;
        }
      }
      function BS(t) {
        const e = t.createContainerElement("li");
        e.getFillerOffset = zS;
        return e;
      }
      function IS(t, e) {
        const n = e.mapper;
        const o = e.writer;
        const i = t.getAttribute("listType") == "numbered" ? "ol" : "ul";
        const r = BS(o);
        const s = o.createContainerElement(i, null);
        o.insert(o.createPositionAt(s, 0), r);
        n.bindElements(t, r);
        return r;
      }
      function OS(t, e, n, o) {
        const i = e.parent;
        const r = n.mapper;
        const s = n.writer;
        let a = r.toViewPosition(o.createPositionBefore(t));
        const c = NS(t.previousSibling, {
          sameIndent: true,
          smallerIndent: true,
          listIndent: t.getAttribute("listIndent"),
        });
        const l = t.previousSibling;
        if (c && c.getAttribute("listIndent") == t.getAttribute("listIndent")) {
          const t = r.toViewElement(c);
          a = s.breakContainer(s.createPositionAfter(t));
        } else {
          if (l && l.name == "listItem") {
            a = r.toViewPosition(o.createPositionAt(l, "end"));
            const t = r.findMappedViewAncestor(a);
            const e = VS(t);
            if (e) {
              a = s.createPositionBefore(e);
            } else {
              a = s.createPositionAt(t, "end");
            }
          } else {
            a = r.toViewPosition(o.createPositionBefore(t));
          }
        }
        a = FS(a);
        s.insert(a, i);
        if (l && l.name == "listItem") {
          const t = r.toViewElement(l);
          const n = s.createRange(s.createPositionAt(t, 0), a);
          const o = n.getWalker({ ignoreElementEnd: true });
          for (const t of o) {
            if (t.item.is("element", "li")) {
              const n = s.breakContainer(s.createPositionBefore(t.item));
              const i = t.item.parent;
              const r = s.createPositionAt(e, "end");
              RS(s, r.nodeBefore, r.nodeAfter);
              s.move(s.createRangeOn(i), r);
              o.position = n;
            }
          }
        } else {
          const n = i.nextSibling;
          if (n && (n.is("element", "ul") || n.is("element", "ol"))) {
            let o = null;
            for (const e of n.getChildren()) {
              const n = r.toModelElement(e);
              if (
                n &&
                n.getAttribute("listIndent") > t.getAttribute("listIndent")
              ) {
                o = e;
              } else {
                break;
              }
            }
            if (o) {
              s.breakContainer(s.createPositionAfter(o));
              s.move(s.createRangeOn(o.parent), s.createPositionAt(e, "end"));
            }
          }
        }
        RS(s, i, i.nextSibling);
        RS(s, i.previousSibling, i);
      }
      function RS(t, e, n) {
        if (!e || !n || (e.name != "ul" && e.name != "ol")) {
          return null;
        }
        if (
          e.name != n.name ||
          e.getAttribute("class") !== n.getAttribute("class")
        ) {
          return null;
        }
        return t.mergeContainers(t.createPositionAfter(e));
      }
      function FS(t) {
        return t.getLastMatchingPosition((t) => t.item.is("uiElement"));
      }
      function NS(t, e) {
        const n = !!e.sameIndent;
        const o = !!e.smallerIndent;
        const i = e.listIndent;
        let r = t;
        while (r && r.name == "listItem") {
          const t = r.getAttribute("listIndent");
          if ((n && i == t) || (o && i > t)) {
            return r;
          }
          if (e.direction === "forward") {
            r = r.nextSibling;
          } else {
            r = r.previousSibling;
          }
        }
        return null;
      }
      function MS(t, e, n, o) {
        t.ui.componentFactory.add(e, (i) => {
          const r = t.commands.get(e);
          const s = new ow(i);
          s.set({ label: n, icon: o, tooltip: true, isToggleable: true });
          s.bind("isOn", "isEnabled").to(r, "value", "isEnabled");
          s.on("execute", () => {
            t.execute(e);
            t.editing.view.focus();
          });
          return s;
        });
      }
      function VS(t) {
        for (const e of t.getChildren()) {
          if (e.name == "ul" || e.name == "ol") {
            return e;
          }
        }
        return null;
      }
      function LS(t, e) {
        const n = [];
        const o = t.parent;
        const i = {
          ignoreElementEnd: true,
          startPosition: t,
          shallow: true,
          direction: e,
        };
        const r = o.getAttribute("listIndent");
        const s = [...new Hh(i)]
          .filter((t) => t.item.is("element"))
          .map((t) => t.item);
        for (const t of s) {
          if (!t.is("element", "listItem")) {
            break;
          }
          if (t.getAttribute("listIndent") < r) {
            break;
          }
          if (t.getAttribute("listIndent") > r) {
            continue;
          }
          if (t.getAttribute("listType") !== o.getAttribute("listType")) {
            break;
          }
          if (t.getAttribute("listStyle") !== o.getAttribute("listStyle")) {
            break;
          }
          if (e === "backward") {
            n.unshift(t);
          } else {
            n.push(t);
          }
        }
        return n;
      }
      function zS() {
        const t =
          !this.isEmpty &&
          (this.getChild(0).name == "ul" || this.getChild(0).name == "ol");
        if (this.isEmpty || t) {
          return 0;
        }
        return qc.call(this);
      }
      function jS(t) {
        return (e, n, o) => {
          const i = o.consumable;
          if (
            !i.test(n.item, "insert") ||
            !i.test(n.item, "attribute:listType") ||
            !i.test(n.item, "attribute:listIndent")
          ) {
            return;
          }
          i.consume(n.item, "insert");
          i.consume(n.item, "attribute:listType");
          i.consume(n.item, "attribute:listIndent");
          const r = n.item;
          const s = IS(r, o);
          OS(r, s, o, t);
        };
      }
      function KS(t) {
        return (e, n, o) => {
          const i = o.mapper.toViewPosition(n.position);
          const r = i.getLastMatchingPosition(
            (t) => !t.item.is("element", "li")
          );
          const s = r.nodeAfter;
          const a = o.writer;
          a.breakContainer(a.createPositionBefore(s));
          a.breakContainer(a.createPositionAfter(s));
          const c = s.parent;
          const l = c.previousSibling;
          const d = a.createRangeOn(c);
          const u = a.remove(d);
          if (l && l.nextSibling) {
            RS(a, l, l.nextSibling);
          }
          const h = o.mapper.toModelElement(s);
          oP(h.getAttribute("listIndent") + 1, n.position, d.start, s, o, t);
          for (const t of a.createRangeIn(u).getItems()) {
            o.mapper.unbindViewElement(t);
          }
          e.stop();
        };
      }
      function qS(t, e, n) {
        if (!n.consumable.consume(e.item, "attribute:listType")) {
          return;
        }
        const o = n.mapper.toViewElement(e.item);
        const i = n.writer;
        i.breakContainer(i.createPositionBefore(o));
        i.breakContainer(i.createPositionAfter(o));
        const r = o.parent;
        const s = e.attributeNewValue == "numbered" ? "ol" : "ul";
        i.rename(s, r);
      }
      function $S(t, e, n) {
        const o = n.mapper.toViewElement(e.item);
        const i = o.parent;
        const r = n.writer;
        RS(r, i, i.nextSibling);
        RS(r, i.previousSibling, i);
        for (const t of e.item.getChildren()) {
          n.consumable.consume(t, "insert");
        }
      }
      function WS(t) {
        return (e, n, o) => {
          if (!o.consumable.consume(n.item, "attribute:listIndent")) {
            return;
          }
          const i = o.mapper.toViewElement(n.item);
          const r = o.writer;
          r.breakContainer(r.createPositionBefore(i));
          r.breakContainer(r.createPositionAfter(i));
          const s = i.parent;
          const a = s.previousSibling;
          const c = r.createRangeOn(s);
          r.remove(c);
          if (a && a.nextSibling) {
            RS(r, a, a.nextSibling);
          }
          oP(n.attributeOldValue + 1, n.range.start, c.start, i, o, t);
          OS(n.item, i, o, t);
          for (const t of n.item.getChildren()) {
            o.consumable.consume(t, "insert");
          }
        };
      }
      function GS(t, e, n) {
        if (e.item.name != "listItem") {
          let t = n.mapper.toViewPosition(e.range.start);
          const o = n.writer;
          const i = [];
          while (t.parent.name == "ul" || t.parent.name == "ol") {
            t = o.breakContainer(t);
            if (t.parent.name != "li") {
              break;
            }
            const e = t;
            const n = o.createPositionAt(t.parent, "end");
            if (!e.isEqual(n)) {
              const t = o.remove(o.createRange(e, n));
              i.push(t);
            }
            t = o.createPositionAfter(t.parent);
          }
          if (i.length > 0) {
            for (let e = 0; e < i.length; e++) {
              const n = t.nodeBefore;
              const r = o.insert(t, i[e]);
              t = r.end;
              if (e > 0) {
                const e = RS(o, n, n.nextSibling);
                if (e && e.parent == n) {
                  t.offset--;
                }
              }
            }
            RS(o, t.nodeBefore, t.nodeAfter);
          }
        }
      }
      function US(t, e, n) {
        const o = n.mapper.toViewPosition(e.position);
        const i = o.nodeBefore;
        const r = o.nodeAfter;
        RS(n.writer, i, r);
      }
      function HS(t, e, n) {
        if (n.consumable.consume(e.viewItem, { name: true })) {
          const t = n.writer;
          const o = t.createElement("listItem");
          const i = rP(e.viewItem);
          t.setAttribute("listIndent", i, o);
          const r =
            e.viewItem.parent && e.viewItem.parent.name == "ol"
              ? "numbered"
              : "bulleted";
          t.setAttribute("listType", r, o);
          if (!n.safeInsert(o, e.modelCursor)) {
            return;
          }
          const s = eP(o, e.viewItem.getChildren(), n);
          e.modelRange = t.createRange(e.modelCursor, s);
          n.updateConversionResult(o, e);
        }
      }
      function JS(t, e, n) {
        if (n.consumable.test(e.viewItem, { name: true })) {
          const t = Array.from(e.viewItem.getChildren());
          for (const e of t) {
            const t = !(e.is("element", "li") || iP(e));
            if (t) {
              e._remove();
            }
          }
        }
      }
      function YS(t, e, n) {
        if (n.consumable.test(e.viewItem, { name: true })) {
          if (e.viewItem.childCount === 0) {
            return;
          }
          const t = [...e.viewItem.getChildren()];
          let n = false;
          let o = true;
          for (const e of t) {
            if (n && !iP(e)) {
              e._remove();
            }
            if (e.is("$text")) {
              if (o) {
                e._data = e.data.replace(/^\s+/, "");
              }
              if (!e.nextSibling || iP(e.nextSibling)) {
                e._data = e.data.replace(/\s+$/, "");
              }
            } else if (iP(e)) {
              n = true;
            }
            o = false;
          }
        }
      }
      function QS(t) {
        return (e, n) => {
          if (n.isPhantom) {
            return;
          }
          const o = n.modelPosition.nodeBefore;
          if (o && o.is("element", "listItem")) {
            const e = n.mapper.toViewElement(o);
            const i = e.getAncestors().find(iP);
            const r = t.createPositionAt(e, 0).getWalker();
            for (const t of r) {
              if (t.type == "elementStart" && t.item.is("element", "li")) {
                n.viewPosition = t.previousPosition;
                break;
              } else if (t.type == "elementEnd" && t.item == i) {
                n.viewPosition = t.nextPosition;
                break;
              }
            }
          }
        };
      }
      function XS(t) {
        return (e, n) => {
          const o = n.viewPosition;
          const i = o.parent;
          const r = n.mapper;
          if (i.name == "ul" || i.name == "ol") {
            if (!o.isAtEnd) {
              const e = r.toModelElement(o.nodeAfter);
              n.modelPosition = t.createPositionBefore(e);
            } else {
              const e = r.toModelElement(o.nodeBefore);
              const i = r.getModelLength(o.nodeBefore);
              n.modelPosition = t.createPositionBefore(e).getShiftedBy(i);
            }
            e.stop();
          } else if (
            i.name == "li" &&
            o.nodeBefore &&
            (o.nodeBefore.name == "ul" || o.nodeBefore.name == "ol")
          ) {
            const s = r.toModelElement(i);
            let a = 1;
            let c = o.nodeBefore;
            while (c && iP(c)) {
              a += r.getModelLength(c);
              c = c.previousSibling;
            }
            n.modelPosition = t.createPositionBefore(s).getShiftedBy(a);
            e.stop();
          }
        };
      }
      function ZS(t, e) {
        const n = t.document.differ.getChanges();
        const o = new Map();
        let i = false;
        for (const o of n) {
          if (o.type == "insert" && o.name == "listItem") {
            r(o.position);
          } else if (o.type == "insert" && o.name != "listItem") {
            if (o.name != "$text") {
              const n = o.position.nodeAfter;
              if (n.hasAttribute("listIndent")) {
                e.removeAttribute("listIndent", n);
                i = true;
              }
              if (n.hasAttribute("listType")) {
                e.removeAttribute("listType", n);
                i = true;
              }
              if (n.hasAttribute("listStyle")) {
                e.removeAttribute("listStyle", n);
                i = true;
              }
              for (const e of Array.from(t.createRangeIn(n)).filter((t) =>
                t.item.is("element", "listItem")
              )) {
                r(e.previousPosition);
              }
            }
            const n = o.position.getShiftedBy(o.length);
            r(n);
          } else if (o.type == "remove" && o.name == "listItem") {
            r(o.position);
          } else if (o.type == "attribute" && o.attributeKey == "listIndent") {
            r(o.range.start);
          } else if (o.type == "attribute" && o.attributeKey == "listType") {
            r(o.range.start);
          }
        }
        for (const t of o.values()) {
          s(t);
          a(t);
        }
        return i;
        function r(t) {
          const e = t.nodeBefore;
          if (!e || !e.is("element", "listItem")) {
            const e = t.nodeAfter;
            if (e && e.is("element", "listItem")) {
              o.set(e, e);
            }
          } else {
            let t = e;
            if (o.has(t)) {
              return;
            }
            for (
              let e = t.previousSibling;
              e && e.is("element", "listItem");
              e = t.previousSibling
            ) {
              t = e;
              if (o.has(t)) {
                return;
              }
            }
            o.set(e, t);
          }
        }
        function s(t) {
          let n = 0;
          let o = null;
          while (t && t.is("element", "listItem")) {
            const r = t.getAttribute("listIndent");
            if (r > n) {
              let s;
              if (o === null) {
                o = r - n;
                s = n;
              } else {
                if (o > r) {
                  o = r;
                }
                s = r - o;
              }
              e.setAttribute("listIndent", s, t);
              i = true;
            } else {
              o = null;
              n = t.getAttribute("listIndent") + 1;
            }
            t = t.nextSibling;
          }
        }
        function a(t) {
          let n = [];
          let o = null;
          while (t && t.is("element", "listItem")) {
            const r = t.getAttribute("listIndent");
            if (o && o.getAttribute("listIndent") > r) {
              n = n.slice(0, r + 1);
            }
            if (r != 0) {
              if (n[r]) {
                const o = n[r];
                if (t.getAttribute("listType") != o) {
                  e.setAttribute("listType", o, t);
                  i = true;
                }
              } else {
                n[r] = t.getAttribute("listType");
              }
            }
            o = t;
            t = t.nextSibling;
          }
        }
      }
      function tP(t, [e, n]) {
        let o = e.is("documentFragment") ? e.getChild(0) : e;
        let i;
        if (!n) {
          i = this.document.selection;
        } else {
          i = this.createSelection(n);
        }
        if (o && o.is("element", "listItem")) {
          const t = i.getFirstPosition();
          let e = null;
          if (t.parent.is("element", "listItem")) {
            e = t.parent;
          } else if (t.nodeBefore && t.nodeBefore.is("element", "listItem")) {
            e = t.nodeBefore;
          }
          if (e) {
            const t = e.getAttribute("listIndent");
            if (t > 0) {
              while (o && o.is("element", "listItem")) {
                o._setAttribute("listIndent", o.getAttribute("listIndent") + t);
                o = o.nextSibling;
              }
            }
          }
        }
      }
      function eP(t, e, n) {
        const { writer: o, schema: i } = n;
        let r = o.createPositionAfter(t);
        for (const s of e) {
          if (s.name == "ul" || s.name == "ol") {
            r = n.convertItem(s, r).modelCursor;
          } else {
            const e = n.convertItem(s, o.createPositionAt(t, "end"));
            const a = e.modelRange.start.nodeAfter;
            const c = a && a.is("element") && !i.checkChild(t, a.name);
            if (c) {
              if (e.modelCursor.parent.is("element", "listItem")) {
                t = e.modelCursor.parent;
              } else {
                t = nP(e.modelCursor);
              }
              r = o.createPositionAfter(t);
            }
          }
        }
        return r;
      }
      function nP(t) {
        const e = new Hh({ startPosition: t });
        let n;
        do {
          n = e.next();
        } while (!n.value.item.is("element", "listItem"));
        return n.value.item;
      }
      function oP(t, e, n, o, i, r) {
        const s = NS(e.nodeBefore, {
          sameIndent: true,
          smallerIndent: true,
          listIndent: t,
          foo: "b",
        });
        const a = i.mapper;
        const c = i.writer;
        const l = s ? s.getAttribute("listIndent") : null;
        let d;
        if (!s) {
          d = n;
        } else if (l == t) {
          const t = a.toViewElement(s).parent;
          d = c.createPositionAfter(t);
        } else {
          const t = r.createPositionAt(s, "end");
          d = a.toViewPosition(t);
        }
        d = FS(d);
        for (const t of [...o.getChildren()]) {
          if (iP(t)) {
            d = c.move(c.createRangeOn(t), d).end;
            RS(c, t, t.nextSibling);
            RS(c, t.previousSibling, t);
          }
        }
      }
      function iP(t) {
        return t.is("element", "ol") || t.is("element", "ul");
      }
      function rP(t) {
        let e = 0;
        let n = t.parent;
        while (n) {
          if (n.is("element", "li")) {
            e++;
          } else {
            const t = n.previousSibling;
            if (t && t.is("element", "li")) {
              e++;
            }
          }
          n = n.parent;
        }
        return e;
      }
      class sP extends t_ {
        static get pluginName() {
          return "ListEditing";
        }
        static get requires() {
          return [UA];
        }
        init() {
          const t = this.editor;
          t.model.schema.register("listItem", {
            inheritAllFrom: "$block",
            allowAttributes: ["listType", "listIndent"],
          });
          const e = t.data;
          const n = t.editing;
          t.model.document.registerPostFixer((e) => ZS(t.model, e));
          n.mapper.registerViewToModelLength("li", aP);
          e.mapper.registerViewToModelLength("li", aP);
          n.mapper.on("modelToViewPosition", QS(n.view));
          n.mapper.on("viewToModelPosition", XS(t.model));
          e.mapper.on("modelToViewPosition", QS(n.view));
          t.conversion.for("editingDowncast").add((e) => {
            e.on("insert", GS, { priority: "high" });
            e.on("insert:listItem", jS(t.model));
            e.on("attribute:listType:listItem", qS, { priority: "high" });
            e.on("attribute:listType:listItem", $S, { priority: "low" });
            e.on("attribute:listIndent:listItem", WS(t.model));
            e.on("remove:listItem", KS(t.model));
            e.on("remove", US, { priority: "low" });
          });
          t.conversion.for("dataDowncast").add((e) => {
            e.on("insert", GS, { priority: "high" });
            e.on("insert:listItem", jS(t.model));
          });
          t.conversion.for("upcast").add((t) => {
            t.on("element:ul", JS, { priority: "high" });
            t.on("element:ol", JS, { priority: "high" });
            t.on("element:li", YS, { priority: "high" });
            t.on("element:li", HS);
          });
          t.model.on("insertContent", tP, { priority: "high" });
          t.commands.add("numberedList", new SS(t, "numbered"));
          t.commands.add("bulletedList", new SS(t, "bulleted"));
          t.commands.add("indentList", new TS(t, "forward"));
          t.commands.add("outdentList", new TS(t, "backward"));
          const o = n.view.document;
          this.listenTo(o, "enter", (t, e) => {
            const n = this.editor.model.document;
            const o = n.selection.getLastPosition().parent;
            if (n.selection.isCollapsed && o.name == "listItem" && o.isEmpty) {
              this.editor.execute("outdentList");
              e.preventDefault();
              t.stop();
            }
          });
          this.listenTo(
            o,
            "delete",
            (t, e) => {
              if (e.direction !== "backward") {
                return;
              }
              const n = this.editor.model.document.selection;
              if (!n.isCollapsed) {
                return;
              }
              const o = n.getFirstPosition();
              if (!o.isAtStart) {
                return;
              }
              const i = o.parent;
              if (i.name !== "listItem") {
                return;
              }
              const r =
                i.previousSibling && i.previousSibling.name === "listItem";
              if (r) {
                return;
              }
              this.editor.execute("outdentList");
              e.preventDefault();
              t.stop();
            },
            { priority: "high" }
          );
          const i = (t) => (e, n) => {
            const o = this.editor.commands.get(t);
            if (o.isEnabled) {
              this.editor.execute(t);
              n();
            }
          };
          t.keystrokes.set("Tab", i("indentList"));
          t.keystrokes.set("Shift+Tab", i("outdentList"));
        }
        afterInit() {
          const t = this.editor.commands;
          const e = t.get("indent");
          const n = t.get("outdent");
          if (e) {
            e.registerChildCommand(t.get("indentList"));
          }
          if (n) {
            n.registerChildCommand(t.get("outdentList"));
          }
        }
      }
      function aP(t) {
        let e = 1;
        for (const n of t.getChildren()) {
          if (n.name == "ul" || n.name == "ol") {
            for (const t of n.getChildren()) {
              e += aP(t);
            }
          }
        }
        return e;
      }
      var cP =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>';
      var lP =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>';
      class dP extends t_ {
        init() {
          const t = this.editor.t;
          MS(this.editor, "numberedList", t("Numbered List"), cP);
          MS(this.editor, "bulletedList", t("Bulleted List"), lP);
        }
      }
      class uP extends t_ {
        static get requires() {
          return [sP, dP];
        }
        static get pluginName() {
          return "List";
        }
      }
      const hP = "strikethrough";
      class fP extends t_ {
        static get pluginName() {
          return "StrikethroughEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: hP });
          t.model.schema.setAttributeProperties(hP, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: hP,
            view: "s",
            upcastAlso: [
              "del",
              "strike",
              { styles: { "text-decoration": "line-through" } },
            ],
          });
          t.commands.add(hP, new b_(t, hP));
          t.keystrokes.set("CTRL+SHIFT+X", "strikethrough");
        }
      }
      var gP =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9L6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>';
      const pP = "strikethrough";
      class mP extends t_ {
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(pP, (n) => {
            const o = t.commands.get(pP);
            const i = new ow(n);
            i.set({
              label: e("Strikethrough"),
              icon: gP,
              keystroke: "CTRL+SHIFT+X",
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute(pP);
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class kP extends t_ {
        static get requires() {
          return [fP, mP];
        }
        static get pluginName() {
          return "Strikethrough";
        }
      }
      const bP = "underline";
      class wP extends t_ {
        static get pluginName() {
          return "UnderlineEditing";
        }
        init() {
          const t = this.editor;
          t.model.schema.extend("$text", { allowAttributes: bP });
          t.model.schema.setAttributeProperties(bP, {
            isFormatting: true,
            copyOnEnter: true,
          });
          t.conversion.attributeToElement({
            model: bP,
            view: "u",
            upcastAlso: { styles: { "text-decoration": "underline" } },
          });
          t.commands.add(bP, new b_(t, bP));
          t.keystrokes.set("CTRL+U", "underline");
        }
      }
      var _P =
        '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>';
      const AP = "underline";
      class CP extends t_ {
        init() {
          const t = this.editor;
          const e = t.t;
          t.ui.componentFactory.add(AP, (n) => {
            const o = t.commands.get(AP);
            const i = new ow(n);
            i.set({
              label: e("Underline"),
              icon: _P,
              keystroke: "CTRL+U",
              tooltip: true,
              isToggleable: true,
            });
            i.bind("isOn", "isEnabled").to(o, "value", "isEnabled");
            this.listenTo(i, "execute", () => {
              t.execute(AP);
              t.editing.view.focus();
            });
            return i;
          });
        }
      }
      class vP extends t_ {
        static get requires() {
          return [wP, CP];
        }
        static get pluginName() {
          return "Underline";
        }
      }
      function yP(t) {
        if (t.is("$text") || t.is("$textProxy")) {
          return t.data;
        }
        let e = "";
        let n = null;
        for (const o of t.getChildren()) {
          const t = yP(o);
          if (n && n.is("element")) {
            e += "\n";
          }
          e += t;
          n = o;
        }
        return e;
      }
      var xP = "Expected a function";
      function EP(t, e, n) {
        var o = true,
          i = true;
        if (typeof t != "function") {
          throw new TypeError(xP);
        }
        if (ct(n)) {
          o = "leading" in n ? !!n.leading : o;
          i = "trailing" in n ? !!n.trailing : i;
        }
        return kh(t, e, { leading: o, maxWait: e, trailing: i });
      }
      var SP = EP;
      class PP extends t_ {
        constructor(t) {
          super(t);
          this.set("characters", 0);
          this.set("words", 0);
          Object.defineProperties(this, {
            characters: {
              get() {
                return (this.characters = this._getCharacters());
              },
            },
            words: {
              get() {
                return (this.words = this._getWords());
              },
            },
          });
          this.set("_wordsLabel");
          this.set("_charactersLabel");
          this._config = t.config.get("wordCount") || {};
          this._outputView = undefined;
          this._wordsMatchRegExp = El.features.isRegExpUnicodePropertySupported
            ? new RegExp("[\\p{L}\\p{N}\\p{M}\\p{Pd}\\p{Pc}]+", "gu")
            : /[_\-a-zA-Z0-9-]+/gu;
        }
        static get pluginName() {
          return "WordCount";
        }
        init() {
          const t = this.editor;
          t.model.document.on(
            "change:data",
            SP(this._refreshStats.bind(this), 250)
          );
          if (typeof this._config.onUpdate == "function") {
            this.on("update", (t, e) => {
              this._config.onUpdate(e);
            });
          }
          if (Hr(this._config.container)) {
            this._config.container.appendChild(this.wordCountContainer);
          }
        }
        destroy() {
          if (this._outputView) {
            this._outputView.element.remove();
            this._outputView.destroy();
          }
          super.destroy();
        }
        get wordCountContainer() {
          const t = this.editor;
          const e = t.t;
          const n = t.config.get("wordCount.displayWords");
          const o = t.config.get("wordCount.displayCharacters");
          const i = Ck.bind(this, this);
          const r = [];
          if (!this._outputView) {
            this._outputView = new Xk();
            if (n || n === undefined) {
              this.bind("_wordsLabel").to(this, "words", (t) =>
                e("Words: %0", t)
              );
              r.push({
                tag: "div",
                children: [{ text: [i.to("_wordsLabel")] }],
                attributes: { class: "ck-word-count__words" },
              });
            }
            if (o || o === undefined) {
              this.bind("_charactersLabel").to(this, "characters", (t) =>
                e("Characters: %0", t)
              );
              r.push({
                tag: "div",
                children: [{ text: [i.to("_charactersLabel")] }],
                attributes: { class: "ck-word-count__characters" },
              });
            }
            this._outputView.setTemplate({
              tag: "div",
              attributes: { class: ["ck", "ck-word-count"] },
              children: r,
            });
            this._outputView.render();
          }
          return this._outputView.element;
        }
        _getCharacters() {
          const t = yP(this.editor.model.document.getRoot());
          return t.replace(/\n/g, "").length;
        }
        _getWords() {
          const t = yP(this.editor.model.document.getRoot());
          const e = t.match(this._wordsMatchRegExp) || [];
          return e.length;
        }
        _refreshStats() {
          const t = (this.words = this._getWords());
          const e = (this.characters = this._getCharacters());
          this.fire("update", { words: t, characters: e });
        }
      }
      class DP extends Uw {}
      DP.builtinPlugins = [
        n_,
        k_,
        y_,
        qA,
        rC,
        Ay,
        Ey,
        wx,
        xx,
        ES,
        uP,
        UA,
        kP,
        vP,
        PP,
      ];
      var TP = (e["default"] = DP);
    },
  ])["default"];
});
//# sourceMappingURL=ckeditor.js.map
